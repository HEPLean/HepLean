/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.FieldStruct.OperatorAlgebra
import HepLean.PerturbationTheory.Wick.Signs.KoszulSign
/-!

# State algebra

We define the state algebra of a field structure to be the free algebra
generated by the states.

-/

namespace FieldStruct
variable {ğ“• : FieldStruct}

/-- The normal ordering on creation and annihlation states. -/
def normalOrderProp : ğ“•.CrAnStates â†’ ğ“•.CrAnStates â†’ Prop :=
  fun a b => CreateAnnihilate.normalOrder (ğ“•.crAnStatesToCreateAnnihilate a)
    (ğ“•.crAnStatesToCreateAnnihilate b)

/-- Normal ordering is total. -/
instance : IsTotal ğ“•.CrAnStates ğ“•.normalOrderProp where
  total _ _ := total_of CreateAnnihilate.normalOrder _ _

/-- Normal ordering is transitive. -/
instance : IsTrans ğ“•.CrAnStates ğ“•.normalOrderProp where
  trans _ _ _ := fun h h' => IsTrans.trans (Î± := CreateAnnihilate) _ _ _ h h'

instance (Ï† Ï†' : ğ“•.CrAnStates) :  Decidable (normalOrderProp Ï† Ï†') :=
  CreateAnnihilate.instDecidableNormalOrder (ğ“•.crAnStatesToCreateAnnihilate Ï†)
    (ğ“•.crAnStatesToCreateAnnihilate Ï†')

/-!

## Normal order sign.

-/
def normalOrderSign (Ï†s : List ğ“•.CrAnStates) : â„‚ :=
  Wick.koszulSign ğ“•.crAnStatesStatistics ğ“•.normalOrderProp Ï†s

lemma koszulSignInsert_create  (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) : (Ï†s : List ğ“•.CrAnStates) â†’
    Wick.koszulSignInsert ğ“•.crAnStatesStatistics normalOrderProp Ï† Ï†s = 1
  | [] => rfl
  | Ï†' :: Ï†s => by
    dsimp [Wick.koszulSignInsert]
    rw [if_pos]
    Â· exact koszulSignInsert_create Ï† hÏ† Ï†s
    Â· dsimp [normalOrderProp]
      rw [hÏ†]
      dsimp [CreateAnnihilate.normalOrder]

lemma normalOrderSign_cons_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    normalOrderSign (Ï† :: Ï†s) = normalOrderSign Ï†s := by
  dsimp [normalOrderSign, Wick.koszulSign]
  rw [koszulSignInsert_create Ï† hÏ† Ï†s]
  simp

@[simp]
lemma normalOrderSign_singleton (Ï† : ğ“•.CrAnStates) :
    normalOrderSign [Ï†] = 1 := by
  simp [normalOrderSign]

@[simp]
lemma normalOrderSign_nil :
    normalOrderSign (ğ“• := ğ“•) [] = 1 := by
  simp [normalOrderSign, Wick.koszulSign]

lemma koszulSignInsert_append_annihilate (Ï†' Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    (Ï†s : List ğ“•.CrAnStates) â†’
    Wick.koszulSignInsert ğ“•.crAnStatesStatistics normalOrderProp Ï†' (Ï†s ++ [Ï†]) =
    Wick.koszulSignInsert ğ“•.crAnStatesStatistics normalOrderProp Ï†' Ï†s
  | [] => by
    simp [Wick.koszulSignInsert, normalOrderProp, hÏ†]
  | Ï†'' :: Ï†s => by
    dsimp [Wick.koszulSignInsert]
    rw [koszulSignInsert_append_annihilate Ï†' Ï† hÏ† Ï†s]

lemma normalOrderSign_append_annihlate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate)  :
    (Ï†s : List ğ“•.CrAnStates) â†’
    normalOrderSign (Ï†s ++ [Ï†]) = normalOrderSign Ï†s
  | [] => by simp
  | Ï†' :: Ï†s => by
    dsimp [normalOrderSign, Wick.koszulSign]
    have hi := normalOrderSign_append_annihlate Ï† hÏ† Ï†s
    dsimp [normalOrderSign] at hi
    rw [hi, koszulSignInsert_append_annihilate Ï†' Ï† hÏ† Ï†s]

lemma koszulSignInsert_annihilate_cons_create (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) :
    Wick.koszulSignInsert ğ“•.crAnStatesStatistics normalOrderProp Ï†a (Ï†c :: Ï†s)
    = FieldStatistic.pairedSign (ğ“•.crAnStatesStatistics Ï†c) (ğ“•.crAnStatesStatistics Ï†a) *
    Wick.koszulSignInsert ğ“•.crAnStatesStatistics normalOrderProp Ï†a Ï†s := by
  rw [Wick.koszulSignInsert_cons]
  simp
  apply Or.inl
  rw [Wick.koszulSignCons, if_neg, FieldStatistic.pairedSign_symm, FieldStatistic.pairedSign_eq_if]
  rw [normalOrderProp, hÏ†a, hÏ†c]
  simp [CreateAnnihilate.normalOrder]

lemma normalOrderSign_swap_create_annihlate_fst (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) :
    normalOrderSign (Ï†c :: Ï†a :: Ï†s) =
    FieldStatistic.pairedSign (ğ“•.crAnStatesStatistics Ï†c) (ğ“•.crAnStatesStatistics Ï†a) *
    normalOrderSign (Ï†a :: Ï†c :: Ï†s) := by
  rw [normalOrderSign_cons_create Ï†c hÏ†c (Ï†a :: Ï†s)]
  conv_rhs =>
    rw [normalOrderSign]
    rw [Wick.koszulSign]
    rw [â† normalOrderSign]
    rw [koszulSignInsert_annihilate_cons_create Ï†c Ï†a hÏ†c hÏ†a Ï†s]
  rw [â† mul_assoc, â† mul_assoc, FieldStatistic.pairedSign_mul_self]
  simp
  rw [normalOrderSign_cons_create Ï†c hÏ†c Ï†s]
  rfl

lemma koszulSignInsert_swap (Ï† Ï†c Ï†a : ğ“•.CrAnStates)
    : (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    Wick.koszulSignInsert ğ“•.crAnStatesStatistics normalOrderProp Ï† (Ï†s ++ Ï†a :: Ï†c :: Ï†s')
    = Wick.koszulSignInsert ğ“•.crAnStatesStatistics normalOrderProp Ï†  (Ï†s ++ Ï†c :: Ï†a :: Ï†s') := by
  intro Ï†s Ï†s'
  apply Wick.koszulSignInsert_eq_perm
  refine List.Perm.append_left Ï†s ?h.a
  exact List.Perm.swap Ï†c Ï†a Ï†s'


lemma normalOrderSign_swap_create_annihlate (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
     : (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    normalOrderSign (Ï†s ++ Ï†c :: Ï†a :: Ï†s') =
    FieldStatistic.pairedSign (ğ“•.crAnStatesStatistics Ï†c) (ğ“•.crAnStatesStatistics Ï†a) *
    normalOrderSign (Ï†s ++ Ï†a :: Ï†c :: Ï†s')
  | [], Ï†s' => by
    exact normalOrderSign_swap_create_annihlate_fst Ï†c Ï†a hÏ†c hÏ†a Ï†s'
  | Ï† :: Ï†s, Ï†s' => by
    rw [normalOrderSign]
    dsimp [Wick.koszulSign]
    rw [â† normalOrderSign]
    rw [normalOrderSign_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a Ï†s Ï†s']
    rw [â† mul_assoc, mul_comm _ (FieldStatistic.pairedSign _ _), mul_assoc]
    simp
    apply Or.inl
    conv_rhs =>
      rw [normalOrderSign]
      dsimp [Wick.koszulSign]
      rw [â† normalOrderSign]
    simp
    apply Or.inl
    rw [koszulSignInsert_swap]


lemma normalOrderSign_swap_create_create_fst (Ï†c Ï†c' : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†c' : ğ“•.crAnStatesToCreateAnnihilate Ï†c' = CreateAnnihilate.create)
    (Ï†s : List ğ“•.CrAnStates) :
    normalOrderSign (Ï†c :: Ï†c' :: Ï†s) =
    normalOrderSign (Ï†c' :: Ï†c :: Ï†s) := by
  rw [normalOrderSign_cons_create Ï†c hÏ†c, normalOrderSign_cons_create Ï†c' hÏ†c']
  rw [normalOrderSign_cons_create Ï†c' hÏ†c', normalOrderSign_cons_create Ï†c hÏ†c]

lemma normalOrderSign_swap_create_create (Ï†c Ï†c' : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†c' : ğ“•.crAnStatesToCreateAnnihilate Ï†c' = CreateAnnihilate.create)
    :  (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    normalOrderSign (Ï†s ++ Ï†c :: Ï†c' :: Ï†s') =
    normalOrderSign (Ï†s ++ Ï†c' :: Ï†c :: Ï†s')
  | [], Ï†s' => by
    exact normalOrderSign_swap_create_create_fst Ï†c Ï†c' hÏ†c hÏ†c' Ï†s'
  | Ï† :: Ï†s, Ï†s' => by
    rw [normalOrderSign]
    dsimp [Wick.koszulSign]
    rw [â† normalOrderSign]
    rw [normalOrderSign_swap_create_create Ï†c Ï†c' hÏ†c hÏ†c']
    dsimp [normalOrderSign, Wick.koszulSign]
    rw [â† normalOrderSign]
    simp
    apply Or.inl
    apply Wick.koszulSignInsert_eq_perm
    refine List.Perm.append_left Ï†s ?h.h.a
    exact List.Perm.swap Ï†c' Ï†c Ï†s'

lemma normalOrderSign_swap_annihilate_annihilate_fst (Ï†a Ï†a' : ğ“•.CrAnStates)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (hÏ†a' : ğ“•.crAnStatesToCreateAnnihilate Ï†a' = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) :
    normalOrderSign (Ï†a :: Ï†a' :: Ï†s) =
    normalOrderSign (Ï†a' :: Ï†a :: Ï†s) := by
  rw [normalOrderSign, normalOrderSign]
  dsimp [Wick.koszulSign]
  rw [â† mul_assoc, â† mul_assoc]
  congr 1
  rw [Wick.koszulSignInsert_cons, Wick.koszulSignInsert_cons]
  rw [mul_assoc, mul_assoc]
  congr 1
  Â· dsimp [Wick.koszulSignCons]
    rw [if_pos, if_pos]
    Â· simp [normalOrderProp, hÏ†a, hÏ†a', CreateAnnihilate.normalOrder]
    Â· simp [normalOrderProp, hÏ†a, hÏ†a', CreateAnnihilate.normalOrder]
  Â· rw [NonUnitalNormedCommRing.mul_comm]

lemma normalOrderSign_swap_annihilate_annihilate (Ï†a Ï†a' : ğ“•.CrAnStates)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (hÏ†a' : ğ“•.crAnStatesToCreateAnnihilate Ï†a' = CreateAnnihilate.annihilate)
    :  (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    normalOrderSign (Ï†s ++ Ï†a :: Ï†a' :: Ï†s') =
    normalOrderSign (Ï†s ++ Ï†a' :: Ï†a :: Ï†s')
  | [], Ï†s' => by
    exact normalOrderSign_swap_annihilate_annihilate_fst Ï†a Ï†a' hÏ†a hÏ†a' Ï†s'
  | Ï† :: Ï†s, Ï†s' => by
    rw [normalOrderSign]
    dsimp [Wick.koszulSign]
    rw [â† normalOrderSign]
    rw [normalOrderSign_swap_annihilate_annihilate Ï†a Ï†a' hÏ†a hÏ†a']
    dsimp [normalOrderSign, Wick.koszulSign]
    rw [â† normalOrderSign]
    simp
    apply Or.inl
    apply Wick.koszulSignInsert_eq_perm
    refine List.Perm.append_left Ï†s ?h.h.a
    exact List.Perm.swap Ï†a' Ï†a Ï†s'


/-!

##Â Normal order of lists

-/

def normalOrderList (Ï†s : List ğ“•.CrAnStates) : List ğ“•.CrAnStates :=
  List.insertionSort ğ“•.normalOrderProp Ï†s


@[simp]
lemma normalOrderList_nil : normalOrderList (ğ“• := ğ“•) [] = [] := by
  simp [normalOrderList]

lemma orderedInsert_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) :
    (Ï†s : List ğ“•.CrAnStates) â†’ List.orderedInsert normalOrderProp Ï† Ï†s = Ï† :: Ï†s
  | [] => rfl
  | Ï†' :: Ï†s => by
    dsimp [List.orderedInsert]
    rw [if_pos]
    dsimp [normalOrderProp]
    rw [hÏ†]
    dsimp [CreateAnnihilate.normalOrder]

lemma normalOrderList_cons_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    normalOrderList (Ï† :: Ï†s) = Ï† :: normalOrderList Ï†s := by
  simp [normalOrderList, List.insertionSort]
  rw [orderedInsert_create Ï† hÏ†]

lemma orderedInsert_append_annihilate (Ï†' Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    (Ï†s : List ğ“•.CrAnStates) â†’ List.orderedInsert normalOrderProp Ï†' (Ï†s ++ [Ï†]) =
    List.orderedInsert normalOrderProp Ï†' Ï†s ++ [Ï†]
  | [] => by
    simp [Wick.koszulSignInsert, normalOrderProp, hÏ†]
  | Ï†'' :: Ï†s => by
    dsimp [List.orderedInsert]
    have hi := orderedInsert_append_annihilate Ï†' Ï† hÏ† Ï†s
    rw [hi]
    split
    next h => simp_all only [List.cons_append]
    next h => simp_all only [List.cons_append]

lemma normalOrderList_append_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    (Ï†s : List ğ“•.CrAnStates) â†’
    normalOrderList (Ï†s ++ [Ï†]) = normalOrderList Ï†s ++ [Ï†]
  | [] => by simp [normalOrderList]
  | Ï†' :: Ï†s => by
    simp [normalOrderList, List.insertionSort]
    have hi := normalOrderList_append_annihilate Ï† hÏ† Ï†s
    dsimp [normalOrderList] at hi
    rw [hi, orderedInsert_append_annihilate Ï†' Ï† hÏ†]

lemma normalOrder_swap_create_annihlate_fst (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) :
    normalOrderList (Ï†c :: Ï†a :: Ï†s) = normalOrderList (Ï†a :: Ï†c :: Ï†s) := by
  rw [normalOrderList_cons_create Ï†c hÏ†c (Ï†a :: Ï†s)]
  conv_rhs =>
    rw [normalOrderList]
    rw [List.insertionSort]
  have hi := normalOrderList_cons_create Ï†c hÏ†c Ï†s
  rw [normalOrderList] at hi
  rw [hi]
  dsimp
  split
  Â· rename_i h
    rw [normalOrderProp, hÏ†a, hÏ†c] at h
    dsimp [CreateAnnihilate.normalOrder] at h
  Â· rfl

lemma normalOrderList_swap_create_annihlate (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate) :
    (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    normalOrderList (Ï†s ++ Ï†c :: Ï†a :: Ï†s') = normalOrderList (Ï†s ++ Ï†a :: Ï†c :: Ï†s')
  | [], Ï†s' => by
    exact normalOrder_swap_create_annihlate_fst Ï†c Ï†a hÏ†c hÏ†a Ï†s'
  | Ï† :: Ï†s, Ï†s' => by
    dsimp [normalOrderList]
    have hi := normalOrderList_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a Ï†s Ï†s'
    dsimp [normalOrderList] at hi
    rw [hi]



def createFilter (Ï†s : List ğ“•.CrAnStates) : List ğ“•.CrAnStates :=
  List.filter (fun Ï† => ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) Ï†s

lemma createFilter_cons_create {Ï† : ğ“•.CrAnStates}
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    createFilter (Ï† :: Ï†s) = Ï† :: createFilter Ï†s := by
  simp [createFilter]
  rw [List.filter_cons_of_pos]
  simp [hÏ†]

lemma createFilter_cons_annihilate {Ï† : ğ“•.CrAnStates}
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) (Ï†s : List ğ“•.CrAnStates) :
    createFilter (Ï† :: Ï†s) = createFilter Ï†s := by
  simp [createFilter]
  rw [List.filter_cons_of_neg]
  simp [hÏ†]

lemma createFilter_append (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    createFilter (Ï†s ++ Ï†s') = createFilter Ï†s ++ createFilter Ï†s' := by
  rw [createFilter, List.filter_append]
  rfl

lemma createFilter_singleton_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) :
    createFilter [Ï†] = [Ï†] := by
  simp [createFilter, hÏ†]

lemma createFilter_singleton_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    createFilter [Ï†] = [] := by
  simp [createFilter, hÏ†]

def annihilateFilter (Ï†s : List ğ“•.CrAnStates) : List ğ“•.CrAnStates :=
  List.filter (fun Ï† => ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) Ï†s

lemma annihilateFilter_cons_create {Ï† : ğ“•.CrAnStates}
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    annihilateFilter (Ï† :: Ï†s) = annihilateFilter Ï†s := by
  simp [annihilateFilter]
  rw [List.filter_cons_of_neg]
  simp [hÏ†]

lemma annihilateFilter_cons_annihilate {Ï† : ğ“•.CrAnStates}
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) (Ï†s : List ğ“•.CrAnStates) :
    annihilateFilter (Ï† :: Ï†s) = Ï† :: annihilateFilter Ï†s := by
  simp [annihilateFilter]
  rw [List.filter_cons_of_pos]
  simp [hÏ†]

lemma annihilateFilter_append (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    annihilateFilter (Ï†s ++ Ï†s') = annihilateFilter Ï†s ++ annihilateFilter Ï†s' := by
  rw [annihilateFilter, List.filter_append]
  rfl

lemma annihilateFilter_singleton_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) :
    annihilateFilter [Ï†] = [] := by
  simp [annihilateFilter, hÏ†]

lemma annihilateFilter_singleton_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    annihilateFilter [Ï†] = [Ï†] := by
  simp [annihilateFilter, hÏ†]

lemma orderedInsert_createFilter_append_annihilate  (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate)
     : (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    List.orderedInsert normalOrderProp Ï† (createFilter Ï†s ++ Ï†s') =
    createFilter Ï†s ++ List.orderedInsert normalOrderProp Ï† Ï†s'
  | [], Ï†s' => by simp [createFilter]
  | Ï†' :: Ï†s, Ï†s' => by
    rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†') with hÏ†' | hÏ†'
    Â· rw [createFilter_cons_create hÏ†']
      dsimp
      rw [if_neg]
      rw [orderedInsert_createFilter_append_annihilate Ï† hÏ† Ï†s Ï†s']
      simp [normalOrderProp, hÏ†, hÏ†', CreateAnnihilate.normalOrder]
    Â· rw [createFilter_cons_annihilate hÏ†']
      rw [orderedInsert_createFilter_append_annihilate Ï† hÏ† Ï†s]

lemma orderedInsert_annihilateFilter  (Ï† : ğ“•.CrAnStates)
     : (Ï†s : List ğ“•.CrAnStates) â†’
    List.orderedInsert normalOrderProp Ï† (annihilateFilter Ï†s ) =
    Ï† :: annihilateFilter Ï†s
  | [] => by simp [annihilateFilter]
  | Ï†' :: Ï†s  => by
    rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†') with hÏ†' | hÏ†'
    Â· rw [annihilateFilter_cons_create hÏ†']
      rw [orderedInsert_annihilateFilter Ï† Ï†s]
    Â· rw [annihilateFilter_cons_annihilate hÏ†']
      dsimp
      rw [if_pos]
      dsimp [normalOrderProp]
      rw [hÏ†']
      rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†) with hÏ† | hÏ†
      Â· rw [hÏ†]
        simp [CreateAnnihilate.normalOrder]
      Â· rw [hÏ†]
        simp [CreateAnnihilate.normalOrder]



lemma orderedInsert_createFilter_append_annihilateFilter_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    (Ï†s : List ğ“•.CrAnStates) â†’
     List.orderedInsert normalOrderProp Ï† (createFilter Ï†s ++ annihilateFilter Ï†s) =
    createFilter Ï†s ++ Ï† :: annihilateFilter Ï†s := by
  intro Ï†s
  rw [orderedInsert_createFilter_append_annihilate Ï† hÏ†, orderedInsert_annihilateFilter]

lemma normalOrderList_eq_createFilter_append_annihilateFilter : (Ï†s : List ğ“•.CrAnStates) â†’
    normalOrderList Ï†s = createFilter Ï†s ++ annihilateFilter Ï†s
  | [] => by simp [normalOrderList, createFilter, annihilateFilter]
  | Ï† :: Ï†s => by
    by_cases hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create
    Â· rw [normalOrderList_cons_create Ï† hÏ† Ï†s]
      dsimp [createFilter]
      rw [List.filter_cons_of_pos]
      swap
      simp [hÏ†]
      dsimp [annihilateFilter]
      rw [List.filter_cons_of_neg]
      swap
      simp [hÏ†]
      rw [normalOrderList_eq_createFilter_append_annihilateFilter Ï†s]
      rfl
    Â· dsimp [normalOrderList]
      rw [â† normalOrderList]
      have hÏ†' : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate := by
        have hx := CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†)
        simp_all
      rw [normalOrderList_eq_createFilter_append_annihilateFilter Ï†s]
      rw [orderedInsert_createFilter_append_annihilateFilter_annihilate Ï† hÏ†']
      rw [createFilter_cons_annihilate hÏ†']
      rw [annihilateFilter_cons_annihilate hÏ†']

/-!

## Normal order on the CrAnAlgebra

-/
namespace CrAnAlgebra

noncomputable section

def normalOrder : CrAnAlgebra ğ“• â†’â‚—[â„‚] CrAnAlgebra ğ“•  :=
  Basis.constr ofCrAnListBasis â„‚ fun Ï†s =>
  normalOrderSign Ï†s â€¢ ofCrAnList (normalOrderList Ï†s)

lemma normalOrder_ofCrAnList (Ï†s : List ğ“•.CrAnStates) :
    normalOrder (ofCrAnList Ï†s) = normalOrderSign Ï†s â€¢ ofCrAnList (normalOrderList Ï†s) := by
  rw [â† ofListBasis_eq_ofList]
  simp only [normalOrder, Basis.constr_basis]

lemma normalOrder_ofCrAnList_cons_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    normalOrder (ofCrAnList (Ï† :: Ï†s)) =
    ofCrAnState Ï† * normalOrder (ofCrAnList Ï†s) := by
  rw [normalOrder_ofCrAnList]
  rw [normalOrderSign_cons_create Ï† hÏ†, normalOrderList_cons_create Ï† hÏ† Ï†s]
  rw [ofCrAnList_cons, normalOrder_ofCrAnList, mul_smul_comm]

lemma normalOrder_create_mul  (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create)
    (a : CrAnAlgebra ğ“•) :
    normalOrder (ofCrAnState Ï† * a) = ofCrAnState Ï† * normalOrder a := by
  change (normalOrder âˆ˜â‚— mulLinearMap (ofCrAnState Ï†)) a =
    (mulLinearMap (ofCrAnState Ï†) âˆ˜â‚— normalOrder) a
  refine LinearMap.congr_fun ?h a
  apply ofCrAnListBasis.ext
  intro l
  simp [mulLinearMap]
  rw [â† ofCrAnList_cons]
  rw [normalOrder_ofCrAnList_cons_create Ï† hÏ†]

lemma normalOrder_ofCrAnList_append_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) (Ï†s : List ğ“•.CrAnStates) :
    normalOrder (ofCrAnList (Ï†s ++ [Ï†])) =
    normalOrder (ofCrAnList Ï†s) * ofCrAnState Ï† := by
  rw [normalOrder_ofCrAnList]
  rw [normalOrderSign_append_annihlate Ï† hÏ† Ï†s, normalOrderList_append_annihilate Ï† hÏ† Ï†s]
  rw [ofCrAnList_append, ofCrAnList_singleton, normalOrder_ofCrAnList, smul_mul_assoc]

lemma normalOrder_mul_annihilate  (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate)
    (a : CrAnAlgebra ğ“•) :
    normalOrder (a * ofCrAnState Ï†) = normalOrder a * ofCrAnState Ï† := by
  change (normalOrder âˆ˜â‚— mulLinearMap.flip (ofCrAnState Ï†)) a =
    (mulLinearMap.flip (ofCrAnState Ï†) âˆ˜â‚— normalOrder) a
  refine LinearMap.congr_fun ?h a
  apply ofCrAnListBasis.ext
  intro l
  simp [mulLinearMap]
  rw [â† ofCrAnList_singleton, â† ofCrAnList_append, ofCrAnList_singleton]
  rw [normalOrder_ofCrAnList_append_annihilate Ï† hÏ†]

lemma normalOrder_swap_create_annihlate_ofCrAnList_ofCrAnList (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    normalOrder (ofCrAnList Ï†s' * ofCrAnState Ï†c * ofCrAnState Ï†a * ofCrAnList Ï†s) =
    FieldStatistic.pairedSign (ğ“•.crAnStatesStatistics Ï†c) (ğ“•.crAnStatesStatistics Ï†a) â€¢
    normalOrder (ofCrAnList Ï†s' * ofCrAnState Ï†a * ofCrAnState Ï†c * ofCrAnList Ï†s)  := by
  rw [mul_assoc, mul_assoc, â† ofCrAnList_cons, â† ofCrAnList_cons, â† ofCrAnList_append]
  rw [normalOrder_ofCrAnList, normalOrderSign_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a]
  rw [normalOrderList_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a]
  rw [â† smul_smul, â† normalOrder_ofCrAnList]
  congr
  rw [ofCrAnList_append, ofCrAnList_cons, ofCrAnList_cons]
  noncomm_ring

lemma normalOrder_swap_create_annihlate_ofCrAnList (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) (a : ğ“•.CrAnAlgebra) :
    normalOrder (ofCrAnList Ï†s * ofCrAnState Ï†c * ofCrAnState Ï†a * a) =
    FieldStatistic.pairedSign (ğ“•.crAnStatesStatistics Ï†c) (ğ“•.crAnStatesStatistics Ï†a) â€¢
    normalOrder (ofCrAnList Ï†s * ofCrAnState Ï†a * ofCrAnState Ï†c * a)  := by
  change (normalOrder âˆ˜â‚— mulLinearMap (ofCrAnList Ï†s * ofCrAnState Ï†c * ofCrAnState Ï†a)) a =
    (smulLinearMap _ âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap (ofCrAnList Ï†s * ofCrAnState Ï†a * ofCrAnState Ï†c)) a
  refine LinearMap.congr_fun ?h a
  apply ofCrAnListBasis.ext
  intro l
  simp [mulLinearMap]
  rw [normalOrder_swap_create_annihlate_ofCrAnList_ofCrAnList Ï†c Ï†a hÏ†c hÏ†a ]
  rfl

lemma normalOrder_swap_create_annihlate (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (a b : ğ“•.CrAnAlgebra) :
    normalOrder (a * ofCrAnState Ï†c * ofCrAnState Ï†a * b) =
    FieldStatistic.pairedSign (ğ“•.crAnStatesStatistics Ï†c) (ğ“•.crAnStatesStatistics Ï†a) â€¢
    normalOrder (a * ofCrAnState Ï†a * ofCrAnState Ï†c * b)  := by
  rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc]
  change (normalOrder âˆ˜â‚— mulLinearMap.flip (ofCrAnState Ï†c * (ofCrAnState Ï†a * b))) a =
    (smulLinearMap (FieldStatistic.pairedSign (ğ“•.crAnStatesStatistics Ï†c) (ğ“•.crAnStatesStatistics Ï†a)) âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap.flip (ofCrAnState Ï†a * (ofCrAnState Ï†c * b))) a
  apply LinearMap.congr_fun
  apply ofCrAnListBasis.ext
  intro l
  simp [mulLinearMap]
  repeat rw [â† mul_assoc]
  rw [normalOrder_swap_create_annihlate_ofCrAnList Ï†c Ï†a hÏ†c hÏ†a ]
  rfl

lemma normalOrder_superCommute_create_annihilate (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (a b : ğ“•.CrAnAlgebra) :
    normalOrder (a * superCommute (ofCrAnState Ï†c) (ofCrAnState Ï†a) * b) = 0 := by
  rw [superCommute_ofCrAnState]
  simp
  rw [mul_sub, sub_mul, map_sub, â†  smul_mul_assoc]
  rw [â† mul_assoc, â† mul_assoc]
  rw [normalOrder_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a]
  simp only [FieldStatistic.instCommGroup.eq_1, Algebra.mul_smul_comm, Algebra.smul_mul_assoc,
    map_smul, sub_self]

lemma normalOrder_superCommute_annihilate_create (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (a b : ğ“•.CrAnAlgebra) :
    normalOrder (a * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†c) * b) = 0 := by
  rw [superCommute_ofCrAnState_symm]
  simp
  apply Or.inr
  exact normalOrder_superCommute_create_annihilate Ï†c Ï†a hÏ†c hÏ†a a b

lemma normalOrder_crPart_mul (Ï† : ğ“•.States) (a : CrAnAlgebra ğ“•) :
    normalOrder (crPart (StateAlgebra.ofState Ï†) * a) =
    crPart (StateAlgebra.ofState Ï†) * normalOrder a := by
  match Ï† with
  | .negAsymp Ï† =>
    dsimp [crPart, StateAlgebra.ofState]
    simp
    exact normalOrder_create_mul âŸ¨States.negAsymp Ï†, ()âŸ© rfl a
  | .position Ï† =>
    dsimp [crPart, StateAlgebra.ofState]
    simp
    refine normalOrder_create_mul _ ?_ _
    simp [crAnStatesToCreateAnnihilate]
  | .posAsymp Ï† =>
    simp

lemma normalOrder_mul_anPart (Ï† : ğ“•.States) (a : CrAnAlgebra ğ“•) :
    normalOrder (a * anPart (StateAlgebra.ofState Ï†)) =
    normalOrder a * anPart (StateAlgebra.ofState Ï†) := by
  match Ï† with
  | .negAsymp Ï† =>
    simp
  | .position Ï† =>
    dsimp [anPart, StateAlgebra.ofState]
    simp
    refine normalOrder_mul_annihilate _ ?_ _
    simp [crAnStatesToCreateAnnihilate]
  | .posAsymp Ï† =>
    dsimp [anPart, StateAlgebra.ofState]
    simp
    refine normalOrder_mul_annihilate _ ?_ _
    simp [crAnStatesToCreateAnnihilate]

lemma normalOrder_superCommute_crPart_anPart (Ï† Ï†' : ğ“•.States) (a b : CrAnAlgebra ğ“•) :
  normalOrder (a * superCommute
    (crPart (StateAlgebra.ofState Ï†)) (anPart (StateAlgebra.ofState Ï†')) * b) = 0 := by
  match Ï†, Ï†' with
  | _,  .negAsymp Ï†' =>
    simp
  | .posAsymp Ï†', _ =>
    simp
  | .position Ï†, .position Ï†' =>
    simp
    refine normalOrder_superCommute_create_annihilate _ _ (by rfl) (by rfl) _ _
  | .negAsymp Ï†, .posAsymp Ï†' =>
    simp
    refine normalOrder_superCommute_create_annihilate _ _ (by rfl) (by rfl) _ _
  | .negAsymp Ï†, .position Ï†' =>
    simp
    refine normalOrder_superCommute_create_annihilate _ _ (by rfl) (by rfl) _ _
  | .position Ï†, .posAsymp Ï†' =>
    simp
    refine normalOrder_superCommute_create_annihilate _ _ (by rfl) (by rfl) _ _

lemma normalOrder_superCommute_anPart_crPart (Ï† Ï†' : ğ“•.States) (a b : CrAnAlgebra ğ“•) :
  normalOrder (a * superCommute
    (anPart (StateAlgebra.ofState Ï†)) (crPart (StateAlgebra.ofState Ï†')) * b) = 0 := by
  match Ï†, Ï†' with
  | .negAsymp Ï†',  _ =>
    simp
  | _, .posAsymp Ï†' =>
    simp
  | .position Ï†, .position Ï†' =>
    simp
    refine normalOrder_superCommute_annihilate_create _ _ (by rfl) (by rfl) _ _
  |  .posAsymp Ï†', .negAsymp Ï† =>
    simp
    refine normalOrder_superCommute_annihilate_create _ _ (by rfl) (by rfl) _ _
  | .position Ï†', .negAsymp Ï† =>
    simp
    refine normalOrder_superCommute_annihilate_create _ _ (by rfl) (by rfl) _ _
  | .posAsymp Ï†, .position Ï†' =>
    simp
    refine normalOrder_superCommute_annihilate_create _ _ (by rfl) (by rfl) _ _


lemma normalOrder_superCommute_ofCrAnList_create_create_ofCrAnList
    (Ï†c Ï†c' : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†c' : ğ“•.crAnStatesToCreateAnnihilate Ï†c' = CreateAnnihilate.create)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
     (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†c) (ofCrAnState Ï†c') * ofCrAnList Ï†s')) =
     normalOrderSign (Ï†s ++ Ï†c' :: Ï†c :: Ï†s') â€¢
    (ofCrAnList (createFilter Ï†s) * superCommute (ofCrAnState Ï†c) (ofCrAnState Ï†c') *
     ofCrAnList (createFilter Ï†s') * ofCrAnList (annihilateFilter (Ï†s ++ Ï†s'))) := by
  rw [superCommute_ofCrAnState]
  rw [mul_sub, sub_mul, map_sub]
  conv_lhs =>
    lhs
    rhs
    rw [â† ofCrAnList_singleton, â† ofCrAnList_singleton, â† ofCrAnList_append, â† ofCrAnList_append,
      â† ofCrAnList_append]
  conv_lhs =>
    lhs
    rw [normalOrder_ofCrAnList]
    rw [normalOrderList_eq_createFilter_append_annihilateFilter]
    rw [createFilter_append, createFilter_append, createFilter_append,
      createFilter_singleton_create _ hÏ†c, createFilter_singleton_create _ hÏ†c']
    rw [annihilateFilter_append, annihilateFilter_append, annihilateFilter_append,
      annihilateFilter_singleton_create _ hÏ†c, annihilateFilter_singleton_create _ hÏ†c']
    enter [2, 1, 2]
    simp
    rw [â† annihilateFilter_append]
  conv_lhs =>
    rhs
    rhs
    rw [smul_mul_assoc]
    rw [Algebra.mul_smul_comm, smul_mul_assoc]
    rhs
    rw [â† ofCrAnList_singleton, â† ofCrAnList_singleton, â† ofCrAnList_append, â† ofCrAnList_append,
      â† ofCrAnList_append]
  conv_lhs =>
    rhs
    rw [map_smul]
    rhs
    rw [normalOrder_ofCrAnList]
    rw [normalOrderList_eq_createFilter_append_annihilateFilter]
    rw [createFilter_append, createFilter_append, createFilter_append,
      createFilter_singleton_create _ hÏ†c, createFilter_singleton_create _ hÏ†c']
    rw [annihilateFilter_append, annihilateFilter_append, annihilateFilter_append,
      annihilateFilter_singleton_create _ hÏ†c, annihilateFilter_singleton_create _ hÏ†c']
    enter [2, 1, 2]
    simp
    rw [â† annihilateFilter_append]
  conv_lhs =>
    lhs
    lhs
    simp
  conv_lhs =>
    rhs
    rhs
    lhs
    simp
  rw [normalOrderSign_swap_create_create Ï†c Ï†c' hÏ†c hÏ†c']
  rw [smul_smul, mul_comm, â† smul_smul]
  rw [â† smul_sub, ofCrAnList_append, ofCrAnList_append, ofCrAnList_append]
  conv_lhs =>
    rhs
    rhs
    rw [ofCrAnList_append, ofCrAnList_append, ofCrAnList_append]
    rw [â† smul_mul_assoc, â† smul_mul_assoc, â† Algebra.mul_smul_comm]
  rw [â† sub_mul, â† sub_mul, â† mul_sub]
  congr
  rw [ofCrAnList_append, ofCrAnList_singleton, ofCrAnList_singleton]
  rw [ofCrAnList_append, ofCrAnList_singleton, ofCrAnList_singleton, smul_mul_assoc]


lemma normalOrder_superCommute_ofCrAnList_annihilate_annihilate_ofCrAnList
    (Ï†a Ï†a' : ğ“•.CrAnStates)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (hÏ†a' : ğ“•.crAnStatesToCreateAnnihilate Ï†a' = CreateAnnihilate.annihilate)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
     (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * ofCrAnList Ï†s')) =
     normalOrderSign (Ï†s ++ Ï†a' :: Ï†a :: Ï†s') â€¢
    (ofCrAnList (createFilter (Ï†s ++ Ï†s'))
      * ofCrAnList (annihilateFilter Ï†s) * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a')
      * ofCrAnList (annihilateFilter Ï†s')) := by
  rw [superCommute_ofCrAnState]
  rw [mul_sub, sub_mul, map_sub]
  conv_lhs =>
    lhs
    rhs
    rw [â† ofCrAnList_singleton, â† ofCrAnList_singleton, â† ofCrAnList_append, â† ofCrAnList_append,
      â† ofCrAnList_append]
  conv_lhs =>
    lhs
    rw [normalOrder_ofCrAnList]
    rw [normalOrderList_eq_createFilter_append_annihilateFilter]
    rw [createFilter_append, createFilter_append, createFilter_append,
      createFilter_singleton_annihilate _ hÏ†a, createFilter_singleton_annihilate _ hÏ†a']
    rw [annihilateFilter_append, annihilateFilter_append, annihilateFilter_append,
      annihilateFilter_singleton_annihilate _ hÏ†a, annihilateFilter_singleton_annihilate _ hÏ†a']
    enter [2, 1, 1]
    simp
    rw [â† createFilter_append]
  conv_lhs =>
    rhs
    rhs
    rw [smul_mul_assoc]
    rw [Algebra.mul_smul_comm, smul_mul_assoc]
    rhs
    rw [â† ofCrAnList_singleton, â† ofCrAnList_singleton, â† ofCrAnList_append, â† ofCrAnList_append,
      â† ofCrAnList_append]
  conv_lhs =>
    rhs
    rw [map_smul]
    rhs
    rw [normalOrder_ofCrAnList]
    rw [normalOrderList_eq_createFilter_append_annihilateFilter]
    rw [createFilter_append, createFilter_append, createFilter_append,
      createFilter_singleton_annihilate _ hÏ†a, createFilter_singleton_annihilate _ hÏ†a']
    rw [annihilateFilter_append, annihilateFilter_append, annihilateFilter_append,
      annihilateFilter_singleton_annihilate _ hÏ†a, annihilateFilter_singleton_annihilate _ hÏ†a']
    enter [2, 1, 1]
    simp
    rw [â† createFilter_append]
  conv_lhs =>
    lhs
    lhs
    simp
  conv_lhs =>
    rhs
    rhs
    lhs
    simp
  rw [normalOrderSign_swap_annihilate_annihilate Ï†a Ï†a' hÏ†a hÏ†a']
  rw [smul_smul, mul_comm, â† smul_smul]
  rw [â† smul_sub, ofCrAnList_append, ofCrAnList_append, ofCrAnList_append]
  conv_lhs =>
    rhs
    rhs
    rw [ofCrAnList_append, ofCrAnList_append, ofCrAnList_append]
    rw [â† Algebra.mul_smul_comm, â† smul_mul_assoc, â† Algebra.mul_smul_comm]
  rw [â† mul_sub, â† sub_mul, â† mul_sub, ]
  apply congrArg
  conv_rhs => rw [mul_assoc, mul_assoc]
  apply congrArg
  rw [mul_assoc]
  apply congrArg
  congr
  rw [ofCrAnList_append, ofCrAnList_singleton, ofCrAnList_singleton]
  rw [ofCrAnList_append, ofCrAnList_singleton, ofCrAnList_singleton, smul_mul_assoc]

end

end CrAnAlgebra

namespace OperatorAlgebra
variable {ğ“ : OperatorAlgebra ğ“•}
open CrAnAlgebra

lemma crAnF_normalOrder_superCommute_ofCrAnList_create_create_ofCrAnList
    (Ï†c Ï†c' : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†c' : ğ“•.crAnStatesToCreateAnnihilate Ï†c' = CreateAnnihilate.create)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    ğ“.crAnF (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†c) (ofCrAnState Ï†c') * ofCrAnList Ï†s'))
    = 0 := by
  rw [normalOrder_superCommute_ofCrAnList_create_create_ofCrAnList Ï†c Ï†c' hÏ†c hÏ†c' Ï†s Ï†s']
  rw [map_smul, map_mul, map_mul, map_mul, ğ“.superCommute_create_create Ï†c Ï†c' hÏ†c hÏ†c']
  simp

lemma crAnF_normalOrder_superCommute_ofCrAnList_annihilate_annihilate_ofCrAnList
    (Ï†a Ï†a' : ğ“•.CrAnStates)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (hÏ†a' : ğ“•.crAnStatesToCreateAnnihilate Ï†a' = CreateAnnihilate.annihilate)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    ğ“.crAnF (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * ofCrAnList Ï†s'))
    = 0 := by
  rw [normalOrder_superCommute_ofCrAnList_annihilate_annihilate_ofCrAnList Ï†a Ï†a' hÏ†a hÏ†a' Ï†s Ï†s']
  rw [map_smul, map_mul, map_mul, map_mul, ğ“.superCommute_annihilate_annihilate Ï†a Ï†a' hÏ†a hÏ†a']
  simp

lemma crAnF_normalOrder_superCommute_ofCrAnList_ofCrAnList_eq_zero
    (Ï†a Ï†a' : ğ“•.CrAnStates) (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    ğ“.crAnF (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * ofCrAnList Ï†s'))
    = 0 := by
  rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†a) with hÏ†a | hÏ†a
  <;> rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†a') with hÏ†a' | hÏ†a'
  Â· rw [normalOrder_superCommute_ofCrAnList_create_create_ofCrAnList Ï†a Ï†a' hÏ†a hÏ†a' Ï†s Ï†s']
    rw [map_smul, map_mul, map_mul, map_mul, ğ“.superCommute_create_create Ï†a Ï†a' hÏ†a hÏ†a']
    simp
  Â· rw [normalOrder_superCommute_create_annihilate Ï†a Ï†a' hÏ†a hÏ†a' (ofCrAnList Ï†s)
      (ofCrAnList Ï†s')]
    simp
  Â· rw [normalOrder_superCommute_annihilate_create Ï†a' Ï†a hÏ†a' hÏ†a (ofCrAnList Ï†s)
      (ofCrAnList Ï†s')]
    simp
  Â· rw [normalOrder_superCommute_ofCrAnList_annihilate_annihilate_ofCrAnList Ï†a Ï†a' hÏ†a hÏ†a' Ï†s Ï†s']
    rw [map_smul, map_mul, map_mul, map_mul, ğ“.superCommute_annihilate_annihilate Ï†a Ï†a' hÏ†a hÏ†a']
    simp

lemma crAnF_normalOrder_superCommute_ofCrAnList_eq_zero
    (Ï†a Ï†a' : ğ“•.CrAnStates) (Ï†s : List ğ“•.CrAnStates)
    (a : ğ“•.CrAnAlgebra) : ğ“.crAnF (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * a))
    = 0 := by
  change (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap ( (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') ))) a =
    0
  have hf : ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap ( (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a'))) = 0 := by
    apply ofCrAnListBasis.ext
    intro l
    simp
    exact crAnF_normalOrder_superCommute_ofCrAnList_ofCrAnList_eq_zero Ï†a Ï†a' Ï†s l
  rw [hf]
  simp

lemma crAnF_normalOrder_superCommute_eq_zero (Ï†a Ï†a' : ğ“•.CrAnStates)
    (a b : ğ“•.CrAnAlgebra) :
    ğ“.crAnF (normalOrder (a * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * b)) = 0 := by
  rw [mul_assoc]
  change (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap.flip ((superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * b ))) a =
    0
  have hf :  (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap.flip ((superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * b ))) = 0 := by
    apply ofCrAnListBasis.ext
    intro l
    simp [mulLinearMap]
    rw [â† mul_assoc]
    exact crAnF_normalOrder_superCommute_ofCrAnList_eq_zero Ï†a Ï†a' _ _
  rw [hf]
  simp


end OperatorAlgebra

end FieldStruct
