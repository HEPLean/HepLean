/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.FieldStruct.OperatorAlgebra
import HepLean.PerturbationTheory.Wick.Signs.KoszulSign
/-!

# State algebra

We define the state algebra of a field structure to be the free algebra
generated by the states.

-/

namespace FieldStruct
variable {ğ“• : FieldStruct}

/-- The normal ordering on creation and annihlation states. -/
def normalOrderProp : ğ“•.CrAnStates â†’ ğ“•.CrAnStates â†’ Prop :=
  fun a b => CreateAnnihilate.normalOrder (ğ“•.crAnStatesToCreateAnnihilate a)
    (ğ“•.crAnStatesToCreateAnnihilate b)

/-- Normal ordering is total. -/
instance : IsTotal ğ“•.CrAnStates ğ“•.normalOrderProp where
  total _ _ := total_of CreateAnnihilate.normalOrder _ _

/-- Normal ordering is transitive. -/
instance : IsTrans ğ“•.CrAnStates ğ“•.normalOrderProp where
  trans _ _ _ := fun h h' => IsTrans.trans (Î± := CreateAnnihilate) _ _ _ h h'

instance (Ï† Ï†' : ğ“•.CrAnStates) :  Decidable (normalOrderProp Ï† Ï†') :=
  CreateAnnihilate.instDecidableNormalOrder (ğ“•.crAnStatesToCreateAnnihilate Ï†)
    (ğ“•.crAnStatesToCreateAnnihilate Ï†')

/-!

## Normal order sign.

-/
def normalOrderSign (Ï†s : List ğ“•.CrAnStates) : â„‚ :=
  Wick.koszulSign ğ“•.crAnStatistics ğ“•.normalOrderProp Ï†s

@[simp]
lemma normalOrderSign_mul_self (Ï†s : List ğ“•.CrAnStates) :
    normalOrderSign Ï†s * normalOrderSign Ï†s = 1 := by
  simp [normalOrderSign, Wick.koszulSign, Wick.koszulSign_mul_self]

lemma koszulSignInsert_create  (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) : (Ï†s : List ğ“•.CrAnStates) â†’
    Wick.koszulSignInsert ğ“•.crAnStatistics normalOrderProp Ï† Ï†s = 1
  | [] => rfl
  | Ï†' :: Ï†s => by
    dsimp [Wick.koszulSignInsert]
    rw [if_pos]
    Â· exact koszulSignInsert_create Ï† hÏ† Ï†s
    Â· dsimp [normalOrderProp]
      rw [hÏ†]
      dsimp [CreateAnnihilate.normalOrder]

lemma normalOrderSign_cons_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    normalOrderSign (Ï† :: Ï†s) = normalOrderSign Ï†s := by
  dsimp [normalOrderSign, Wick.koszulSign]
  rw [koszulSignInsert_create Ï† hÏ† Ï†s]
  simp

@[simp]
lemma normalOrderSign_singleton (Ï† : ğ“•.CrAnStates) :
    normalOrderSign [Ï†] = 1 := by
  simp [normalOrderSign]

@[simp]
lemma normalOrderSign_nil :
    normalOrderSign (ğ“• := ğ“•) [] = 1 := by
  simp [normalOrderSign, Wick.koszulSign]

lemma koszulSignInsert_append_annihilate (Ï†' Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    (Ï†s : List ğ“•.CrAnStates) â†’
    Wick.koszulSignInsert ğ“•.crAnStatistics normalOrderProp Ï†' (Ï†s ++ [Ï†]) =
    Wick.koszulSignInsert ğ“•.crAnStatistics normalOrderProp Ï†' Ï†s
  | [] => by
    simp [Wick.koszulSignInsert, normalOrderProp, hÏ†]
  | Ï†'' :: Ï†s => by
    dsimp [Wick.koszulSignInsert]
    rw [koszulSignInsert_append_annihilate Ï†' Ï† hÏ† Ï†s]

lemma normalOrderSign_append_annihlate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate)  :
    (Ï†s : List ğ“•.CrAnStates) â†’
    normalOrderSign (Ï†s ++ [Ï†]) = normalOrderSign Ï†s
  | [] => by simp
  | Ï†' :: Ï†s => by
    dsimp [normalOrderSign, Wick.koszulSign]
    have hi := normalOrderSign_append_annihlate Ï† hÏ† Ï†s
    dsimp [normalOrderSign] at hi
    rw [hi, koszulSignInsert_append_annihilate Ï†' Ï† hÏ† Ï†s]

lemma koszulSignInsert_annihilate_cons_create (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) :
    Wick.koszulSignInsert ğ“•.crAnStatistics normalOrderProp Ï†a (Ï†c :: Ï†s)
    = FieldStatistic.pairedSign (ğ“•.crAnStatistics Ï†c) (ğ“•.crAnStatistics Ï†a) *
    Wick.koszulSignInsert ğ“•.crAnStatistics normalOrderProp Ï†a Ï†s := by
  rw [Wick.koszulSignInsert_cons]
  simp
  apply Or.inl
  rw [Wick.koszulSignCons, if_neg, FieldStatistic.pairedSign_symm, FieldStatistic.pairedSign_eq_if]
  rw [normalOrderProp, hÏ†a, hÏ†c]
  simp [CreateAnnihilate.normalOrder]

lemma normalOrderSign_swap_create_annihlate_fst (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) :
    normalOrderSign (Ï†c :: Ï†a :: Ï†s) =
    FieldStatistic.pairedSign (ğ“•.crAnStatistics Ï†c) (ğ“•.crAnStatistics Ï†a) *
    normalOrderSign (Ï†a :: Ï†c :: Ï†s) := by
  rw [normalOrderSign_cons_create Ï†c hÏ†c (Ï†a :: Ï†s)]
  conv_rhs =>
    rw [normalOrderSign]
    rw [Wick.koszulSign]
    rw [â† normalOrderSign]
    rw [koszulSignInsert_annihilate_cons_create Ï†c Ï†a hÏ†c hÏ†a Ï†s]
  rw [â† mul_assoc, â† mul_assoc, FieldStatistic.pairedSign_mul_self]
  simp
  rw [normalOrderSign_cons_create Ï†c hÏ†c Ï†s]
  rfl

lemma koszulSignInsert_swap (Ï† Ï†c Ï†a : ğ“•.CrAnStates)
    : (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    Wick.koszulSignInsert ğ“•.crAnStatistics normalOrderProp Ï† (Ï†s ++ Ï†a :: Ï†c :: Ï†s')
    = Wick.koszulSignInsert ğ“•.crAnStatistics normalOrderProp Ï†  (Ï†s ++ Ï†c :: Ï†a :: Ï†s') := by
  intro Ï†s Ï†s'
  apply Wick.koszulSignInsert_eq_perm
  refine List.Perm.append_left Ï†s ?h.a
  exact List.Perm.swap Ï†c Ï†a Ï†s'


lemma normalOrderSign_swap_create_annihlate (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
     : (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    normalOrderSign (Ï†s ++ Ï†c :: Ï†a :: Ï†s') =
    FieldStatistic.pairedSign (ğ“•.crAnStatistics Ï†c) (ğ“•.crAnStatistics Ï†a) *
    normalOrderSign (Ï†s ++ Ï†a :: Ï†c :: Ï†s')
  | [], Ï†s' => by
    exact normalOrderSign_swap_create_annihlate_fst Ï†c Ï†a hÏ†c hÏ†a Ï†s'
  | Ï† :: Ï†s, Ï†s' => by
    rw [normalOrderSign]
    dsimp [Wick.koszulSign]
    rw [â† normalOrderSign]
    rw [normalOrderSign_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a Ï†s Ï†s']
    rw [â† mul_assoc, mul_comm _ (FieldStatistic.pairedSign _ _), mul_assoc]
    simp
    apply Or.inl
    conv_rhs =>
      rw [normalOrderSign]
      dsimp [Wick.koszulSign]
      rw [â† normalOrderSign]
    simp
    apply Or.inl
    rw [koszulSignInsert_swap]


lemma normalOrderSign_swap_create_create_fst (Ï†c Ï†c' : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†c' : ğ“•.crAnStatesToCreateAnnihilate Ï†c' = CreateAnnihilate.create)
    (Ï†s : List ğ“•.CrAnStates) :
    normalOrderSign (Ï†c :: Ï†c' :: Ï†s) =
    normalOrderSign (Ï†c' :: Ï†c :: Ï†s) := by
  rw [normalOrderSign_cons_create Ï†c hÏ†c, normalOrderSign_cons_create Ï†c' hÏ†c']
  rw [normalOrderSign_cons_create Ï†c' hÏ†c', normalOrderSign_cons_create Ï†c hÏ†c]

lemma normalOrderSign_swap_create_create (Ï†c Ï†c' : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†c' : ğ“•.crAnStatesToCreateAnnihilate Ï†c' = CreateAnnihilate.create)
    :  (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    normalOrderSign (Ï†s ++ Ï†c :: Ï†c' :: Ï†s') =
    normalOrderSign (Ï†s ++ Ï†c' :: Ï†c :: Ï†s')
  | [], Ï†s' => by
    exact normalOrderSign_swap_create_create_fst Ï†c Ï†c' hÏ†c hÏ†c' Ï†s'
  | Ï† :: Ï†s, Ï†s' => by
    rw [normalOrderSign]
    dsimp [Wick.koszulSign]
    rw [â† normalOrderSign]
    rw [normalOrderSign_swap_create_create Ï†c Ï†c' hÏ†c hÏ†c']
    dsimp [normalOrderSign, Wick.koszulSign]
    rw [â† normalOrderSign]
    simp
    apply Or.inl
    apply Wick.koszulSignInsert_eq_perm
    refine List.Perm.append_left Ï†s ?h.h.a
    exact List.Perm.swap Ï†c' Ï†c Ï†s'

lemma normalOrderSign_swap_annihilate_annihilate_fst (Ï†a Ï†a' : ğ“•.CrAnStates)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (hÏ†a' : ğ“•.crAnStatesToCreateAnnihilate Ï†a' = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) :
    normalOrderSign (Ï†a :: Ï†a' :: Ï†s) =
    normalOrderSign (Ï†a' :: Ï†a :: Ï†s) := by
  rw [normalOrderSign, normalOrderSign]
  dsimp [Wick.koszulSign]
  rw [â† mul_assoc, â† mul_assoc]
  congr 1
  rw [Wick.koszulSignInsert_cons, Wick.koszulSignInsert_cons]
  rw [mul_assoc, mul_assoc]
  congr 1
  Â· dsimp [Wick.koszulSignCons]
    rw [if_pos, if_pos]
    Â· simp [normalOrderProp, hÏ†a, hÏ†a', CreateAnnihilate.normalOrder]
    Â· simp [normalOrderProp, hÏ†a, hÏ†a', CreateAnnihilate.normalOrder]
  Â· rw [NonUnitalNormedCommRing.mul_comm]

lemma normalOrderSign_swap_annihilate_annihilate (Ï†a Ï†a' : ğ“•.CrAnStates)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (hÏ†a' : ğ“•.crAnStatesToCreateAnnihilate Ï†a' = CreateAnnihilate.annihilate)
    :  (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    normalOrderSign (Ï†s ++ Ï†a :: Ï†a' :: Ï†s') =
    normalOrderSign (Ï†s ++ Ï†a' :: Ï†a :: Ï†s')
  | [], Ï†s' => by
    exact normalOrderSign_swap_annihilate_annihilate_fst Ï†a Ï†a' hÏ†a hÏ†a' Ï†s'
  | Ï† :: Ï†s, Ï†s' => by
    rw [normalOrderSign]
    dsimp [Wick.koszulSign]
    rw [â† normalOrderSign]
    rw [normalOrderSign_swap_annihilate_annihilate Ï†a Ï†a' hÏ†a hÏ†a']
    dsimp [normalOrderSign, Wick.koszulSign]
    rw [â† normalOrderSign]
    simp
    apply Or.inl
    apply Wick.koszulSignInsert_eq_perm
    refine List.Perm.append_left Ï†s ?h.h.a
    exact List.Perm.swap Ï†a' Ï†a Ï†s'
open FieldStatistic

/-!

##Â Normal order of lists

-/

def normalOrderList (Ï†s : List ğ“•.CrAnStates) : List ğ“•.CrAnStates :=
  List.insertionSort ğ“•.normalOrderProp Ï†s


@[simp]
lemma normalOrderList_nil : normalOrderList (ğ“• := ğ“•) [] = [] := by
  simp [normalOrderList]

lemma orderedInsert_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) :
    (Ï†s : List ğ“•.CrAnStates) â†’ List.orderedInsert normalOrderProp Ï† Ï†s = Ï† :: Ï†s
  | [] => rfl
  | Ï†' :: Ï†s => by
    dsimp [List.orderedInsert]
    rw [if_pos]
    dsimp [normalOrderProp]
    rw [hÏ†]
    dsimp [CreateAnnihilate.normalOrder]

lemma normalOrderList_cons_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    normalOrderList (Ï† :: Ï†s) = Ï† :: normalOrderList Ï†s := by
  simp [normalOrderList, List.insertionSort]
  rw [orderedInsert_create Ï† hÏ†]

lemma orderedInsert_append_annihilate (Ï†' Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    (Ï†s : List ğ“•.CrAnStates) â†’ List.orderedInsert normalOrderProp Ï†' (Ï†s ++ [Ï†]) =
    List.orderedInsert normalOrderProp Ï†' Ï†s ++ [Ï†]
  | [] => by
    simp [Wick.koszulSignInsert, normalOrderProp, hÏ†]
  | Ï†'' :: Ï†s => by
    dsimp [List.orderedInsert]
    have hi := orderedInsert_append_annihilate Ï†' Ï† hÏ† Ï†s
    rw [hi]
    split
    next h => simp_all only [List.cons_append]
    next h => simp_all only [List.cons_append]

lemma normalOrderList_append_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    (Ï†s : List ğ“•.CrAnStates) â†’
    normalOrderList (Ï†s ++ [Ï†]) = normalOrderList Ï†s ++ [Ï†]
  | [] => by simp [normalOrderList]
  | Ï†' :: Ï†s => by
    simp [normalOrderList, List.insertionSort]
    have hi := normalOrderList_append_annihilate Ï† hÏ† Ï†s
    dsimp [normalOrderList] at hi
    rw [hi, orderedInsert_append_annihilate Ï†' Ï† hÏ†]

lemma normalOrder_swap_create_annihlate_fst (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) :
    normalOrderList (Ï†c :: Ï†a :: Ï†s) = normalOrderList (Ï†a :: Ï†c :: Ï†s) := by
  rw [normalOrderList_cons_create Ï†c hÏ†c (Ï†a :: Ï†s)]
  conv_rhs =>
    rw [normalOrderList]
    rw [List.insertionSort]
  have hi := normalOrderList_cons_create Ï†c hÏ†c Ï†s
  rw [normalOrderList] at hi
  rw [hi]
  dsimp
  split
  Â· rename_i h
    rw [normalOrderProp, hÏ†a, hÏ†c] at h
    dsimp [CreateAnnihilate.normalOrder] at h
  Â· rfl

lemma normalOrderList_swap_create_annihlate (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate) :
    (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    normalOrderList (Ï†s ++ Ï†c :: Ï†a :: Ï†s') = normalOrderList (Ï†s ++ Ï†a :: Ï†c :: Ï†s')
  | [], Ï†s' => by
    exact normalOrder_swap_create_annihlate_fst Ï†c Ï†a hÏ†c hÏ†a Ï†s'
  | Ï† :: Ï†s, Ï†s' => by
    dsimp [normalOrderList]
    have hi := normalOrderList_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a Ï†s Ï†s'
    dsimp [normalOrderList] at hi
    rw [hi]

-- HepLean.List.insertionSortEquiv
def normalOrderEquiv {Ï†s : List ğ“•.CrAnStates} : Fin Ï†s.length â‰ƒ Fin (normalOrderList Ï†s).length :=
  HepLean.List.insertionSortEquiv ğ“•.normalOrderProp Ï†s

lemma sum_normalOrderList_length {M : Type} [AddCommMonoid M]
    (Ï†s : List ğ“•.CrAnStates) (f : Fin (normalOrderList Ï†s).length â†’ M) :
    âˆ‘ (n : Fin (normalOrderList Ï†s).length), f n =
    âˆ‘ (n : Fin Ï†s.length), f (normalOrderEquiv n) := by
  exact Eq.symm (Equiv.sum_comp normalOrderEquiv f)

@[simp]
lemma normalOrderList_get_normalOrderEquiv {Ï†s : List ğ“•.CrAnStates} (n : Fin Ï†s.length) :
    (normalOrderList Ï†s)[(normalOrderEquiv n).val] = Ï†s[n.val] := by
  change (normalOrderList Ï†s).get (normalOrderEquiv n) = _
  simp only [normalOrderList, normalOrderEquiv]
  erw [â† HepLean.List.insertionSortEquiv_get]
  simp

@[simp]
lemma normalOrderList_eraseIdx_normalOrderEquiv {Ï†s : List ğ“•.CrAnStates} (n : Fin Ï†s.length) :
    (normalOrderList Ï†s).eraseIdx (normalOrderEquiv n).val =
    normalOrderList (Ï†s.eraseIdx n.val) := by
  simp [normalOrderList, normalOrderEquiv]
  rw [HepLean.List.eraseIdx_insertionSort_fin]

lemma normalOrderSign_eraseIdx (Ï†s : List ğ“•.CrAnStates) (n : Fin Ï†s.length) :
    normalOrderSign (Ï†s.eraseIdx n) = normalOrderSign Ï†s *
    ğ“¢(ğ“• |>â‚› (Ï†s.get n), ğ“• |>â‚› (Ï†s.take n)) *
    ğ“¢(ğ“• |>â‚› (Ï†s.get n), ğ“• |>â‚› ((normalOrderList Ï†s).take (normalOrderEquiv n))) := by
  rw [normalOrderSign, Wick.koszulSign_eraseIdx]
  rw [â† normalOrderSign]
  congr
  Â· rw [pairedSign_eq_if]
    simp [Wick.superCommuteCoef]
  Â· rw [pairedSign_eq_if]
    simp [Wick.superCommuteCoef]
    rfl

def createFilter (Ï†s : List ğ“•.CrAnStates) : List ğ“•.CrAnStates :=
  List.filter (fun Ï† => ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) Ï†s

lemma createFilter_cons_create {Ï† : ğ“•.CrAnStates}
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    createFilter (Ï† :: Ï†s) = Ï† :: createFilter Ï†s := by
  simp [createFilter]
  rw [List.filter_cons_of_pos]
  simp [hÏ†]

lemma createFilter_cons_annihilate {Ï† : ğ“•.CrAnStates}
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) (Ï†s : List ğ“•.CrAnStates) :
    createFilter (Ï† :: Ï†s) = createFilter Ï†s := by
  simp [createFilter]
  rw [List.filter_cons_of_neg]
  simp [hÏ†]

lemma createFilter_append (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    createFilter (Ï†s ++ Ï†s') = createFilter Ï†s ++ createFilter Ï†s' := by
  rw [createFilter, List.filter_append]
  rfl

lemma createFilter_singleton_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) :
    createFilter [Ï†] = [Ï†] := by
  simp [createFilter, hÏ†]

lemma createFilter_singleton_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    createFilter [Ï†] = [] := by
  simp [createFilter, hÏ†]

def annihilateFilter (Ï†s : List ğ“•.CrAnStates) : List ğ“•.CrAnStates :=
  List.filter (fun Ï† => ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) Ï†s

lemma annihilateFilter_cons_create {Ï† : ğ“•.CrAnStates}
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    annihilateFilter (Ï† :: Ï†s) = annihilateFilter Ï†s := by
  simp [annihilateFilter]
  rw [List.filter_cons_of_neg]
  simp [hÏ†]

lemma annihilateFilter_cons_annihilate {Ï† : ğ“•.CrAnStates}
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) (Ï†s : List ğ“•.CrAnStates) :
    annihilateFilter (Ï† :: Ï†s) = Ï† :: annihilateFilter Ï†s := by
  simp [annihilateFilter]
  rw [List.filter_cons_of_pos]
  simp [hÏ†]

lemma annihilateFilter_append (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    annihilateFilter (Ï†s ++ Ï†s') = annihilateFilter Ï†s ++ annihilateFilter Ï†s' := by
  rw [annihilateFilter, List.filter_append]
  rfl

lemma annihilateFilter_singleton_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) :
    annihilateFilter [Ï†] = [] := by
  simp [annihilateFilter, hÏ†]

lemma annihilateFilter_singleton_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    annihilateFilter [Ï†] = [Ï†] := by
  simp [annihilateFilter, hÏ†]

lemma orderedInsert_createFilter_append_annihilate  (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate)
     : (Ï†s Ï†s' : List ğ“•.CrAnStates) â†’
    List.orderedInsert normalOrderProp Ï† (createFilter Ï†s ++ Ï†s') =
    createFilter Ï†s ++ List.orderedInsert normalOrderProp Ï† Ï†s'
  | [], Ï†s' => by simp [createFilter]
  | Ï†' :: Ï†s, Ï†s' => by
    rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†') with hÏ†' | hÏ†'
    Â· rw [createFilter_cons_create hÏ†']
      dsimp
      rw [if_neg]
      rw [orderedInsert_createFilter_append_annihilate Ï† hÏ† Ï†s Ï†s']
      simp [normalOrderProp, hÏ†, hÏ†', CreateAnnihilate.normalOrder]
    Â· rw [createFilter_cons_annihilate hÏ†']
      rw [orderedInsert_createFilter_append_annihilate Ï† hÏ† Ï†s]

lemma orderedInsert_annihilateFilter  (Ï† : ğ“•.CrAnStates)
     : (Ï†s : List ğ“•.CrAnStates) â†’
    List.orderedInsert normalOrderProp Ï† (annihilateFilter Ï†s ) =
    Ï† :: annihilateFilter Ï†s
  | [] => by simp [annihilateFilter]
  | Ï†' :: Ï†s  => by
    rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†') with hÏ†' | hÏ†'
    Â· rw [annihilateFilter_cons_create hÏ†']
      rw [orderedInsert_annihilateFilter Ï† Ï†s]
    Â· rw [annihilateFilter_cons_annihilate hÏ†']
      dsimp
      rw [if_pos]
      dsimp [normalOrderProp]
      rw [hÏ†']
      rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†) with hÏ† | hÏ†
      Â· rw [hÏ†]
        simp [CreateAnnihilate.normalOrder]
      Â· rw [hÏ†]
        simp [CreateAnnihilate.normalOrder]


lemma orderedInsert_createFilter_append_annihilateFilter_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) :
    (Ï†s : List ğ“•.CrAnStates) â†’
     List.orderedInsert normalOrderProp Ï† (createFilter Ï†s ++ annihilateFilter Ï†s) =
    createFilter Ï†s ++ Ï† :: annihilateFilter Ï†s := by
  intro Ï†s
  rw [orderedInsert_createFilter_append_annihilate Ï† hÏ†, orderedInsert_annihilateFilter]

lemma normalOrderList_eq_createFilter_append_annihilateFilter : (Ï†s : List ğ“•.CrAnStates) â†’
    normalOrderList Ï†s = createFilter Ï†s ++ annihilateFilter Ï†s
  | [] => by simp [normalOrderList, createFilter, annihilateFilter]
  | Ï† :: Ï†s => by
    by_cases hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create
    Â· rw [normalOrderList_cons_create Ï† hÏ† Ï†s]
      dsimp [createFilter]
      rw [List.filter_cons_of_pos]
      swap
      simp [hÏ†]
      dsimp [annihilateFilter]
      rw [List.filter_cons_of_neg]
      swap
      simp [hÏ†]
      rw [normalOrderList_eq_createFilter_append_annihilateFilter Ï†s]
      rfl
    Â· dsimp [normalOrderList]
      rw [â† normalOrderList]
      have hÏ†' : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate := by
        have hx := CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†)
        simp_all
      rw [normalOrderList_eq_createFilter_append_annihilateFilter Ï†s]
      rw [orderedInsert_createFilter_append_annihilateFilter_annihilate Ï† hÏ†']
      rw [createFilter_cons_annihilate hÏ†']
      rw [annihilateFilter_cons_annihilate hÏ†']

/-!

## Normal order on the CrAnAlgebra

-/
namespace CrAnAlgebra

noncomputable section

def normalOrder : CrAnAlgebra ğ“• â†’â‚—[â„‚] CrAnAlgebra ğ“•  :=
  Basis.constr ofCrAnListBasis â„‚ fun Ï†s =>
  normalOrderSign Ï†s â€¢ ofCrAnList (normalOrderList Ï†s)

lemma normalOrder_ofCrAnList (Ï†s : List ğ“•.CrAnStates) :
    normalOrder (ofCrAnList Ï†s) = normalOrderSign Ï†s â€¢ ofCrAnList (normalOrderList Ï†s) := by
  rw [â† ofListBasis_eq_ofList]
  simp only [normalOrder, Basis.constr_basis]

lemma ofCrAnList_eq_normalOrder (Ï†s : List ğ“•.CrAnStates) :
    ofCrAnList (normalOrderList Ï†s) = normalOrderSign Ï†s â€¢ normalOrder (ofCrAnList Ï†s) := by
  rw [normalOrder_ofCrAnList, normalOrderList]
  rw [smul_smul]
  simp [normalOrderSign]
  rw [Wick.koszulSign_mul_self]
  simp

lemma normalOrder_one : normalOrder (ğ“• := ğ“•) 1 = 1 := by
  rw [â† ofCrAnList_nil, normalOrder_ofCrAnList]
  simp

lemma normalOrder_ofCrAnList_cons_create (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create) (Ï†s : List ğ“•.CrAnStates) :
    normalOrder (ofCrAnList (Ï† :: Ï†s)) =
    ofCrAnState Ï† * normalOrder (ofCrAnList Ï†s) := by
  rw [normalOrder_ofCrAnList]
  rw [normalOrderSign_cons_create Ï† hÏ†, normalOrderList_cons_create Ï† hÏ† Ï†s]
  rw [ofCrAnList_cons, normalOrder_ofCrAnList, mul_smul_comm]

lemma normalOrder_create_mul  (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.create)
    (a : CrAnAlgebra ğ“•) :
    normalOrder (ofCrAnState Ï† * a) = ofCrAnState Ï† * normalOrder a := by
  change (normalOrder âˆ˜â‚— mulLinearMap (ofCrAnState Ï†)) a =
    (mulLinearMap (ofCrAnState Ï†) âˆ˜â‚— normalOrder) a
  refine LinearMap.congr_fun ?h a
  apply ofCrAnListBasis.ext
  intro l
  simp [mulLinearMap]
  rw [â† ofCrAnList_cons]
  rw [normalOrder_ofCrAnList_cons_create Ï† hÏ†]

lemma normalOrder_ofCrAnList_append_annihilate (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate) (Ï†s : List ğ“•.CrAnStates) :
    normalOrder (ofCrAnList (Ï†s ++ [Ï†])) =
    normalOrder (ofCrAnList Ï†s) * ofCrAnState Ï† := by
  rw [normalOrder_ofCrAnList]
  rw [normalOrderSign_append_annihlate Ï† hÏ† Ï†s, normalOrderList_append_annihilate Ï† hÏ† Ï†s]
  rw [ofCrAnList_append, ofCrAnList_singleton, normalOrder_ofCrAnList, smul_mul_assoc]

lemma normalOrder_mul_annihilate  (Ï† : ğ“•.CrAnStates)
    (hÏ† : ğ“•.crAnStatesToCreateAnnihilate Ï† = CreateAnnihilate.annihilate)
    (a : CrAnAlgebra ğ“•) :
    normalOrder (a * ofCrAnState Ï†) = normalOrder a * ofCrAnState Ï† := by
  change (normalOrder âˆ˜â‚— mulLinearMap.flip (ofCrAnState Ï†)) a =
    (mulLinearMap.flip (ofCrAnState Ï†) âˆ˜â‚— normalOrder) a
  refine LinearMap.congr_fun ?h a
  apply ofCrAnListBasis.ext
  intro l
  simp [mulLinearMap]
  rw [â† ofCrAnList_singleton, â† ofCrAnList_append, ofCrAnList_singleton]
  rw [normalOrder_ofCrAnList_append_annihilate Ï† hÏ†]

lemma normalOrder_swap_create_annihlate_ofCrAnList_ofCrAnList (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    normalOrder (ofCrAnList Ï†s' * ofCrAnState Ï†c * ofCrAnState Ï†a * ofCrAnList Ï†s) =
    FieldStatistic.pairedSign (ğ“•.crAnStatistics Ï†c) (ğ“•.crAnStatistics Ï†a) â€¢
    normalOrder (ofCrAnList Ï†s' * ofCrAnState Ï†a * ofCrAnState Ï†c * ofCrAnList Ï†s)  := by
  rw [mul_assoc, mul_assoc, â† ofCrAnList_cons, â† ofCrAnList_cons, â† ofCrAnList_append]
  rw [normalOrder_ofCrAnList, normalOrderSign_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a]
  rw [normalOrderList_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a]
  rw [â† smul_smul, â† normalOrder_ofCrAnList]
  congr
  rw [ofCrAnList_append, ofCrAnList_cons, ofCrAnList_cons]
  noncomm_ring

lemma normalOrder_swap_create_annihlate_ofCrAnList (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (Ï†s : List ğ“•.CrAnStates) (a : ğ“•.CrAnAlgebra) :
    normalOrder (ofCrAnList Ï†s * ofCrAnState Ï†c * ofCrAnState Ï†a * a) =
    FieldStatistic.pairedSign (ğ“•.crAnStatistics Ï†c) (ğ“•.crAnStatistics Ï†a) â€¢
    normalOrder (ofCrAnList Ï†s * ofCrAnState Ï†a * ofCrAnState Ï†c * a)  := by
  change (normalOrder âˆ˜â‚— mulLinearMap (ofCrAnList Ï†s * ofCrAnState Ï†c * ofCrAnState Ï†a)) a =
    (smulLinearMap _ âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap (ofCrAnList Ï†s * ofCrAnState Ï†a * ofCrAnState Ï†c)) a
  refine LinearMap.congr_fun ?h a
  apply ofCrAnListBasis.ext
  intro l
  simp [mulLinearMap]
  rw [normalOrder_swap_create_annihlate_ofCrAnList_ofCrAnList Ï†c Ï†a hÏ†c hÏ†a ]
  rfl

lemma normalOrder_swap_create_annihlate (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (a b : ğ“•.CrAnAlgebra) :
    normalOrder (a * ofCrAnState Ï†c * ofCrAnState Ï†a * b) =
    FieldStatistic.pairedSign (ğ“•.crAnStatistics Ï†c) (ğ“•.crAnStatistics Ï†a) â€¢
    normalOrder (a * ofCrAnState Ï†a * ofCrAnState Ï†c * b)  := by
  rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc]
  change (normalOrder âˆ˜â‚— mulLinearMap.flip (ofCrAnState Ï†c * (ofCrAnState Ï†a * b))) a =
    (smulLinearMap (FieldStatistic.pairedSign (ğ“•.crAnStatistics Ï†c) (ğ“•.crAnStatistics Ï†a)) âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap.flip (ofCrAnState Ï†a * (ofCrAnState Ï†c * b))) a
  apply LinearMap.congr_fun
  apply ofCrAnListBasis.ext
  intro l
  simp [mulLinearMap]
  repeat rw [â† mul_assoc]
  rw [normalOrder_swap_create_annihlate_ofCrAnList Ï†c Ï†a hÏ†c hÏ†a ]
  rfl

lemma normalOrder_superCommute_create_annihilate (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (a b : ğ“•.CrAnAlgebra) :
    normalOrder (a * superCommute (ofCrAnState Ï†c) (ofCrAnState Ï†a) * b) = 0 := by
  rw [superCommute_ofCrAnState]
  simp
  rw [mul_sub, sub_mul, map_sub, â†  smul_mul_assoc]
  rw [â† mul_assoc, â† mul_assoc]
  rw [normalOrder_swap_create_annihlate Ï†c Ï†a hÏ†c hÏ†a]
  simp only [FieldStatistic.instCommGroup.eq_1, Algebra.mul_smul_comm, Algebra.smul_mul_assoc,
    map_smul, sub_self]

lemma normalOrder_superCommute_annihilate_create (Ï†c Ï†a : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (a b : ğ“•.CrAnAlgebra) :
    normalOrder (a * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†c) * b) = 0 := by
  rw [superCommute_ofCrAnState_symm]
  simp
  apply Or.inr
  exact normalOrder_superCommute_create_annihilate Ï†c Ï†a hÏ†c hÏ†a a b

lemma normalOrder_crPart_mul (Ï† : ğ“•.States) (a : CrAnAlgebra ğ“•) :
    normalOrder (crPart (StateAlgebra.ofState Ï†) * a) =
    crPart (StateAlgebra.ofState Ï†) * normalOrder a := by
  match Ï† with
  | .negAsymp Ï† =>
    dsimp [crPart, StateAlgebra.ofState]
    simp
    exact normalOrder_create_mul âŸ¨States.negAsymp Ï†, ()âŸ© rfl a
  | .position Ï† =>
    dsimp [crPart, StateAlgebra.ofState]
    simp
    refine normalOrder_create_mul _ ?_ _
    simp [crAnStatesToCreateAnnihilate]
  | .posAsymp Ï† =>
    simp

lemma normalOrder_mul_anPart (Ï† : ğ“•.States) (a : CrAnAlgebra ğ“•) :
    normalOrder (a * anPart (StateAlgebra.ofState Ï†)) =
    normalOrder a * anPart (StateAlgebra.ofState Ï†) := by
  match Ï† with
  | .negAsymp Ï† =>
    simp
  | .position Ï† =>
    dsimp [anPart, StateAlgebra.ofState]
    simp
    refine normalOrder_mul_annihilate _ ?_ _
    simp [crAnStatesToCreateAnnihilate]
  | .posAsymp Ï† =>
    dsimp [anPart, StateAlgebra.ofState]
    simp
    refine normalOrder_mul_annihilate _ ?_ _
    simp [crAnStatesToCreateAnnihilate]

lemma normalOrder_swap_crPart_anPart (Ï† Ï†' : ğ“•.States) (a b : CrAnAlgebra ğ“•) :
    normalOrder (a * (crPart (StateAlgebra.ofState Ï†))  *  (anPart (StateAlgebra.ofState Ï†')) * b) =
    FieldStatistic.pairedSign (ğ“•.statesStatistic Ï†) (ğ“•.statesStatistic Ï†') â€¢
    normalOrder (a * (anPart (StateAlgebra.ofState Ï†')) * (crPart (StateAlgebra.ofState Ï†)) * b)  := by
  match Ï†, Ï†' with
  | _, .negAsymp Ï†' =>
    simp
  | .posAsymp Ï†, _ =>
    simp
  | .position Ï†, .position Ï†' =>
    simp
    rw [normalOrder_swap_create_annihlate ]
    simp [crAnStatistics]
    rfl
    rfl
  | .negAsymp Ï†, .posAsymp Ï†' =>
    simp
    rw [normalOrder_swap_create_annihlate ]
    simp [crAnStatistics]
    rfl
    rfl
  | .negAsymp Ï†, .position Ï†' =>
    simp
    rw [normalOrder_swap_create_annihlate ]
    simp [crAnStatistics]
    rfl
    rfl
  | .position Ï†, .posAsymp Ï†' =>
    simp
    rw [normalOrder_swap_create_annihlate ]
    simp [crAnStatistics]
    rfl
    rfl

lemma normalOrder_swap_anPart_crPart (Ï† Ï†' : ğ“•.States) (a b : CrAnAlgebra ğ“•) :
    normalOrder (a * (anPart (StateAlgebra.ofState Ï†))  *  (crPart (StateAlgebra.ofState Ï†')) * b) =
    FieldStatistic.pairedSign (ğ“•.statesStatistic Ï†) (ğ“•.statesStatistic Ï†') â€¢
    normalOrder (a * (crPart (StateAlgebra.ofState Ï†')) * (anPart (StateAlgebra.ofState Ï†)) * b)  := by
  rw [normalOrder_swap_crPart_anPart]
  rw [smul_smul, FieldStatistic.pairedSign_symm, FieldStatistic.pairedSign_mul_self]
  simp

lemma normalOrder_superCommute_crPart_anPart (Ï† Ï†' : ğ“•.States) (a b : CrAnAlgebra ğ“•) :
  normalOrder (a * superCommute
    (crPart (StateAlgebra.ofState Ï†)) (anPart (StateAlgebra.ofState Ï†')) * b) = 0 := by
  match Ï†, Ï†' with
  | _,  .negAsymp Ï†' =>
    simp
  | .posAsymp Ï†', _ =>
    simp
  | .position Ï†, .position Ï†' =>
    simp
    refine normalOrder_superCommute_create_annihilate _ _ (by rfl) (by rfl) _ _
  | .negAsymp Ï†, .posAsymp Ï†' =>
    simp
    refine normalOrder_superCommute_create_annihilate _ _ (by rfl) (by rfl) _ _
  | .negAsymp Ï†, .position Ï†' =>
    simp
    refine normalOrder_superCommute_create_annihilate _ _ (by rfl) (by rfl) _ _
  | .position Ï†, .posAsymp Ï†' =>
    simp
    refine normalOrder_superCommute_create_annihilate _ _ (by rfl) (by rfl) _ _

lemma normalOrder_superCommute_anPart_crPart (Ï† Ï†' : ğ“•.States) (a b : CrAnAlgebra ğ“•) :
  normalOrder (a * superCommute
    (anPart (StateAlgebra.ofState Ï†)) (crPart (StateAlgebra.ofState Ï†')) * b) = 0 := by
  match Ï†, Ï†' with
  | .negAsymp Ï†',  _ =>
    simp
  | _, .posAsymp Ï†' =>
    simp
  | .position Ï†, .position Ï†' =>
    simp
    refine normalOrder_superCommute_annihilate_create _ _ (by rfl) (by rfl) _ _
  |  .posAsymp Ï†', .negAsymp Ï† =>
    simp
    refine normalOrder_superCommute_annihilate_create _ _ (by rfl) (by rfl) _ _
  | .position Ï†', .negAsymp Ï† =>
    simp
    refine normalOrder_superCommute_annihilate_create _ _ (by rfl) (by rfl) _ _
  | .posAsymp Ï†, .position Ï†' =>
    simp
    refine normalOrder_superCommute_annihilate_create _ _ (by rfl) (by rfl) _ _


lemma normalOrder_superCommute_ofCrAnList_create_create_ofCrAnList
    (Ï†c Ï†c' : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†c' : ğ“•.crAnStatesToCreateAnnihilate Ï†c' = CreateAnnihilate.create)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
     (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†c) (ofCrAnState Ï†c') * ofCrAnList Ï†s')) =
     normalOrderSign (Ï†s ++ Ï†c' :: Ï†c :: Ï†s') â€¢
    (ofCrAnList (createFilter Ï†s) * superCommute (ofCrAnState Ï†c) (ofCrAnState Ï†c') *
     ofCrAnList (createFilter Ï†s') * ofCrAnList (annihilateFilter (Ï†s ++ Ï†s'))) := by
  rw [superCommute_ofCrAnState]
  rw [mul_sub, sub_mul, map_sub]
  conv_lhs =>
    lhs
    rhs
    rw [â† ofCrAnList_singleton, â† ofCrAnList_singleton, â† ofCrAnList_append, â† ofCrAnList_append,
      â† ofCrAnList_append]
  conv_lhs =>
    lhs
    rw [normalOrder_ofCrAnList]
    rw [normalOrderList_eq_createFilter_append_annihilateFilter]
    rw [createFilter_append, createFilter_append, createFilter_append,
      createFilter_singleton_create _ hÏ†c, createFilter_singleton_create _ hÏ†c']
    rw [annihilateFilter_append, annihilateFilter_append, annihilateFilter_append,
      annihilateFilter_singleton_create _ hÏ†c, annihilateFilter_singleton_create _ hÏ†c']
    enter [2, 1, 2]
    simp
    rw [â† annihilateFilter_append]
  conv_lhs =>
    rhs
    rhs
    rw [smul_mul_assoc]
    rw [Algebra.mul_smul_comm, smul_mul_assoc]
    rhs
    rw [â† ofCrAnList_singleton, â† ofCrAnList_singleton, â† ofCrAnList_append, â† ofCrAnList_append,
      â† ofCrAnList_append]
  conv_lhs =>
    rhs
    rw [map_smul]
    rhs
    rw [normalOrder_ofCrAnList]
    rw [normalOrderList_eq_createFilter_append_annihilateFilter]
    rw [createFilter_append, createFilter_append, createFilter_append,
      createFilter_singleton_create _ hÏ†c, createFilter_singleton_create _ hÏ†c']
    rw [annihilateFilter_append, annihilateFilter_append, annihilateFilter_append,
      annihilateFilter_singleton_create _ hÏ†c, annihilateFilter_singleton_create _ hÏ†c']
    enter [2, 1, 2]
    simp
    rw [â† annihilateFilter_append]
  conv_lhs =>
    lhs
    lhs
    simp
  conv_lhs =>
    rhs
    rhs
    lhs
    simp
  rw [normalOrderSign_swap_create_create Ï†c Ï†c' hÏ†c hÏ†c']
  rw [smul_smul, mul_comm, â† smul_smul]
  rw [â† smul_sub, ofCrAnList_append, ofCrAnList_append, ofCrAnList_append]
  conv_lhs =>
    rhs
    rhs
    rw [ofCrAnList_append, ofCrAnList_append, ofCrAnList_append]
    rw [â† smul_mul_assoc, â† smul_mul_assoc, â† Algebra.mul_smul_comm]
  rw [â† sub_mul, â† sub_mul, â† mul_sub]
  congr
  rw [ofCrAnList_append, ofCrAnList_singleton, ofCrAnList_singleton]
  rw [ofCrAnList_append, ofCrAnList_singleton, ofCrAnList_singleton, smul_mul_assoc]


lemma normalOrder_superCommute_ofCrAnList_annihilate_annihilate_ofCrAnList
    (Ï†a Ï†a' : ğ“•.CrAnStates)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (hÏ†a' : ğ“•.crAnStatesToCreateAnnihilate Ï†a' = CreateAnnihilate.annihilate)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
     (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * ofCrAnList Ï†s')) =
     normalOrderSign (Ï†s ++ Ï†a' :: Ï†a :: Ï†s') â€¢
    (ofCrAnList (createFilter (Ï†s ++ Ï†s'))
      * ofCrAnList (annihilateFilter Ï†s) * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a')
      * ofCrAnList (annihilateFilter Ï†s')) := by
  rw [superCommute_ofCrAnState]
  rw [mul_sub, sub_mul, map_sub]
  conv_lhs =>
    lhs
    rhs
    rw [â† ofCrAnList_singleton, â† ofCrAnList_singleton, â† ofCrAnList_append, â† ofCrAnList_append,
      â† ofCrAnList_append]
  conv_lhs =>
    lhs
    rw [normalOrder_ofCrAnList]
    rw [normalOrderList_eq_createFilter_append_annihilateFilter]
    rw [createFilter_append, createFilter_append, createFilter_append,
      createFilter_singleton_annihilate _ hÏ†a, createFilter_singleton_annihilate _ hÏ†a']
    rw [annihilateFilter_append, annihilateFilter_append, annihilateFilter_append,
      annihilateFilter_singleton_annihilate _ hÏ†a, annihilateFilter_singleton_annihilate _ hÏ†a']
    enter [2, 1, 1]
    simp
    rw [â† createFilter_append]
  conv_lhs =>
    rhs
    rhs
    rw [smul_mul_assoc]
    rw [Algebra.mul_smul_comm, smul_mul_assoc]
    rhs
    rw [â† ofCrAnList_singleton, â† ofCrAnList_singleton, â† ofCrAnList_append, â† ofCrAnList_append,
      â† ofCrAnList_append]
  conv_lhs =>
    rhs
    rw [map_smul]
    rhs
    rw [normalOrder_ofCrAnList]
    rw [normalOrderList_eq_createFilter_append_annihilateFilter]
    rw [createFilter_append, createFilter_append, createFilter_append,
      createFilter_singleton_annihilate _ hÏ†a, createFilter_singleton_annihilate _ hÏ†a']
    rw [annihilateFilter_append, annihilateFilter_append, annihilateFilter_append,
      annihilateFilter_singleton_annihilate _ hÏ†a, annihilateFilter_singleton_annihilate _ hÏ†a']
    enter [2, 1, 1]
    simp
    rw [â† createFilter_append]
  conv_lhs =>
    lhs
    lhs
    simp
  conv_lhs =>
    rhs
    rhs
    lhs
    simp
  rw [normalOrderSign_swap_annihilate_annihilate Ï†a Ï†a' hÏ†a hÏ†a']
  rw [smul_smul, mul_comm, â† smul_smul]
  rw [â† smul_sub, ofCrAnList_append, ofCrAnList_append, ofCrAnList_append]
  conv_lhs =>
    rhs
    rhs
    rw [ofCrAnList_append, ofCrAnList_append, ofCrAnList_append]
    rw [â† Algebra.mul_smul_comm, â† smul_mul_assoc, â† Algebra.mul_smul_comm]
  rw [â† mul_sub, â† sub_mul, â† mul_sub, ]
  apply congrArg
  conv_rhs => rw [mul_assoc, mul_assoc]
  apply congrArg
  rw [mul_assoc]
  apply congrArg
  congr
  rw [ofCrAnList_append, ofCrAnList_singleton, ofCrAnList_singleton]
  rw [ofCrAnList_append, ofCrAnList_singleton, ofCrAnList_singleton, smul_mul_assoc]


@[simp]
lemma normalOrder_crPart_mul_crPart (Ï† Ï†' : ğ“•.States) :
    normalOrder (crPart (StateAlgebra.ofState Ï†) * crPart (StateAlgebra.ofState Ï†')) =
    crPart (StateAlgebra.ofState Ï†) * crPart (StateAlgebra.ofState Ï†') := by
  rw [normalOrder_crPart_mul]
  conv_lhs => rw [â† mul_one (crPart (StateAlgebra.ofState Ï†'))]
  rw [normalOrder_crPart_mul, normalOrder_one]
  simp

@[simp]
lemma normalOrder_anPart_mul_anPart (Ï† Ï†' : ğ“•.States) :
    normalOrder (anPart (StateAlgebra.ofState Ï†) * anPart (StateAlgebra.ofState Ï†')) =
    anPart (StateAlgebra.ofState Ï†) * anPart (StateAlgebra.ofState Ï†') := by
  rw [normalOrder_mul_anPart]
  conv_lhs => rw [â† one_mul (anPart (StateAlgebra.ofState Ï†))]
  rw [normalOrder_mul_anPart, normalOrder_one]
  simp

@[simp]
lemma normalOrder_crPart_mul_anPart (Ï† Ï†' : ğ“•.States) :
    normalOrder (crPart (StateAlgebra.ofState Ï†) * anPart (StateAlgebra.ofState Ï†')) =
    crPart (StateAlgebra.ofState Ï†) * anPart (StateAlgebra.ofState Ï†') := by
  rw [normalOrder_crPart_mul]
  conv_lhs => rw [â† one_mul (anPart (StateAlgebra.ofState Ï†'))]
  rw [normalOrder_mul_anPart, normalOrder_one]
  simp

@[simp]
lemma normalOrder_anPart_mul_crPart (Ï† Ï†' : ğ“•.States) :
    normalOrder (anPart (StateAlgebra.ofState Ï†) * crPart (StateAlgebra.ofState Ï†')) =
    (FieldStatistic.pairedSign (ğ“•.statesStatistic Ï†)) (ğ“•.statesStatistic Ï†') â€¢
    (crPart (StateAlgebra.ofState Ï†') * anPart (StateAlgebra.ofState Ï†)) := by
  conv_lhs => rw [â† one_mul (anPart (StateAlgebra.ofState Ï†) * crPart (StateAlgebra.ofState Ï†'))]
  conv_lhs => rw [â† mul_one (1 * (anPart (StateAlgebra.ofState Ï†) * crPart (StateAlgebra.ofState Ï†')))]
  rw [â† mul_assoc, normalOrder_swap_anPart_crPart]
  simp

lemma normalOrder_ofState_mul_ofState (Ï† Ï†' : ğ“•.States) :
    normalOrder (ofState Ï† * ofState Ï†') =
    crPart (StateAlgebra.ofState Ï†) * crPart (StateAlgebra.ofState Ï†') +
    (FieldStatistic.pairedSign (ğ“•.statesStatistic Ï†)) (ğ“•.statesStatistic Ï†') â€¢
      (crPart (StateAlgebra.ofState Ï†') * anPart (StateAlgebra.ofState Ï†)) +
    crPart (StateAlgebra.ofState Ï†) * anPart (StateAlgebra.ofState Ï†') +
    anPart (StateAlgebra.ofState Ï†) * anPart (StateAlgebra.ofState Ï†')  := by
  rw [ofState_eq_crPart_add_anPart, ofState_eq_crPart_add_anPart]
  rw [mul_add, add_mul, add_mul]
  simp
  abel

end

end CrAnAlgebra

namespace OperatorAlgebra
variable {ğ“ : OperatorAlgebra ğ“•}
open CrAnAlgebra

lemma crAnF_normalOrder_superCommute_ofCrAnList_create_create_ofCrAnList
    (Ï†c Ï†c' : ğ“•.CrAnStates)
    (hÏ†c : ğ“•.crAnStatesToCreateAnnihilate Ï†c = CreateAnnihilate.create)
    (hÏ†c' : ğ“•.crAnStatesToCreateAnnihilate Ï†c' = CreateAnnihilate.create)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    ğ“.crAnF (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†c) (ofCrAnState Ï†c') * ofCrAnList Ï†s'))
    = 0 := by
  rw [normalOrder_superCommute_ofCrAnList_create_create_ofCrAnList Ï†c Ï†c' hÏ†c hÏ†c' Ï†s Ï†s']
  rw [map_smul, map_mul, map_mul, map_mul, ğ“.superCommute_create_create Ï†c Ï†c' hÏ†c hÏ†c']
  simp

lemma crAnF_normalOrder_superCommute_ofCrAnList_annihilate_annihilate_ofCrAnList
    (Ï†a Ï†a' : ğ“•.CrAnStates)
    (hÏ†a : ğ“•.crAnStatesToCreateAnnihilate Ï†a = CreateAnnihilate.annihilate)
    (hÏ†a' : ğ“•.crAnStatesToCreateAnnihilate Ï†a' = CreateAnnihilate.annihilate)
    (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    ğ“.crAnF (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * ofCrAnList Ï†s'))
    = 0 := by
  rw [normalOrder_superCommute_ofCrAnList_annihilate_annihilate_ofCrAnList Ï†a Ï†a' hÏ†a hÏ†a' Ï†s Ï†s']
  rw [map_smul, map_mul, map_mul, map_mul, ğ“.superCommute_annihilate_annihilate Ï†a Ï†a' hÏ†a hÏ†a']
  simp

lemma crAnF_normalOrder_superCommute_ofCrAnList_ofCrAnList_eq_zero
    (Ï†a Ï†a' : ğ“•.CrAnStates) (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    ğ“.crAnF (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * ofCrAnList Ï†s'))
    = 0 := by
  rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†a) with hÏ†a | hÏ†a
  <;> rcases CreateAnnihilate.eq_create_or_annihilate (ğ“•.crAnStatesToCreateAnnihilate Ï†a') with hÏ†a' | hÏ†a'
  Â· rw [normalOrder_superCommute_ofCrAnList_create_create_ofCrAnList Ï†a Ï†a' hÏ†a hÏ†a' Ï†s Ï†s']
    rw [map_smul, map_mul, map_mul, map_mul, ğ“.superCommute_create_create Ï†a Ï†a' hÏ†a hÏ†a']
    simp
  Â· rw [normalOrder_superCommute_create_annihilate Ï†a Ï†a' hÏ†a hÏ†a' (ofCrAnList Ï†s)
      (ofCrAnList Ï†s')]
    simp
  Â· rw [normalOrder_superCommute_annihilate_create Ï†a' Ï†a hÏ†a' hÏ†a (ofCrAnList Ï†s)
      (ofCrAnList Ï†s')]
    simp
  Â· rw [normalOrder_superCommute_ofCrAnList_annihilate_annihilate_ofCrAnList Ï†a Ï†a' hÏ†a hÏ†a' Ï†s Ï†s']
    rw [map_smul, map_mul, map_mul, map_mul, ğ“.superCommute_annihilate_annihilate Ï†a Ï†a' hÏ†a hÏ†a']
    simp

lemma crAnF_normalOrder_superCommute_ofCrAnList_eq_zero
    (Ï†a Ï†a' : ğ“•.CrAnStates) (Ï†s : List ğ“•.CrAnStates)
    (a : ğ“•.CrAnAlgebra) : ğ“.crAnF (normalOrder (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * a))
    = 0 := by
  change (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap ( (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') ))) a =
    0
  have hf : ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap ( (ofCrAnList Ï†s * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a'))) = 0 := by
    apply ofCrAnListBasis.ext
    intro l
    simp
    exact crAnF_normalOrder_superCommute_ofCrAnList_ofCrAnList_eq_zero Ï†a Ï†a' Ï†s l
  rw [hf]
  simp

lemma crAnF_normalOrder_superCommute_ofCrAnState_eq_zero_mul (Ï†a Ï†a' : ğ“•.CrAnStates)
    (a b : ğ“•.CrAnAlgebra) :
    ğ“.crAnF (normalOrder (a * superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * b)) = 0 := by
  rw [mul_assoc]
  change (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap.flip ((superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * b ))) a =
    0
  have hf :  (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚— mulLinearMap.flip ((superCommute (ofCrAnState Ï†a) (ofCrAnState Ï†a') * b ))) = 0 := by
    apply ofCrAnListBasis.ext
    intro l
    simp [mulLinearMap]
    rw [â† mul_assoc]
    exact crAnF_normalOrder_superCommute_ofCrAnList_eq_zero Ï†a Ï†a' _ _
  rw [hf]
  simp


lemma crAnF_normalOrder_superCommute_ofCrAnState_ofCrAnList_eq_zero_mul (Ï†a : ğ“•.CrAnStates)
    (Ï†s : List ğ“•.CrAnStates)
    (a b : ğ“•.CrAnAlgebra) :
    ğ“.crAnF (normalOrder (a * superCommute (ofCrAnState Ï†a) (ofCrAnList Ï†s) * b)) = 0 := by
  rw [â† ofCrAnList_singleton, superCommute_ofCrAnList_ofCrAnList_eq_sum]
  rw [Finset.mul_sum, Finset.sum_mul]
  rw [map_sum, map_sum]
  apply Fintype.sum_eq_zero
  intro n
  rw [â† mul_assoc, â† mul_assoc]
  rw [mul_assoc _ _ b, ofCrAnList_singleton]
  rw [crAnF_normalOrder_superCommute_ofCrAnState_eq_zero_mul]

lemma crAnF_normalOrder_superCommute_ofCrAnList_ofCrAnState_eq_zero_mul (Ï†a : ğ“•.CrAnStates)
    (Ï†s : List ğ“•.CrAnStates)
    (a b : ğ“•.CrAnAlgebra) :
    ğ“.crAnF (normalOrder (a * superCommute (ofCrAnList Ï†s)  (ofCrAnState Ï†a) * b)) = 0 := by
  rw [â† ofCrAnList_singleton, superCommute_ofCrAnList_symm, ofCrAnList_singleton]
  simp only [FieldStatistic.instCommGroup.eq_1, FieldStatistic.ofList_singleton,  mul_neg,
    Algebra.mul_smul_comm, neg_mul, Algebra.smul_mul_assoc, map_neg, map_smul]
  rw [crAnF_normalOrder_superCommute_ofCrAnState_ofCrAnList_eq_zero_mul]
  simp

lemma crAnF_normalOrder_superCommute_ofCrAnList_ofCrAnList_eq_zero_mul
    (Ï†s Ï†s' : List ğ“•.CrAnStates)
    (a b : ğ“•.CrAnAlgebra) :
    ğ“.crAnF (normalOrder (a * superCommute (ofCrAnList Ï†s) (ofCrAnList Ï†s') * b)) = 0 := by
  rw [ superCommute_ofCrAnList_ofCrAnList_eq_sum]
  rw [Finset.mul_sum, Finset.sum_mul]
  rw [map_sum, map_sum]
  apply Fintype.sum_eq_zero
  intro n
  rw [â† mul_assoc, â† mul_assoc]
  rw [mul_assoc _ _ b]
  rw [crAnF_normalOrder_superCommute_ofCrAnList_ofCrAnState_eq_zero_mul]

lemma crAnF_normalOrder_superCommute_ofCrAnList_eq_zero_mul
    (Ï†s : List ğ“•.CrAnStates)
    (a b c : ğ“•.CrAnAlgebra) :
    ğ“.crAnF (normalOrder (a * superCommute (ofCrAnList Ï†s) c * b)) = 0 := by
  change (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚—
    mulLinearMap.flip b âˆ˜â‚— mulLinearMap a âˆ˜â‚— superCommute (ofCrAnList Ï†s)) c = 0
  have hf : (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚—
    mulLinearMap.flip b âˆ˜â‚— mulLinearMap a âˆ˜â‚— superCommute (ofCrAnList Ï†s)) = 0 := by
    apply ofCrAnListBasis.ext
    intro Ï†s'
    simp [mulLinearMap]
    rw [crAnF_normalOrder_superCommute_ofCrAnList_ofCrAnList_eq_zero_mul]
  rw [hf]
  simp

@[simp]
lemma crAnF_normalOrder_superCommute_eq_zero_mul
    (a b c d : ğ“•.CrAnAlgebra) : ğ“.crAnF (normalOrder (a * superCommute d c * b)) = 0 := by
  change (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚—
    mulLinearMap.flip b âˆ˜â‚— mulLinearMap a âˆ˜â‚— superCommute.flip c) d = 0
  have hf : (ğ“.crAnF.toLinearMap âˆ˜â‚— normalOrder âˆ˜â‚—
    mulLinearMap.flip b âˆ˜â‚— mulLinearMap a âˆ˜â‚— superCommute.flip c) = 0 := by
    apply ofCrAnListBasis.ext
    intro Ï†s
    simp [mulLinearMap]
    rw [crAnF_normalOrder_superCommute_ofCrAnList_eq_zero_mul]
  rw [hf]
  simp

@[simp]
lemma crAnF_normalOrder_superCommute_eq_zero
    (c d : ğ“•.CrAnAlgebra) : ğ“.crAnF (normalOrder (superCommute d c)) = 0 := by
  rw [â† crAnF_normalOrder_superCommute_eq_zero_mul 1 1 c d]
  simp


lemma crAnF_normalOrder_ofState_ofState_swap (Ï† Ï†' : ğ“•.States) :
    ğ“.crAnF (normalOrder (ofState Ï† * ofState Ï†')) =
    (FieldStatistic.pairedSign (ğ“•.statesStatistic Ï†)) (ğ“•.statesStatistic Ï†') â€¢
    ğ“.crAnF (normalOrder (ofState Ï†' * ofState Ï†)) := by
  conv_lhs =>
    rhs
    rhs
    rw [ofState_eq_crPart_add_anPart, ofState_eq_crPart_add_anPart]
    rw [mul_add, add_mul, add_mul]
    rw [crPart_crPart_eq_superCommute, crPart_anPart_eq_superCommute,
      anPart_anPart_eq_superCommute, anPart_crPart_eq_superCommute]
  simp only [FieldStatistic.instCommGroup.eq_1, Algebra.smul_mul_assoc, map_add, map_smul,
    normalOrder_crPart_mul_crPart, normalOrder_crPart_mul_anPart, normalOrder_anPart_mul_crPart,
    normalOrder_anPart_mul_anPart, map_mul, crAnF_normalOrder_superCommute_eq_zero, add_zero]
  rw [normalOrder_ofState_mul_ofState]
  simp
  rw [smul_smul]
  simp
  abel
open FieldStatistic
lemma crAnF_normalOrder_ofCrAnState_ofCrAnList_swap (Ï† : ğ“•.CrAnStates)
    (Ï†s : List ğ“•.CrAnStates) :
    ğ“.crAnF (normalOrder (ofCrAnState Ï† * ofCrAnList Ï†s)) =
    ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› Ï†s) â€¢ ğ“.crAnF (normalOrder (ofCrAnList Ï†s * ofCrAnState Ï†)) := by
  rw [â† ofCrAnList_singleton, ofCrAnList_mul_ofCrAnList_eq_superCommute]
  simp

lemma crAnF_normalOrder_ofCrAnState_ofStatesList_swap (Ï†  : ğ“•.CrAnStates)
    (Ï†' : List ğ“•.States) :
    ğ“.crAnF (normalOrder (ofCrAnState Ï† * ofStateList Ï†')) =
    (FieldStatistic.pairedSign (ğ“•.crAnStatistics Ï†)) (FieldStatistic.ofList ğ“•.statesStatistic Ï†') â€¢
    ğ“.crAnF (normalOrder (ofStateList Ï†' * ofCrAnState Ï†)) := by
  rw [â† ofCrAnList_singleton, ofCrAnList_mul_ofStateList_eq_superCommute ]
  simp

lemma crAnF_normalOrder_anPart_ofStatesList_swap  (Ï†  : ğ“•.States)
    (Ï†' : List ğ“•.States) :
    ğ“.crAnF (normalOrder (anPart (StateAlgebra.ofState Ï†) * ofStateList Ï†')) =
    (FieldStatistic.pairedSign (ğ“•.statesStatistic Ï†)) (FieldStatistic.ofList ğ“•.statesStatistic Ï†') â€¢
    ğ“.crAnF (normalOrder (ofStateList Ï†' * anPart (StateAlgebra.ofState Ï†))) := by
  match Ï† with
  | .negAsymp Ï† =>
    simp
  | .position Ï† =>
    simp
    rw [crAnF_normalOrder_ofCrAnState_ofStatesList_swap]
    rfl
  | .posAsymp Ï† =>
    simp
    rw [crAnF_normalOrder_ofCrAnState_ofStatesList_swap]
    rfl

lemma crAnF_normalOrder_ofStatesList_anPart_swap (Ï†  : ğ“•.States)
    (Ï†' : List ğ“•.States) :
     ğ“.crAnF (normalOrder  (ofStateList Ï†' * anPart (StateAlgebra.ofState Ï†)))
    = (FieldStatistic.pairedSign (ğ“•.statesStatistic Ï†)) (FieldStatistic.ofList ğ“•.statesStatistic Ï†') â€¢
    ğ“.crAnF (normalOrder (anPart (StateAlgebra.ofState Ï†) * ofStateList Ï†')) := by
  rw [crAnF_normalOrder_anPart_ofStatesList_swap]
  simp [smul_smul, FieldStatistic.pairedSign_mul_self]

lemma crAnF_normalOrder_ofStatesList_mul_anPart_swap  (Ï†  : ğ“•.States)
    (Ï†' : List ğ“•.States) :
     ğ“.crAnF (normalOrder (ofStateList Ï†') * anPart (StateAlgebra.ofState Ï†)) =
    (FieldStatistic.pairedSign (ğ“•.statesStatistic Ï†)) (FieldStatistic.ofList ğ“•.statesStatistic Ï†') â€¢
    ğ“.crAnF (normalOrder (anPart (StateAlgebra.ofState Ï†) * ofStateList Ï†')) := by
  rw [â† normalOrder_mul_anPart]
  rw [crAnF_normalOrder_ofStatesList_anPart_swap]

lemma crAnF_ofCrAnState_superCommute_normalOrder_ofCrAnList_eq_sum (Ï†  : ğ“•.CrAnStates)
    (Ï†s : List ğ“•.CrAnStates) : ğ“.crAnF (âŸ¨ofCrAnState Ï†, normalOrder (ofCrAnList Ï†s)âŸ©â‚›ca) =
    âˆ‘ n : Fin Ï†s.length, ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› (Ï†s.take n)) â€¢
      ğ“.crAnF (âŸ¨ofCrAnState Ï†, ofCrAnState Ï†s[n]âŸ©â‚›ca)
      * ğ“.crAnF (normalOrder (ofCrAnList (Ï†s.eraseIdx n))) := by
  rw [normalOrder_ofCrAnList, map_smul, map_smul]
  rw [crAnF_superCommute_ofCrAnState_ofCrAnList_eq_sum, sum_normalOrderList_length]
  simp [Finset.smul_sum]
  congr
  funext n
  rw [ofCrAnList_eq_normalOrder, map_smul, mul_smul_comm, smul_smul, smul_smul]
  by_cases hs : (ğ“• |>â‚› Ï†) = (ğ“• |>â‚› Ï†s[n])
  Â· congr
    erw [normalOrderSign_eraseIdx, â†  hs]
    trans (normalOrderSign Ï†s * normalOrderSign Ï†s) *
      (ğ“¢(ğ“• |>â‚› (Ï†s.get n), ğ“• |>â‚› ((normalOrderList Ï†s).take (normalOrderEquiv n))) *
      ğ“¢(ğ“• |>â‚› (Ï†s.get n), ğ“• |>â‚› ((normalOrderList Ï†s).take (normalOrderEquiv n))))
      *  ğ“¢(ğ“• |>â‚› (Ï†s.get n), ğ“• |>â‚› (Ï†s.take n))
    Â· ring_nf
      rw [hs]
      rfl
    Â· simp [hs]
  Â· erw [ğ“.superCommute_different_statistics _ _ hs]
    simp



lemma crAnF_anPart_mul_normalOrder_ofStatesList_eq_superCommute (Ï†  : ğ“•.States)
    (Ï†' : List ğ“•.States) :
    ğ“.crAnF (anPart (StateAlgebra.ofState Ï†) * normalOrder (ofStateList Ï†')) =
    ğ“.crAnF (normalOrder (anPart (StateAlgebra.ofState Ï†) * ofStateList Ï†')) +
    ğ“.crAnF (âŸ¨anPart (StateAlgebra.ofState Ï†), normalOrder (ofStateList Ï†')âŸ©â‚›ca) := by
  sorry

end OperatorAlgebra

end FieldStruct
