/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.FieldStruct.NormalOrder
import HepLean.PerturbationTheory.Wick.Signs.KoszulSign
import HepLean.Mathematics.List.InsertIdx
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Finset.Image
/-!

# Contractions


-/

namespace FieldStruct
variable {ùìï : FieldStruct}

def ContractionsNat (n : ‚Ñï) : Type :=
  {f : Finset ((Finset (Fin n))) // (‚àÄ a ‚àà f, a.card = 2) ‚àß
    (‚àÄ a ‚àà f, ‚àÄ b ‚àà f, a = b ‚à® Disjoint a b)}

namespace ContractionsNat
variable {n : ‚Ñï} (c : ContractionsNat n)
open HepLean.List

local instance : IsTotal (Fin n √ó Fin n) (fun a b => a.1 ‚â§ b.1) where
  total := by
    intro a b
    exact le_total a.1 b.1

local instance : IsTrans (Fin n √ó Fin n) (fun a b => a.1 ‚â§ b.1) where
  trans := by
    intro a b c ha hb
    exact Fin.le_trans ha hb

def congr : {n m : ‚Ñï} ‚Üí (h : n = m) ‚Üí ContractionsNat n ‚âÉ ContractionsNat m
  | n, .(n), rfl => Equiv.refl _

@[simp]
lemma congr_refl : c.congr rfl = c := by
  cases c
  rfl

def getDual? (i : Fin n) : Option (Fin n) := Fin.find (fun j => {i, j} ‚àà c.1)

lemma getDual?_eq_some_iff_mem (i j : Fin n) :
    c.getDual? i = some j ‚Üî {i, j} ‚àà c.1 := by
  simp [getDual?]
  rw [Fin.find_eq_some_iff]
  apply Iff.intro
  ¬∑ intro h
    exact h.1
  ¬∑ intro h
    simp [h]
    intro k hk
    have hc := c.2.2 _ h _ hk
    simp at hc
    have hj : k ‚àà ({i, j} : Finset (Fin n)):= by
      simp [hc]
    simp at hj
    rcases hj with hj | hj
    ¬∑ subst hj
      simp at hk
      have hc := c.2.1 _ hk
      simp at hc
    ¬∑ subst hj
      simp

@[simp]
lemma getDual?_one_eq_none (c : ContractionsNat 1) (i : Fin 1) : c.getDual? i = none := by
  by_contra h
  have hn : (c.getDual? i).isSome := by
    rw [‚Üê Option.not_isSome_iff_eq_none] at h
    simpa  [- Option.not_isSome, -Option.isNone_iff_eq_none] using h
  rw [@Option.isSome_iff_exists] at hn
  obtain ‚ü®a, hn‚ü© := hn
  rw [getDual?_eq_some_iff_mem] at hn
  have hc := c.2.1 {i, a} hn
  fin_cases i
  fin_cases a
  simp at hc

@[simp]
lemma getDual?_get_self_mem (i : Fin n) (h : (c.getDual? i).isSome) :
    {(c.getDual? i).get h, i} ‚àà c.1 := by
  rw [@Finset.pair_comm]
  rw [‚Üê getDual?_eq_some_iff_mem]
  simp

@[simp]
lemma self_getDual?_get_mem (i : Fin n) (h : (c.getDual? i).isSome) :
    {i, (c.getDual? i).get h} ‚àà c.1 := by
  rw [‚Üê getDual?_eq_some_iff_mem]
  simp

lemma getDual?_eq_some_neq (i j : Fin n) (h : c.getDual? i = some j) :
     ¬¨ i = j := by
  rw [getDual?_eq_some_iff_mem] at h
  by_contra hn
  subst hn
  have hc := c.2.1 _ h
  simp at hc

@[simp]
lemma self_neq_getDual?_get (i : Fin n) (h : (c.getDual? i).isSome) :
    ¬¨ i = (c.getDual? i).get h := by
  by_contra hn
  have hx : {i, (c.getDual? i).get h} ‚àà c.1 := by simp
  have hc := c.2.1 _ hx
  nth_rewrite 1 [hn] at hc
  simp at hc

@[simp]
lemma getDual?_get_self_neq (i : Fin n) (h : (c.getDual? i).isSome) :
    ¬¨ (c.getDual? i).get h  = i := by
  by_contra hn
  have hx : {i, (c.getDual? i).get h} ‚àà c.1 := by simp
  have hc := c.2.1 _ hx
  nth_rewrite 1 [hn] at hc
  simp at hc

def uncontracted : Finset (Fin n) := Finset.filter (fun i => c.getDual? i = none) (Finset.univ)

lemma congr_uncontracted {n m : ‚Ñï} (c : ContractionsNat n) (h : n = m) :
    (c.congr h).uncontracted = Finset.map (finCongr h).toEmbedding c.uncontracted := by
  subst h
  simp

def uncontractedCongr {c c': ContractionsNat n} (h : c = c') :
    Option c.uncontracted ‚âÉ Option c'.uncontracted :=
    Equiv.optionCongr (Equiv.subtypeEquivRight (by rw [h]; simp))

@[simp]
lemma uncontractedCongr_none {c c': ContractionsNat n} (h : c = c') :
    (uncontractedCongr h) none = none := by
  simp [uncontractedCongr]

@[simp]
lemma uncontractedCongr_some {c c': ContractionsNat n} (h : c = c') (i : c.uncontracted) :
    (uncontractedCongr h) (some i) = some (Equiv.subtypeEquivRight (by rw [h]; simp) i) := by
  simp [uncontractedCongr]


lemma mem_uncontracted_iff_not_contracted (i : Fin n)  :
    i ‚àà c.uncontracted ‚Üî ‚àÄ p ‚àà c.1, i ‚àâ p := by
  simp [uncontracted, getDual?]
  apply Iff.intro
  ¬∑ intro h p hp
    have hp := c.2.1 p hp
    rw [Finset.card_eq_two] at hp
    obtain ‚ü®a, b, ha, hb, hab‚ü© := hp
    rw [Fin.find_eq_none_iff] at h
    by_contra hn
    simp at hn
    rcases hn with hn | hn
    ¬∑ subst hn
      exact h b hp
    ¬∑ subst hn
      rw [Finset.pair_comm] at hp
      exact h a hp
  ¬∑ intro h
    rw [Fin.find_eq_none_iff]
    by_contra hn
    simp at hn
    obtain ‚ü®j, hj‚ü© := hn
    apply h {i, j} hj
    simp

lemma eq_filter_mem_self : c.1 = Finset.filter (fun x => x ‚àà c.1) Finset.univ := by
  exact Eq.symm (Finset.filter_univ_mem c.1)

def erase (c : ContractionsNat n.succ) (i : Fin n.succ) : ContractionsNat n := by
  refine ‚ü®Finset.filter (fun x => Finset.map i.succAboveEmb x ‚àà c.1) Finset.univ, ?_, ?_‚ü©
  ¬∑ intro a ha
    simpa using c.2.1 (Finset.map i.succAboveEmb a) (by simpa using ha)
  ¬∑ intro a ha b hb
    simp at ha hb
    rw [‚Üê Finset.disjoint_map i.succAboveEmb, ‚Üê (Finset.map_injective i.succAboveEmb).eq_iff]
    exact c.2.2 _ ha _ hb

lemma mem_erase_uncontracted_iff (c : ContractionsNat n.succ) (i : Fin n.succ) (j : Fin n) :
    j ‚àà (c.erase i).uncontracted ‚Üî
    i.succAbove j ‚àà c.uncontracted ‚à® c.getDual? (i.succAbove j) = some i  := by
  rw [getDual?_eq_some_iff_mem]
  simp [uncontracted,erase, getDual?]
  rw [Fin.find_eq_none_iff, Fin.find_eq_none_iff]
  apply Iff.intro
  ¬∑ intro h
    by_cases hi : {i.succAbove j, i} ‚àà c.1
    ¬∑ simp [hi]
    ¬∑ apply Or.inl
      intro k
      by_cases hi' : k = i
      ¬∑ subst hi'
        exact hi
      ¬∑ simp [‚Üê Fin.exists_succAbove_eq_iff] at hi'
        obtain ‚ü®z, hz‚ü© := hi'
        subst hz
        exact h z
  ¬∑ intro h
    intro k
    rcases h with h | h
    ¬∑ exact h (i.succAbove k)
    ¬∑ by_contra hn
      have hc := c.2.2 _ h _ hn
      simp at hc
      have hi : i ‚àà ({i.succAbove j, i.succAbove k} : Finset (Fin n.succ)) := by
        simp [‚Üê hc]
      simp at hi
      rcases hi with hi | hi
      ¬∑ exact False.elim (Fin.succAbove_ne _ _ hi.symm)
      ¬∑ exact False.elim (Fin.succAbove_ne _ _ hi.symm)


lemma mem_not_eq_erase_of_isSome (c : ContractionsNat n.succ) (i : Fin n.succ) (h : (c.getDual? i).isSome)
    (ha : a ‚àà c.1) (ha2 : a ‚â† {i, (c.getDual? i).get h}) :
    ‚àÉ a', a' ‚àà (c.erase i).1  ‚àß a = Finset.map i.succAboveEmb a' := by
  have h2a := c.2.1 a ha
  rw [@Finset.card_eq_two] at h2a
  obtain ‚ü®x, y, hx,hy‚ü© := h2a
  subst hy
  have hxn : ¬¨ x = i := by
    by_contra hx
    subst hx
    rw [‚Üê @getDual?_eq_some_iff_mem] at ha
    rw [(Option.get_of_mem h ha)] at ha2
    simp at ha2
  have hyn : ¬¨ y = i := by
    by_contra hy
    subst hy
    rw [@Finset.pair_comm] at ha
    rw [‚Üê @getDual?_eq_some_iff_mem] at ha
    rw [(Option.get_of_mem h ha)] at ha2
    simp [Finset.pair_comm] at ha2
  simp [‚Üê Fin.exists_succAbove_eq_iff] at hxn hyn
  obtain ‚ü®x', hx'‚ü© := hxn
  obtain ‚ü®y', hy'‚ü© := hyn
  use {x', y'}
  subst hx' hy'
  simp [erase]
  exact ha

lemma mem_not_eq_erase_of_isNone (c : ContractionsNat n.succ) (i : Fin n.succ) (h : (c.getDual? i).isNone)
    (ha : a ‚àà c.1)  :
    ‚àÉ a', a' ‚àà (c.erase i).1  ‚àß a = Finset.map i.succAboveEmb a' := by
  have h2a := c.2.1 a ha
  rw [@Finset.card_eq_two] at h2a
  obtain ‚ü®x, y, hx,hy‚ü© := h2a
  subst hy
  have hi : i ‚àà c.uncontracted := by
    simp [uncontracted, h]
    simp_all only [Nat.succ_eq_add_one, Option.isNone_iff_eq_none, ne_eq]
  rw [@mem_uncontracted_iff_not_contracted] at hi
  have hxn : ¬¨ x = i := by
    by_contra hx
    subst hx
    exact hi {x, y} ha (by simp)
  have hyn : ¬¨ y = i := by
    by_contra hy
    subst hy
    exact hi {x, y} ha (by simp)
  simp [‚Üê Fin.exists_succAbove_eq_iff] at hxn hyn
  obtain ‚ü®x', hx'‚ü© := hxn
  obtain ‚ü®y', hy'‚ü© := hyn
  use {x', y'}
  subst hx' hy'
  simp [erase]
  exact ha

def insert (c : ContractionsNat n) (i : Fin n.succ) (j : Option (c.uncontracted)) :
    ContractionsNat n.succ := by
  let f := Finset.map (Finset.mapEmbedding i.succAboveEmb).toEmbedding c.1
  let f' := match j with | none => f | some j => Insert.insert {i, i.succAbove j} f
  refine ‚ü®f', ?_, ?_‚ü©
  ¬∑ simp [f']
    match j with
    | none =>
      simp [f', f]
      intro a ha
      rw [Finset.mapEmbedding_apply]
      simp [Finset.mapEmbedding_apply]
      exact c.2.1  a ha
    | some j =>
      simp
      apply And.intro
      ¬∑ rw [@Finset.card_eq_two]
        use i
        use (i.succAbove j)
        simp
        exact Fin.ne_succAbove i j
      ¬∑ simp [f]
        intro a ha
        rw [Finset.mapEmbedding_apply]
        simp
        exact c.2.1 a ha
  ¬∑ intro a ha b hb
    simp [f'] at ha hb
    match j with
    | none =>
      simp_all [f]
      obtain ‚ü®a', ha', ha''‚ü© := ha
      obtain ‚ü®b', hb', hb''‚ü© := hb
      subst ha''
      subst hb''
      simp
      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply, Finset.disjoint_map]
      exact c.2.2 a' ha' b' hb'
    | some j =>
      simp_all
      match ha, hb with
      | Or.inl ha, Or.inl hb =>
        rw [ha, hb]
        simp
      | Or.inl ha, Or.inr hb =>
        apply Or.inr
        subst ha
        simp
        simp [f] at hb
        obtain ‚ü®a', hb', hb''‚ü© := hb
        subst hb''
        rw [Finset.mapEmbedding_apply]
        apply And.intro
        ¬∑ simp
          exact fun x _  => Fin.succAbove_ne i x
        ¬∑ simp
          have hj := j.2
          rw [mem_uncontracted_iff_not_contracted] at hj
          intro a ha hja
          rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hja
          subst hja
          exact False.elim (hj a' hb' ha)
      | Or.inr ha, Or.inl hb =>
        apply Or.inr
        subst hb
        simp
        simp [f] at ha
        obtain ‚ü®a', ha', ha''‚ü© := ha
        subst ha''
        rw [Finset.mapEmbedding_apply]
        apply And.intro
        ¬∑ simp
          exact fun x _ => Fin.succAbove_ne i x
        ¬∑ simp
          have hj := j.2
          rw [mem_uncontracted_iff_not_contracted] at hj
          intro a ha hja
          rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hja
          subst hja
          exact False.elim (hj a' ha' ha)
      | Or.inr ha, Or.inr hb =>
        simp_all [f]
        obtain ‚ü®a', ha', ha''‚ü© := ha
        obtain ‚ü®b', hb', hb''‚ü© := hb
        subst ha''
        subst hb''
        simp
        rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply, Finset.disjoint_map]
        exact c.2.2 a' ha' b' hb'

lemma insert_of_isSome (c : ContractionsNat n) (i : Fin n.succ) (j : Option c.uncontracted) (hj : j.isSome) :
    (insert c i j).1 = Insert.insert {i, i.succAbove (j.get hj)}
    (Finset.map (Finset.mapEmbedding i.succAboveEmb).toEmbedding c.1) := by
  simp [insert]
  rw [@Option.isSome_iff_exists] at hj
  obtain ‚ü®j, hj‚ü© := hj
  subst hj
  simp

@[simp]
lemma self_mem_uncontracted_of_insert_none (c : ContractionsNat n) (i : Fin n.succ) :
    i ‚àà (insert c i none).uncontracted := by
  rw [mem_uncontracted_iff_not_contracted]
  intro p hp
  simp [insert] at hp
  obtain ‚ü®a, ha, ha'‚ü© := hp
  have hc := c.2.1 a ha
  rw [@Finset.card_eq_two] at hc
  obtain ‚ü®x, y, hxy, ha‚ü© := hc
  subst ha
  subst ha'
  rw [Finset.mapEmbedding_apply]
  simp
  apply And.intro
  ¬∑ exact Fin.ne_succAbove i x
  ¬∑ exact Fin.ne_succAbove i y


lemma insert_none_getDual?_isNone (c : ContractionsNat n) (i : Fin n.succ) :
    ((insert c i none).getDual? i).isNone := by
  have hi : i ‚àà (insert c i none).uncontracted := by
    simp
  simp [uncontracted] at hi
  rw [hi]
  simp

@[simp]
lemma self_not_mem_uncontracted_of_insert_some (c : ContractionsNat n) (i : Fin n.succ) (j : c.uncontracted) :
    i ‚àâ (insert c i (some j)).uncontracted := by
  rw [mem_uncontracted_iff_not_contracted]
  simp [insert]

@[simp]
lemma insert_succAbove_mem_uncontracted_iff (c : ContractionsNat n) (i : Fin n.succ) (j : Fin n) :
    (i.succAbove j) ‚àà (insert c i none).uncontracted ‚Üî j ‚àà c.uncontracted := by
  rw [mem_uncontracted_iff_not_contracted, mem_uncontracted_iff_not_contracted]
  simp [insert]
  apply Iff.intro
  ¬∑ intro h p hp
    have hp' := h p hp
    have hc := c.2.1 p hp
    rw [Finset.card_eq_two] at hc
    obtain ‚ü®x, y, hxy, hp‚ü© := hc
    subst hp
    rw [Finset.mapEmbedding_apply] at hp'
    simp at hp'
    simp
    exact And.intro (fun a => hp'.1 (congrArg i.succAbove a))
      (fun a => hp'.2 (congrArg i.succAbove a))
  ¬∑ intro h p hp
    have hc := c.2.1 p hp
    rw [Finset.card_eq_two] at hc
    obtain ‚ü®x, y, hxy, hp‚ü© := hc
    subst hp
    rw [Finset.mapEmbedding_apply]
    simp
    have hp' := h {x, y} hp
    simp at hp'
    apply And.intro
      (fun a => hp'.1 (i.succAbove_right_injective a))
      (fun a => hp'.2 (i.succAbove_right_injective a))

@[simp]
lemma mem_uncontracted_insert_none_iff (c : ContractionsNat n) (i : Fin n.succ) (k : Fin n.succ) :
    k ‚àà (insert c i none).uncontracted ‚Üî
    k = i ‚à® ‚àÉ j, k = i.succAbove j ‚àß j ‚àà c.uncontracted := by
  by_cases hi : k = i
  ¬∑ subst hi
    simp
  ¬∑ simp [‚Üê Fin.exists_succAbove_eq_iff] at hi
    obtain ‚ü®z, hk‚ü© := hi
    subst hk
    have hn :  ¬¨ i.succAbove z = i := by exact Fin.succAbove_ne i z
    simp [hn]
    apply Iff.intro
    ¬∑ intro h
      exact  ‚ü®z, rfl, h‚ü©
    ¬∑ intro h
      obtain ‚ü®j, hk‚ü© := h
      have hjk : z = j := Fin.succAbove_right_inj.mp hk.1
      subst hjk
      exact hk.2

lemma insert_none_uncontracted (c : ContractionsNat n) (i : Fin n.succ) :
    (insert c i none).uncontracted = Insert.insert i (c.uncontracted.map i.succAboveEmb) := by
  ext a
  simp
  apply Iff.intro
  ¬∑ intro a_1
    cases a_1 with
    | inl h =>
      subst h
      simp_all only [true_or]
    | inr h_1 =>
      obtain ‚ü®w, h‚ü© := h_1
      obtain ‚ü®left, right‚ü© := h
      subst left
      apply Or.inr
      apply Exists.intro
      ¬∑ apply And.intro
        on_goal 2 => {rfl
        }
        ¬∑ simp_all only
  ¬∑ intro a_1
    cases a_1 with
    | inl h =>
      subst h
      simp_all only [true_or]
    | inr h_1 =>
      obtain ‚ü®w, h‚ü© := h_1
      obtain ‚ü®left, right‚ü© := h
      subst right
      apply Or.inr
      apply Exists.intro
      ¬∑ apply And.intro
        on_goal 2 => {exact left
        }
        ¬∑ simp_all only

@[simp]
lemma mem_uncontracted_insert_some_iff (c : ContractionsNat n) (i : Fin n.succ)
    (k : Fin n.succ) (j : c.uncontracted) :
    k ‚àà (insert c i (some j)).uncontracted ‚Üî
    ‚àÉ z, k = i.succAbove z ‚àß z ‚àà c.uncontracted ‚àß z ‚â† j := by
  by_cases hki : k = i
  ¬∑ subst hki
    simp
    exact fun x hx => False.elim (Fin.ne_succAbove k x hx)
  ¬∑ simp [‚Üê Fin.exists_succAbove_eq_iff] at hki
    obtain ‚ü®z, hk‚ü© := hki
    subst hk
    by_cases hjz : j = z
    ¬∑ subst hjz
      rw [mem_uncontracted_iff_not_contracted]
      simp [insert]
      intro x
      rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)]
      exact fun a _a => a.symm
    ¬∑ apply Iff.intro
      ¬∑ intro h
        use z
        simp
        refine And.intro ?_ (fun a => hjz a.symm)
        rw [mem_uncontracted_iff_not_contracted]
        intro p hp
        rw [mem_uncontracted_iff_not_contracted] at h
        simp [insert] at h
        have hc := h.2 p hp
        rw [Finset.mapEmbedding_apply] at hc
        exact (Finset.mem_map' (i.succAboveEmb)).mpr.mt hc
      ¬∑ intro h
        obtain ‚ü®z', hz'1, hz'‚ü© := h
        rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hz'1
        subst hz'1
        rw [mem_uncontracted_iff_not_contracted]
        simp [insert]
        apply And.intro
        ¬∑ rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)]
          exact And.intro (Fin.succAbove_ne i z) (fun a => hjz a.symm)
        ¬∑ rw [mem_uncontracted_iff_not_contracted] at hz'
          exact fun a ha hc => hz'.1 a ha ((Finset.mem_map' (i.succAboveEmb)).mp hc)

lemma insert_some_uncontracted  (c : ContractionsNat n) (i : Fin n.succ) (j : c.uncontracted) :
    (insert c i (some j)).uncontracted = (c.uncontracted.erase j).map i.succAboveEmb := by
  ext a
  simp
  apply Iff.intro
  ¬∑ intro h
    obtain ‚ü®z, h1, h2, h3‚ü© := h
    subst h1
    rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)]
    simp [h3]
    use z
  ¬∑ intro h
    obtain ‚ü®z, h1, h2‚ü© := h.2
    use z
    subst h2
    simp
    obtain ‚ü®a, ha1 , ha2‚ü© := h.2
    rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at ha2
    subst ha2
    simp_all
    rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at h
    exact h.1

@[simp]
lemma insert_some_getDual?_eq (c : ContractionsNat n) (i : Fin n.succ) (j : c.uncontracted) :
    (insert c i (some j)).getDual? i = some (i.succAbove j) := by
  rw [getDual?_eq_some_iff_mem]
  simp [insert]

@[simp]
lemma insert_erase (c : ContractionsNat n) (i : Fin n.succ) (j : Option (c.uncontracted)) :
    erase (insert c i j) i = c := by
  refine Subtype.eq ?_
  simp [insert, erase]
  conv_rhs => rw [c.eq_filter_mem_self]
  refine Finset.filter_inj'.mpr ?_
  intro a _
  match j with
  | none =>
    simp
    apply Iff.intro
    ¬∑ intro ha
      obtain ‚ü®a', ha', ha''‚ü© := ha
      rw [Finset.mapEmbedding_apply] at ha''
      simp at ha''
      subst ha''
      exact ha'
    ¬∑ intro ha
      use a
      simp [ha]
      rw [Finset.mapEmbedding_apply]
  | some j =>
    simp
    apply Iff.intro
    ¬∑ intro ha
      rcases ha with ha | ha
      ¬∑ have hin : ¬¨ i ‚àà Finset.map i.succAboveEmb a := by
          simp
          intro x
          exact fun a => Fin.succAbove_ne i x
        refine False.elim (hin ?_)
        rw [ha]
        simp
      ¬∑ obtain ‚ü®a', ha', ha''‚ü© := ha
        rw [Finset.mapEmbedding_apply] at ha''
        simp at ha''
        subst ha''
        exact ha'
    ¬∑ intro ha
      apply Or.inr
      use a
      simp [ha]
      rw [Finset.mapEmbedding_apply]

open HepLean.Fin

def getDualErase {n : ‚Ñï} (c : ContractionsNat n.succ) (i : Fin n.succ) :
    Option ((erase c i).uncontracted) := by
  match n with
  | 0 => exact none
  | Nat.succ n =>
  refine if hj : (c.getDual? i).isSome then some ‚ü®(predAboveI i ((c.getDual? i).get hj)), ?_‚ü©
    else none
  rw [mem_erase_uncontracted_iff]
  apply Or.inr
  rw [succsAbove_predAboveI, getDual?_eq_some_iff_mem]
  ¬∑ simp
  ¬∑ apply c.getDual?_eq_some_neq _ _ _
    simp


@[simp]
lemma getDualErase_isSome_iff_getDual?_isSome (c : ContractionsNat n.succ) (i : Fin n.succ) :
     (c.getDualErase i).isSome ‚Üî (c.getDual? i).isSome := by
  match n with
  | 0 =>
    fin_cases i
    simp [getDualErase]

  | Nat.succ n =>
    simp [getDualErase]


@[simp]
lemma getDualErase_one (c : ContractionsNat 1) (i : Fin 1) :
    c.getDualErase i = none := by
  fin_cases i
  simp [getDualErase]

lemma insert_getDualErase (c : ContractionsNat n) (i : Fin n.succ) (j : Option c.uncontracted) :
    (insert c i j).getDualErase i = uncontractedCongr (c := c) (c' := (c.insert i j).erase i) (by simp) j := by
  match n with
  | 0 =>
    simp [getDualErase, insert]
    fin_cases j
    simp
  | Nat.succ n =>
  match j with
  | none =>
    have hi := insert_none_getDual?_isNone c i
    simp [getDualErase, hi]
  | some j =>
    simp only [Nat.succ_eq_add_one, getDualErase, insert_some_getDual?_eq, Option.isSome_some,
      ‚ÜìreduceDIte, Option.get_some, predAboveI_succAbove, uncontractedCongr_some, Option.some.injEq]
    rfl


@[simp]
lemma erase_insert (c : ContractionsNat n.succ) (i : Fin n.succ) :
    insert (erase c i) i (getDualErase c i) = c := by
  match n with
  | 0 =>
    apply Subtype.eq
    simp [getDualErase,  insert]
    ext a
    simp
    apply Iff.intro
    ¬∑ intro h
      simp only [erase, Nat.reduceAdd, Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ,
        true_and] at h
      obtain ‚ü®a', ha', ha''‚ü© := h
      subst ha''
      exact ha'
    ¬∑ intro ha
      obtain ‚ü®a, ha‚ü© := c.mem_not_eq_erase_of_isNone (a := a) i (by simp) ha
      simp_all only [Nat.succ_eq_add_one, Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none]
      obtain ‚ü®left, right‚ü© := ha
      subst right
      apply Exists.intro
      ¬∑ apply And.intro
        on_goal 2 => {rfl
        }
        ¬∑ simp_all only
  | Nat.succ n =>
  apply Subtype.eq
  by_cases hi : (c.getDual? i).isSome
  ¬∑ rw [insert_of_isSome]
    simp [getDualErase, hi]
    rw [succsAbove_predAboveI]
    ext a
    apply Iff.intro
    ¬∑ simp
      intro ha
      rcases ha with ha | ha
      ¬∑ subst ha
        simp
      ¬∑ obtain ‚ü®a', ha', ha''‚ü© := ha
        subst ha''
        simpa [erase] using ha'
    ¬∑ intro ha
      simp
      by_cases hia :  a = {i, (c.getDual? i).get hi}
      ¬∑ subst hia
        simp
      ¬∑ apply Or.inr
        simp [erase]
        obtain ‚ü®a', ha'‚ü© := c.mem_not_eq_erase_of_isSome (a := a) i hi ha hia
        use a'
        simp_all only [Nat.succ_eq_add_one, true_and]
        obtain ‚ü®left, right‚ü© := ha'
        subst right
        rfl
    simp
    exact (getDualErase_isSome_iff_getDual?_isSome c i).mpr hi
  ¬∑ simp [getDualErase, hi, insert]
    ext a
    simp
    apply Iff.intro
    ¬∑ intro h
      simp [erase] at h
      obtain ‚ü®a', ha', ha''‚ü© := h
      subst ha''
      exact ha'
    ¬∑ intro ha
      obtain ‚ü®a, ha‚ü© := c.mem_not_eq_erase_of_isNone (a := a) i (by simpa using hi) ha
      simp_all only [Nat.succ_eq_add_one, Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none]
      obtain ‚ü®left, right‚ü© := ha
      subst right
      apply Exists.intro
      ¬∑ apply And.intro
        on_goal 2 => {rfl
        }
        ¬∑ simp_all only

/-!

## extractEquiv

-/

lemma extractEquiv_equiv {c1 c2 : (c : ContractionsNat n) √ó Option c.uncontracted}
    (h : c1.1 = c2.1) (ho : c1.2 = uncontractedCongr (by rw [h]) c2.2) : c1 = c2 := by
  cases c1
  cases c2
  simp_all
  simp at h
  subst h
  simp [uncontractedCongr]
  rename_i a
  match a with
  | none => simp
  | some a =>
    simp
    ext
    simp


def extractEquiv (i : Fin n.succ) : ContractionsNat n.succ ‚âÉ
    (c : ContractionsNat n) √ó Option c.uncontracted  where
  toFun := fun c => ‚ü®erase c i, getDualErase c i‚ü©
  invFun := fun ‚ü®c, j‚ü© => insert c i j
  left_inv f := by
    simp
  right_inv f := by
    refine extractEquiv_equiv ?_ ?_
    simp
    simp
    have h1 := insert_getDualErase f.fst i f.snd
    exact insert_getDualErase _ i _

lemma extractEquiv_symm_none_uncontracted (i : Fin n.succ)  (c : ContractionsNat n) :
    ((extractEquiv i).symm ‚ü®c, none‚ü©).uncontracted =
    (Insert.insert i (c.uncontracted.map i.succAboveEmb)) := by
  exact insert_none_uncontracted c i

def nil : ContractionsNat n := ‚ü®‚àÖ, by simp, by simp‚ü©

instance fintype_zero : Fintype (ContractionsNat 0) where
  elems := {nil}
  complete := by
    intro c
    simp
    apply Subtype.eq
    simp [nil]
    ext a
    apply Iff.intro
    ¬∑ intro h
      have hc := c.2.1 a h
      rw [Finset.card_eq_two] at hc
      obtain ‚ü®x, y, hxy, ha‚ü© := hc
      exact Fin.elim0 x
    ¬∑ simp

instance fintype_succ : (n : ‚Ñï) ‚Üí Fintype (ContractionsNat n)
  | 0 => fintype_zero
  | Nat.succ n => by
    letI := fintype_succ n
    exact Fintype.ofEquiv _ (extractEquiv 0).symm

/-!

## Uncontracted List

-/
def uncontractedList : List (Fin n) := List.filter (fun x => x ‚àà c.uncontracted) (List.finRange n)

lemma uncontractedList_mem_iff (i : Fin n) :
    i ‚àà c.uncontractedList ‚Üî  i ‚àà c.uncontracted := by
  simp [uncontractedList]

lemma congr_uncontractedList {n m : ‚Ñï} (h : n = m) (c : ContractionsNat n) :
    ((congr h) c).uncontractedList = List.map (finCongr h) c.uncontractedList := by
  subst h
  simp [congr]

lemma uncontractedList_get_mem_uncontracted (i : Fin c.uncontractedList.length) :
    c.uncontractedList.get i ‚àà c.uncontracted := by
  rw [‚Üê uncontractedList_mem_iff]
  simp

lemma uncontractedList_sorted : List.Sorted (¬∑ ‚â§ ¬∑) c.uncontractedList := by
  rw [uncontractedList]
  apply List.Sorted.filter
  rw [‚Üê List.ofFn_id]
  exact Monotone.ofFn_sorted fun ‚¶Éa b‚¶Ñ a => a

lemma uncontractedList_nodup : c.uncontractedList.Nodup := by
  rw [uncontractedList]
  refine List.Nodup.filter (fun x => decide (x ‚àà c.uncontracted)) ?_
  exact List.nodup_finRange n

lemma uncontractedList_toFinset (c : ContractionsNat n) :
    c.uncontractedList.toFinset = c.uncontracted := by
  simp [uncontractedList]

lemma uncontractedList_eq_sort (c : ContractionsNat n) :
    c.uncontractedList = c.uncontracted.sort (¬∑ ‚â§ ¬∑) := by
  symm
  rw [‚Üê uncontractedList_toFinset]
  refine (List.toFinset_sort (Œ± := Fin n) (¬∑ ‚â§ ¬∑) ?_).mpr ?_
  ¬∑ exact uncontractedList_nodup c
  ¬∑ exact uncontractedList_sorted c

lemma uncontractedList_length_eq_card (c : ContractionsNat n) :
    c.uncontractedList.length = c.uncontracted.card := by
  rw [uncontractedList_eq_sort]
  exact Finset.length_sort fun x1 x2 => x1 ‚â§ x2



lemma fin_list_sorted_monotone_sorted {n m : ‚Ñï} (l: List (Fin n)) (hl : l.Sorted (¬∑ ‚â§ ¬∑))
   (f : Fin n ‚Üí Fin m) (hf : StrictMono f) :
    ((List.map f l)).Sorted (¬∑ ‚â§ ¬∑) := by
  induction l with
  | nil => simp
  | cons a l ih =>
    simp
    apply And.intro
    ¬∑ simp at hl
      intro b hb
      have hl1 := hl.1 b hb
      exact (StrictMono.le_iff_le hf).mpr hl1
    ¬∑ simp at hl
      exact ih hl.2

lemma fin_list_sorted_succAboveEmb_sorted (l: List (Fin n)) (hl : l.Sorted (¬∑ ‚â§ ¬∑)) (i : Fin n.succ)  :
    ((List.map i.succAboveEmb l)).Sorted (¬∑ ‚â§ ¬∑) := by
  apply fin_list_sorted_monotone_sorted
  exact hl
  simp
  exact Fin.strictMono_succAbove i

lemma uncontractedList_succAboveEmb_sorted (c : ContractionsNat n) (i : Fin n.succ) :
    ((List.map i.succAboveEmb c.uncontractedList)).Sorted (¬∑ ‚â§ ¬∑) := by
  apply fin_list_sorted_succAboveEmb_sorted
  exact uncontractedList_sorted c

lemma uncontractedList_succAboveEmb_nodup (c : ContractionsNat n) (i : Fin n.succ) :
    ((List.map i.succAboveEmb c.uncontractedList)).Nodup := by
  refine List.Nodup.map ?_ ?_
  ¬∑ exact Function.Embedding.injective i.succAboveEmb
  ¬∑ exact uncontractedList_nodup c

lemma uncontractedList_succAboveEmb_toFinset (c : ContractionsNat n) (i : Fin n.succ) :
    (List.map i.succAboveEmb c.uncontractedList).toFinset = (Finset.map i.succAboveEmb c.uncontracted) := by
  ext a
  simp
  rw [‚Üê c.uncontractedList_toFinset]
  simp

lemma uncontractedList_succAboveEmb_eq_sort(c : ContractionsNat n) (i : Fin n.succ) :
    (List.map i.succAboveEmb c.uncontractedList) =
    (c.uncontracted.map i.succAboveEmb).sort (¬∑ ‚â§ ¬∑)  := by
  rw [‚Üê uncontractedList_succAboveEmb_toFinset]
  symm
  refine (List.toFinset_sort (Œ± := Fin n.succ) (¬∑ ‚â§ ¬∑) ?_).mpr ?_
  ¬∑ exact uncontractedList_succAboveEmb_nodup c i
  ¬∑ exact uncontractedList_succAboveEmb_sorted c i

lemma uncontractedList_succAboveEmb_eraseIdx_sorted (c : ContractionsNat n) (i : Fin n.succ) (k: ‚Ñï) :
    ((List.map i.succAboveEmb c.uncontractedList).eraseIdx k).Sorted (¬∑ ‚â§ ¬∑) := by
  apply HepLean.List.eraseIdx_sorted
  exact uncontractedList_succAboveEmb_sorted c i

lemma uncontractedList_succAboveEmb_eraseIdx_nodup (c : ContractionsNat n) (i : Fin n.succ) (k: ‚Ñï) :
    ((List.map i.succAboveEmb c.uncontractedList).eraseIdx k).Nodup := by
  refine List.Nodup.eraseIdx k ?_
  exact uncontractedList_succAboveEmb_nodup c i

lemma uncontractedList_succAboveEmb_eraseIdx_toFinset (c : ContractionsNat n) (i : Fin n.succ) (k : ‚Ñï)
      (hk : k < c.uncontractedList.length) :
    ((List.map i.succAboveEmb c.uncontractedList).eraseIdx k).toFinset =
    (c.uncontracted.map i.succAboveEmb).erase (i.succAboveEmb c.uncontractedList[k]) := by
  ext a
  simp
  rw [mem_eraseIdx_nodup _ _ _ (by simpa using hk)]
  simp_all only [List.mem_map, List.getElem_map, ne_eq]
  apply Iff.intro
  ¬∑ intro a_1
    simp_all only [not_false_eq_true, true_and]
    obtain ‚ü®left, right‚ü© := a_1
    obtain ‚ü®w, h‚ü© := left
    obtain ‚ü®left, right_1‚ü© := h
    subst right_1
    use w
    simp_all [uncontractedList]
  ¬∑ intro a_1
    simp_all only [not_false_eq_true, and_true]
    obtain ‚ü®left, right‚ü© := a_1
    obtain ‚ü®w, h‚ü© := right
    obtain ‚ü®left_1, right‚ü© := h
    subst right
    use w
    simp_all [uncontractedList]
  exact uncontractedList_succAboveEmb_nodup c i

lemma uncontractedList_succAboveEmb_eraseIdx_eq_sort (c : ContractionsNat n) (i : Fin n.succ) (k : ‚Ñï)
      (hk : k < c.uncontractedList.length) :
    ((List.map i.succAboveEmb c.uncontractedList).eraseIdx k) =
    ((c.uncontracted.map i.succAboveEmb).erase (i.succAboveEmb c.uncontractedList[k])).sort (¬∑ ‚â§ ¬∑) := by
  rw [‚Üê uncontractedList_succAboveEmb_eraseIdx_toFinset]
  symm
  refine (List.toFinset_sort (Œ± := Fin n.succ) (¬∑ ‚â§ ¬∑) ?_).mpr ?_
  ¬∑ exact uncontractedList_succAboveEmb_eraseIdx_nodup c i k
  ¬∑ exact uncontractedList_succAboveEmb_eraseIdx_sorted c i k

lemma uncontractedList_succAbove_orderedInsert_sorted (c : ContractionsNat n) (i : Fin n.succ) :
    (List.orderedInsert (¬∑ ‚â§ ¬∑) i (List.map i.succAboveEmb c.uncontractedList)).Sorted (¬∑ ‚â§ ¬∑) := by
  refine List.Sorted.orderedInsert i (List.map (‚áëi.succAboveEmb) c.uncontractedList) ?_
  exact uncontractedList_succAboveEmb_sorted c i

lemma uncontractedList_succAbove_orderedInsert_nodup (c : ContractionsNat n) (i : Fin n.succ) :
    (List.orderedInsert (¬∑ ‚â§ ¬∑) i (List.map i.succAboveEmb c.uncontractedList)).Nodup := by
  have h1 : (List.orderedInsert (¬∑ ‚â§ ¬∑) i (List.map i.succAboveEmb c.uncontractedList)).Perm
    (i :: List.map i.succAboveEmb c.uncontractedList) := by
    exact List.perm_orderedInsert (fun x1 x2 => x1 ‚â§ x2) i _
  apply List.Perm.nodup h1.symm
  simp only [Nat.succ_eq_add_one, List.nodup_cons, List.mem_map, not_exists,
    not_and]
  apply And.intro
  ¬∑ intro x _
    exact Fin.succAbove_ne i x
  ¬∑ exact uncontractedList_succAboveEmb_nodup c i

lemma uncontractedList_succAbove_orderedInsert_toFinset (c : ContractionsNat n) (i : Fin n.succ) :
    (List.orderedInsert (¬∑ ‚â§ ¬∑) i (List.map i.succAboveEmb c.uncontractedList)).toFinset =
    (Insert.insert i (Finset.map i.succAboveEmb c.uncontracted)) := by
  ext a
  simp
  rw [‚Üê uncontractedList_toFinset]
  simp

lemma uncontractedList_succAbove_orderedInsert_eq_sort (c : ContractionsNat n) (i : Fin n.succ) :
    (List.orderedInsert (¬∑ ‚â§ ¬∑) i (List.map i.succAboveEmb c.uncontractedList)) =
    (Insert.insert i (Finset.map i.succAboveEmb c.uncontracted)).sort (¬∑ ‚â§ ¬∑) := by
  rw [‚Üê uncontractedList_succAbove_orderedInsert_toFinset]
  symm
  refine (List.toFinset_sort (Œ± := Fin n.succ) (¬∑ ‚â§ ¬∑) ?_).mpr ?_
  ¬∑ exact uncontractedList_succAbove_orderedInsert_nodup c i
  ¬∑ exact uncontractedList_succAbove_orderedInsert_sorted c i

lemma uncontractedList_extractEquiv_symm_none (c : ContractionsNat n) (i : Fin n.succ) :
    ((extractEquiv i).symm ‚ü®c, none‚ü©).uncontractedList =
    List.orderedInsert (¬∑ ‚â§ ¬∑) i (List.map i.succAboveEmb c.uncontractedList) := by
  rw [uncontractedList_eq_sort, extractEquiv_symm_none_uncontracted]
  rw [uncontractedList_succAbove_orderedInsert_eq_sort]




lemma fin_list_sorted_split  :
    (l : List (Fin n)) ‚Üí (hl : l.Sorted (¬∑ ‚â§ ¬∑))  ‚Üí  (i : ‚Ñï) ‚Üí
    l = l.filter (fun x => x.1 < i) ++ l.filter (fun x => i ‚â§ x.1)
  | [], _, _ => by simp
  | a :: l, hl, i => by
    simp at hl
    by_cases ha : a < i
    ¬∑ conv_lhs => rw [fin_list_sorted_split l hl.2 i]
      rw [‚Üê List.cons_append]
      rw [List.filter_cons_of_pos, List.filter_cons_of_neg]
      simp [ha]
      simp [ha]
    ¬∑ have hx :  List.filter (fun x => decide (x.1 < i)) (a :: l) = [] := by
        simp [ha]
        intro b hb
        have hb' := hl.1 b hb
        omega
      simp [hx]
      rw [List.filter_cons_of_pos]
      simp
      have hl' := fin_list_sorted_split l hl.2 i
      have hx :  List.filter (fun x => decide (x.1 < i)) (l) = [] := by
        simp [ha]
        intro b hb
        have hb' := hl.1 b hb
        omega
      simp [hx] at hl'
      conv_lhs => rw [hl']
      simp [ha]
      omega

lemma orderedInsert_of_fin_list_sorted  :
    (l : List (Fin n)) ‚Üí (hl : l.Sorted (¬∑ ‚â§ ¬∑))  ‚Üí  (i : Fin n) ‚Üí
    List.orderedInsert (¬∑ ‚â§ ¬∑) i l = l.filter (fun x => x.1 < i.1) ++ i :: l.filter (fun x => i.1 ‚â§ x.1)
  | [], _, _ => by simp
  | a :: l, hl, i => by
    simp at hl
    by_cases ha : i ‚â§ a
    ¬∑ simp [ha]
      have h1 : List.filter (fun x => decide (‚Üëx < ‚Üëi)) l  = [] := by
        simp
        intro a ha
        have ha' := hl.1 a ha
        omega
      have hl : l = List.filter (fun x => decide (i ‚â§ x)) l := by
        conv_lhs => rw [fin_list_sorted_split l hl.2 i]
        simp [h1]
      simp [‚Üê hl, h1]
    ¬∑ simp [ha]
      rw [List.filter_cons_of_pos]
      rw [orderedInsert_of_fin_list_sorted l hl.2 i]
      simp
      simp
      omega

lemma orderedInsert_eq_insertIdx_of_fin_list_sorted  :  (l : List (Fin n)) ‚Üí (hl : l.Sorted (¬∑ ‚â§ ¬∑))  ‚Üí  (i : Fin n) ‚Üí
    List.orderedInsert (¬∑ ‚â§ ¬∑) i l = l.insertIdx (l.filter (fun x => x.1 < i.1)).length i := by
  intro l hl i
  let n : Fin l.length.succ := ‚ü®(List.filter (fun x => decide (x < i)) l).length, by
    have h1 := l.length_filter_le (fun x => x.1 < i.1)
    simp at h1
    omega‚ü©
  simp
  conv_rhs => rw [insertIdx_eq_take_drop _ _ n]
  rw [orderedInsert_of_fin_list_sorted]
  congr
  ¬∑ conv_rhs =>
      rhs
      rw [fin_list_sorted_split l  hl i]
    simp [n]
  ¬∑ conv_rhs =>
      rhs
      rw [fin_list_sorted_split l  hl i]
    simp [n]
  exact hl


def uncontractedListOrderPos (c : ContractionsNat n)  (i : Fin n.succ) : ‚Ñï :=
  (List.filter (fun x => x.1 < i.1) c.uncontractedList).length

@[simp]
lemma uncontractedListOrderPos_lt_length_add_one (c : ContractionsNat n) (i : Fin n.succ) :
    c.uncontractedListOrderPos i < c.uncontractedList.length + 1 := by
  simp [uncontractedListOrderPos]
  have h1 := c.uncontractedList.length_filter_le (fun x => x.1 < i.1)
  omega

lemma take_uncontractedListOrderPos_eq_filter (c : ContractionsNat n) (i : Fin n.succ) :
    (c.uncontractedList.take (c.uncontractedListOrderPos i)) =
    c.uncontractedList.filter (fun x => x.1 < i.1) := by
  nth_rewrite 1 [fin_list_sorted_split c.uncontractedList _ i]
  simp [uncontractedListOrderPos]
  exact uncontractedList_sorted c


lemma take_uncontractedListOrderPos_eq_filter_sort (c : ContractionsNat n) (i : Fin n.succ) :
    (c.uncontractedList.take (c.uncontractedListOrderPos i)) =
    (c.uncontracted.filter (fun x => x.1 < i.1)).sort (¬∑ ‚â§ ¬∑) := by
  rw [take_uncontractedListOrderPos_eq_filter]
  have h1 : (c.uncontractedList.filter (fun x => x.1 < i.1)).Sorted (¬∑ ‚â§ ¬∑) := by
    apply List.Sorted.filter
    exact uncontractedList_sorted c
  have h2 : (c.uncontractedList.filter (fun x => x.1 < i.1)).Nodup := by
    refine List.Nodup.filter _ ?_
    exact uncontractedList_nodup c
  have h3 : (c.uncontractedList.filter (fun x => x.1 < i.1)).toFinset =
    (c.uncontracted.filter (fun x => x.1 < i.1)) := by
    rw [uncontractedList_eq_sort]
    simp
  rw [‚Üê h3]
  exact ((List.toFinset_sort (Œ± := Fin n) (¬∑ ‚â§ ¬∑) h2).mpr h1).symm

lemma orderedInsert_succAboveEmb_uncontractedList_eq_insertIdx (c : ContractionsNat n) (i : Fin n.succ) :
    (List.orderedInsert (¬∑ ‚â§ ¬∑) i (List.map i.succAboveEmb c.uncontractedList)) =
    (List.map i.succAboveEmb c.uncontractedList).insertIdx (uncontractedListOrderPos c i) i := by
  rw [orderedInsert_eq_insertIdx_of_fin_list_sorted]
  swap
  exact uncontractedList_succAboveEmb_sorted c i
  congr 1
  simp [uncontractedListOrderPos]
  rw [List.filter_map]
  simp
  congr
  funext x
  simp [Fin.succAbove]
  split
  simp [Fin.lt_def]
  rename_i h
  simp_all [Fin.lt_def]
  omega

def uncontractedFinEquiv (c : ContractionsNat n) :
    Fin (c.uncontractedList).length ‚âÉ c.uncontracted where
  toFun i := ‚ü®c.uncontractedList.get i, c.uncontractedList_get_mem_uncontracted i‚ü©
  invFun i := ‚ü®List.indexOf i.1 c.uncontractedList,
    List.indexOf_lt_length.mpr ((c.uncontractedList_mem_iff i.1).mpr i.2)‚ü©
  left_inv i := by
    ext
    exact List.get_indexOf (uncontractedList_nodup c) _
  right_inv i := by
    ext
    simp

@[simp]
lemma uncontractedList_getElem_uncontractedFinEquiv_symm (k : c.uncontracted) :
    c.uncontractedList[(c.uncontractedFinEquiv.symm k).val] = k := by
  simp [uncontractedFinEquiv]

def uncontractedStatesEquiv (œÜs : List ùìï.States) (c : ContractionsNat œÜs.length) :
   Option c.uncontracted ‚âÉ Option (Fin (c.uncontractedList.map œÜs.get).length):=
  Equiv.optionCongr (c.uncontractedFinEquiv.symm.trans (finCongr (by simp)))

@[simp]
lemma uncontractedStatesEquiv_none (œÜs : List ùìï.States) (c : ContractionsNat œÜs.length) :
    (uncontractedStatesEquiv œÜs c).toFun none = none := by
  simp [uncontractedStatesEquiv]

lemma uncontractedStatesEquiv_list_sum [AddCommMonoid Œ±] (œÜs : List ùìï.States)
  (c : ContractionsNat œÜs.length) (f : Option (Fin (c.uncontractedList.map œÜs.get).length) ‚Üí Œ±) :
    ‚àë (i : Option (Fin (c.uncontractedList.map œÜs.get).length)), f i =
    ‚àë (i : Option c.uncontracted), f (c.uncontractedStatesEquiv œÜs i) := by
  rw [(c.uncontractedStatesEquiv œÜs).sum_comp]

lemma uncontractedStatesEquiv_take (œÜs : List ùìï.States) (c : ContractionsNat œÜs.length) (i : ‚Ñï) :
    (c.uncontractedList.map œÜs.val) (c.uncontractedStatesEquiv œÜs ) =
    some (Fin.cast (List.length_map œÜs.get) (c.uncontractedList.take i).length) := by
  sorry

lemma uncontractedList_extractEquiv_symm_some (c : ContractionsNat n) (i : Fin n.succ)
  (k : c.uncontracted) :
    ((extractEquiv i).symm ‚ü®c, some k‚ü©).uncontractedList =
   ((c.uncontractedList).map i.succAboveEmb).eraseIdx (c.uncontractedFinEquiv.symm k) := by
  rw [uncontractedList_eq_sort]
  rw [uncontractedList_succAboveEmb_eraseIdx_eq_sort]
  swap
  simp
  congr
  simp [extractEquiv]
  rw [insert_some_uncontracted]
  ext a
  simp


end ContractionsNat

end FieldStruct
