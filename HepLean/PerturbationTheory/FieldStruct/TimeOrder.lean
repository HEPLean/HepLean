/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.FieldStruct.StateAlgebra
import HepLean.PerturbationTheory.Wick.Signs.KoszulSign
/-!

# State algebra

We define the state algebra of a field structure to be the free algebra
generated by the states.

-/

namespace FieldStruct
variable {𝓕 : FieldStruct}

/-- Returns true if `timeOrder a b` is true if `a` has time greater then or equal to `b`.
  This will put the stats at the greatest time to left. -/
def timeOrderProp : 𝓕.States → 𝓕.States → Prop
  | States.posAsymp _, _ => True
  | States.position φ0, States.position φ1 => φ1.2 0 ≤ φ0.2 0
  | States.position _, States.negAsymp _ => True
  | States.position _, States.posAsymp _ => False
  | States.negAsymp _, States.posAsymp _ => False
  | States.negAsymp _, States.position _ => False
  | States.negAsymp _, States.negAsymp _ => True

noncomputable instance :  (φ φ' : 𝓕.States) → Decidable (timeOrderProp φ φ')
  | States.posAsymp _, _ => isTrue True.intro
  | States.position φ0, States.position φ1 => inferInstanceAs (Decidable (φ1.2 0 ≤ φ0.2 0))
  | States.position _, States.negAsymp _ => isTrue True.intro
  | States.position _, States.posAsymp _ => isFalse (fun a => a)
  | States.negAsymp _, States.posAsymp _ => isFalse (fun a => a)
  | States.negAsymp _, States.position _ => isFalse (fun a => a)
  | States.negAsymp _, States.negAsymp _ => isTrue True.intro


/-- Time ordering is total. -/
instance : IsTotal 𝓕.States 𝓕.timeOrderProp where
  total a b := by
    cases a <;> cases b <;> simp [timeOrderProp]
    exact LinearOrder.le_total _ _

/-- Time ordering is transitive. -/
instance : IsTrans 𝓕.States 𝓕.timeOrderProp where
  trans a b c := by
    cases a <;> cases b <;> cases c <;> simp [timeOrderProp]
    exact fun h1 h2 => Preorder.le_trans _ _ _ h2 h1

noncomputable section

def timeOrderSign (φs : List 𝓕.States) : ℂ :=
  Wick.koszulSign 𝓕.statesStatistic 𝓕.timeOrderProp φs

def timeOrderList (φs : List 𝓕.States) : List 𝓕.States :=
  List.insertionSort 𝓕.timeOrderProp φs

@[simp]
lemma timeOrderList_nil : timeOrderList (𝓕 := 𝓕) [] = [] := by
  simp [timeOrderList]

namespace StateAlgebra

def timeOrder : StateAlgebra 𝓕 →ₗ[ℂ] StateAlgebra 𝓕  :=
  Basis.constr ofListBasis ℂ fun φs =>
  timeOrderSign φs • ofList (timeOrderList φs)

lemma timeOrder_ofList (φs : List 𝓕.States) :
    timeOrder (ofList φs) = timeOrderSign φs • ofList (timeOrderList φs) := by
  rw [← ofListBasis_eq_ofList]
  simp only [timeOrder, Basis.constr_basis]

@[simp]
lemma timeOrder_ofList_nil : timeOrder (𝓕 := 𝓕) (ofList []) = 1 := by
  rw [timeOrder_ofList]
  simp [timeOrderSign, Wick.koszulSign, timeOrderList]

@[simp]
lemma timeOrder_ofList_singleton (φ : 𝓕.States) : timeOrder (ofList [φ]) = ofList [φ] := by
  rw [timeOrder_ofList]
  simp [timeOrderSign, timeOrderList]

end StateAlgebra
end
end FieldStruct
