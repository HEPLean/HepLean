/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.Mathematics.List.InsertionSort
import HepLean.PerturbationTheory.FieldStruct.StateAlgebra
import HepLean.PerturbationTheory.Wick.Signs.KoszulSign
/-!

# State algebra

We define the state algebra of a field structure to be the free algebra
generated by the states.

-/

namespace FieldStruct
variable {ğ“• : FieldStruct}

/-- Returns true if `timeOrder a b` is true if `a` has time greater then or equal to `b`.
  This will put the stats at the greatest time to left. -/
def timeOrderProp : ğ“•.States â†’ ğ“•.States â†’ Prop
  | States.posAsymp _, _ => True
  | States.position Ï†0, States.position Ï†1 => Ï†1.2 0 â‰¤ Ï†0.2 0
  | States.position _, States.negAsymp _ => True
  | States.position _, States.posAsymp _ => False
  | States.negAsymp _, States.posAsymp _ => False
  | States.negAsymp _, States.position _ => False
  | States.negAsymp _, States.negAsymp _ => True

noncomputable instance :  (Ï† Ï†' : ğ“•.States) â†’ Decidable (timeOrderProp Ï† Ï†')
  | States.posAsymp _, _ => isTrue True.intro
  | States.position Ï†0, States.position Ï†1 => inferInstanceAs (Decidable (Ï†1.2 0 â‰¤ Ï†0.2 0))
  | States.position _, States.negAsymp _ => isTrue True.intro
  | States.position _, States.posAsymp _ => isFalse (fun a => a)
  | States.negAsymp _, States.posAsymp _ => isFalse (fun a => a)
  | States.negAsymp _, States.position _ => isFalse (fun a => a)
  | States.negAsymp _, States.negAsymp _ => isTrue True.intro

/-- Time ordering is total. -/
instance : IsTotal ğ“•.States ğ“•.timeOrderProp where
  total a b := by
    cases a <;> cases b <;> simp [timeOrderProp]
    exact LinearOrder.le_total _ _

/-- Time ordering is transitive. -/
instance : IsTrans ğ“•.States ğ“•.timeOrderProp where
  trans a b c := by
    cases a <;> cases b <;> cases c <;> simp [timeOrderProp]
    exact fun h1 h2 => Preorder.le_trans _ _ _ h2 h1

noncomputable section

open FieldStatistic
open HepLean.List

def maxTimeFieldPos (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) : â„• :=
  insertionSortMinPos timeOrderProp Ï† Ï†s

lemma maxTimeFieldPos_lt_length (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) :
    maxTimeFieldPos Ï† Ï†s < (Ï† :: Ï†s).length := by
  simp [maxTimeFieldPos]

def maxTimeField (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) : ğ“•.States :=
  insertionSortMin timeOrderProp Ï† Ï†s

def eraseMaxTimeField (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) : List ğ“•.States :=
  insertionSortDropMinPos timeOrderProp Ï† Ï†s

@[simp]
lemma eraseMaxTimeField_length (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) :
    (eraseMaxTimeField Ï† Ï†s).length = Ï†s.length := by
  simp [eraseMaxTimeField, insertionSortDropMinPos, eraseIdx_length']

lemma maxTimeFieldPos_lt_eraseMaxTimeField_length_succ (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) :
    maxTimeFieldPos Ï† Ï†s < (eraseMaxTimeField Ï† Ï†s).length.succ := by
  simp
  exact maxTimeFieldPos_lt_length Ï† Ï†s


def maxTimeFieldPosFin (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) :
    Fin (eraseMaxTimeField Ï† Ï†s).length.succ :=
  insertionSortMinPosFin timeOrderProp Ï† Ï†s

lemma lt_maxTimeFieldPosFin_not_timeOrder (Ï† : ğ“•.States) (Ï†s : List ğ“•.States)
    (i : Fin (eraseMaxTimeField Ï† Ï†s).length) (hi : (maxTimeFieldPosFin Ï† Ï†s).succAbove i <
     maxTimeFieldPosFin Ï† Ï†s) :
    Â¬ timeOrderProp  ((eraseMaxTimeField Ï† Ï†s)[i.val]) (maxTimeField Ï† Ï†s) := by
  exact insertionSortMin_lt_mem_insertionSortDropMinPos_of_lt timeOrderProp Ï† Ï†s i hi

lemma timeOrder_maxTimeField (Ï† : ğ“•.States) (Ï†s : List ğ“•.States)
    (i : Fin (eraseMaxTimeField Ï† Ï†s).length)  :
    timeOrderProp (maxTimeField Ï† Ï†s) ((eraseMaxTimeField Ï† Ï†s)[i.val])  := by
  exact insertionSortMin_lt_mem_insertionSortDropMinPos timeOrderProp Ï† Ï†s _

def timeOrderSign (Ï†s : List ğ“•.States) : â„‚ :=
  Wick.koszulSign ğ“•.statesStatistic ğ“•.timeOrderProp Ï†s

lemma timeOrderSign_pair_ordered {Ï† Ïˆ : ğ“•.States} (h : timeOrderProp Ï† Ïˆ):
    timeOrderSign [Ï†, Ïˆ] = 1 := by
  simp [timeOrderSign, Wick.koszulSign, Wick.koszulSignInsert]
  exact fun h' => False.elim (h' h)

lemma timeOrderSign_pair_not_ordered {Ï† Ïˆ : ğ“•.States} (h : Â¬ timeOrderProp Ï† Ïˆ):
    timeOrderSign [Ï†, Ïˆ] = ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› Ïˆ) := by
  simp [timeOrderSign, Wick.koszulSign, Wick.koszulSignInsert]
  rw [if_neg h]
  simp [FieldStatistic.pairedSign_eq_if]

lemma timerOrderSign_of_eraseMaxTimeField (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) :
    timeOrderSign (eraseMaxTimeField Ï† Ï†s) = timeOrderSign (Ï† :: Ï†s) *
    ğ“¢(ğ“• |>â‚› maxTimeField Ï† Ï†s, ğ“• |>â‚› (Ï† :: Ï†s).take (maxTimeFieldPos Ï† Ï†s)) := by
  rw [eraseMaxTimeField, insertionSortDropMinPos, timeOrderSign,
    Wick.koszulSign_eraseIdx_insertionSortMinPos]
  rw [â† timeOrderSign, â† maxTimeField]
  rfl

def timeOrderList (Ï†s : List ğ“•.States) : List ğ“•.States :=
  List.insertionSort ğ“•.timeOrderProp Ï†s

lemma timeOrderList_pair_ordered {Ï† Ïˆ : ğ“•.States} (h : timeOrderProp Ï† Ïˆ):
    timeOrderList [Ï†, Ïˆ] = [Ï†, Ïˆ] := by
  simp [timeOrderList]
  exact fun h' => False.elim (h' h)

lemma timeOrderList_pair_not_ordered {Ï† Ïˆ : ğ“•.States} (h : Â¬ timeOrderProp Ï† Ïˆ):
    timeOrderList [Ï†, Ïˆ] = [Ïˆ, Ï†] := by
  simp [timeOrderList]
  exact fun h' => False.elim (h h')

@[simp]
lemma timeOrderList_nil : timeOrderList (ğ“• := ğ“•) [] = [] := by
  simp [timeOrderList]


lemma timeOrderList_eq_maxTimeField_timeOrderList  (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) :
    timeOrderList (Ï† :: Ï†s) = maxTimeField Ï† Ï†s :: timeOrderList (eraseMaxTimeField Ï† Ï†s) := by
  exact insertionSort_eq_insertionSortMin_cons timeOrderProp Ï† Ï†s

namespace StateAlgebra

def timeOrder : StateAlgebra ğ“• â†’â‚—[â„‚] StateAlgebra ğ“•  :=
  Basis.constr ofListBasis â„‚ fun Ï†s =>
  timeOrderSign Ï†s â€¢ ofList (timeOrderList Ï†s)

lemma timeOrder_ofList (Ï†s : List ğ“•.States) :
    timeOrder (ofList Ï†s) = timeOrderSign Ï†s â€¢ ofList (timeOrderList Ï†s) := by
  rw [â† ofListBasis_eq_ofList]
  simp only [timeOrder, Basis.constr_basis]

@[simp]
lemma timeOrder_ofList_nil : timeOrder (ğ“• := ğ“•) (ofList []) = 1 := by
  rw [timeOrder_ofList]
  simp [timeOrderSign, Wick.koszulSign, timeOrderList]

@[simp]
lemma timeOrder_ofList_singleton (Ï† : ğ“•.States) : timeOrder (ofList [Ï†]) = ofList [Ï†] := by
  rw [timeOrder_ofList]
  simp [timeOrderSign, timeOrderList]

lemma timeOrder_ofState_ofState_ordered {Ï† Ïˆ : ğ“•.States} (h : timeOrderProp Ï† Ïˆ) :
    timeOrder (ofState Ï† * ofState Ïˆ) = ofState Ï† * ofState Ïˆ := by
  rw [â† ofList_singleton, â† ofList_singleton, â† ofList_append]
  rw [timeOrder_ofList]
  simp
  rw [timeOrderSign_pair_ordered h, timeOrderList_pair_ordered h]
  simp

lemma timeOrder_ofState_ofState_not_ordered {Ï† Ïˆ : ğ“•.States} (h :Â¬ timeOrderProp Ï† Ïˆ) :
    timeOrder (ofState Ï† * ofState Ïˆ) =
    ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› Ïˆ) â€¢ ofState Ïˆ * ofState Ï† := by
  rw [â† ofList_singleton, â† ofList_singleton, â† ofList_append]
  rw [timeOrder_ofList]
  simp
  rw [timeOrderSign_pair_not_ordered h, timeOrderList_pair_not_ordered h]
  simp [â† ofList_append]

lemma timeOrder_ofState_ofState_not_ordered_eq_timeOrder {Ï† Ïˆ : ğ“•.States} (h :Â¬ timeOrderProp Ï† Ïˆ) :
    timeOrder (ofState Ï† * ofState Ïˆ) =
    ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› Ïˆ) â€¢ timeOrder (ofState Ïˆ * ofState Ï†) := by
  rw [timeOrder_ofState_ofState_not_ordered h]
  rw [timeOrder_ofState_ofState_ordered]
  simp
  have hx := IsTotal.total (r := timeOrderProp) Ïˆ Ï†
  simp_all

lemma timeOrder_eq_maxTimeField_mul (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) :
    timeOrder (ofList (Ï† :: Ï†s)) =
    ğ“¢(ğ“• |>â‚› maxTimeField Ï† Ï†s, ğ“• |>â‚› (Ï† :: Ï†s).take (maxTimeFieldPos Ï† Ï†s)) â€¢
    ofState (maxTimeField Ï† Ï†s) * timeOrder (ofList (eraseMaxTimeField Ï† Ï†s)) := by
  rw [timeOrder_ofList, timeOrderList_eq_maxTimeField_timeOrderList]
  rw [ofList_cons, timeOrder_ofList]
  simp [smul_smul]
  congr
  rw [timerOrderSign_of_eraseMaxTimeField, mul_assoc]
  simp



end StateAlgebra
end
end FieldStruct
