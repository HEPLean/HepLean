/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.FieldSpecification.CrAnStates
import HepLean.PerturbationTheory.FieldSpecification.CrAnSection
/-!

# Creation and annihlation free-algebra

This module defines the creation and annihilation algebra for a field structure.

The creation and annihilation algebra extends from the state algebra by adding information about
whether a state is a creation or annihilation operator.

The algebra is spanned by lists of creation/annihilation states.

The main structures defined in this module are:

* `FieldOpFreeAlgebra` - The creation and annihilation algebra
* `ofCrAnState` - Maps a creation/annihilation state to the algebra
* `ofCrAnList` - Maps a list of creation/annihilation states to the algebra
* `ofState` - Maps a state to a sum of creation and annihilation operators
* `crPartF` - The creation part of a state in the algebra
* `anPartF` - The annihilation part of a state in the algebra
* `superCommuteF` - The super commutator on the algebra

The key lemmas show how these operators interact, particularly focusing on the
super commutation relations between creation and annihilation operators.

-/

namespace FieldSpecification
variable {ğ“• : FieldSpecification}

/-- The creation and annihlation free-algebra.
  The free algebra generated by `CrAnStates`,
  that is a position based states or assymptotic states with a specification of
  whether the state is a creation or annihlation state.
  As a module `FieldOpFreeAlgebra` is spanned by lists of `CrAnStates`. -/
abbrev FieldOpFreeAlgebra (ğ“• : FieldSpecification) : Type := FreeAlgebra â„‚ ğ“•.CrAnStates

namespace FieldOpFreeAlgebra

/-- Maps a creation and annihlation state to the creation and annihlation free-algebra. -/
def ofCrAnState (Ï† : ğ“•.CrAnStates) : FieldOpFreeAlgebra ğ“• :=
  FreeAlgebra.Î¹ â„‚ Ï†

/-- Maps a list creation and annihlation state to the creation and annihlation free-algebra
  by taking their product. -/
def ofCrAnList (Ï†s : List ğ“•.CrAnStates) : FieldOpFreeAlgebra ğ“• := (List.map ofCrAnState Ï†s).prod

@[simp]
lemma ofCrAnList_nil : ofCrAnList ([] : List ğ“•.CrAnStates) = 1 := rfl

lemma ofCrAnList_cons (Ï† : ğ“•.CrAnStates) (Ï†s : List ğ“•.CrAnStates) :
    ofCrAnList (Ï† :: Ï†s) = ofCrAnState Ï† * ofCrAnList Ï†s := rfl

lemma ofCrAnList_append (Ï†s Ï†s' : List ğ“•.CrAnStates) :
    ofCrAnList (Ï†s ++ Ï†s') = ofCrAnList Ï†s * ofCrAnList Ï†s' := by
  simp [ofCrAnList, List.map_append]

lemma ofCrAnList_singleton (Ï† : ğ“•.CrAnStates) :
    ofCrAnList [Ï†] = ofCrAnState Ï† := by simp [ofCrAnList]

/-- Maps a state to the sum of creation and annihilation operators in
  creation and annihilation free-algebra. -/
def ofState (Ï† : ğ“•.States) : FieldOpFreeAlgebra ğ“• :=
  âˆ‘ (i : ğ“•.statesToCrAnType Ï†), ofCrAnState âŸ¨Ï†, iâŸ©

/-- Maps a list of states to the creation and annihilation free-algebra by taking
  the product of their sums of creation and annihlation operators.
  Roughly `[Ï†1, Ï†2]` gets sent to `(Ï†1á¶œ+ Ï†1áµƒ) * (Ï†2á¶œ+ Ï†2áµƒ)` etc. -/
def ofStateList (Ï†s : List ğ“•.States) : FieldOpFreeAlgebra ğ“• := (List.map ofState Ï†s).prod

/-- Coercion from `List ğ“•.States` to `FieldOpFreeAlgebra ğ“•` through `ofStateList`. -/
instance : Coe (List ğ“•.States) (FieldOpFreeAlgebra ğ“•) := âŸ¨ofStateListâŸ©

@[simp]
lemma ofStateList_nil : ofStateList ([] : List ğ“•.States) = 1 := rfl

lemma ofStateList_cons (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) :
    ofStateList (Ï† :: Ï†s) = ofState Ï† * ofStateList Ï†s := rfl

lemma ofStateList_singleton (Ï† : ğ“•.States) :
    ofStateList [Ï†] = ofState Ï† := by simp [ofStateList]

lemma ofStateList_append (Ï†s Ï†s' : List ğ“•.States) :
    ofStateList (Ï†s ++ Ï†s') = ofStateList Ï†s * ofStateList Ï†s' := by
  dsimp only [ofStateList]
  rw [List.map_append, List.prod_append]

lemma ofStateList_sum (Ï†s : List ğ“•.States) :
    ofStateList Ï†s = âˆ‘ (s : CrAnSection Ï†s), ofCrAnList s.1 := by
  induction Ï†s with
  | nil => simp
  | cons Ï† Ï†s ih =>
    rw [CrAnSection.sum_cons]
    dsimp only [CrAnSection.cons, ofCrAnList_cons]
    conv_rhs =>
      enter [2, x]
      rw [â† Finset.mul_sum]
    rw [â† Finset.sum_mul, ofStateList_cons, â† ih]
    rfl

/-!

## Creation and annihilation parts of a state

-/

/-- The algebra map taking an element of the free-state algbra to
  the part of it in the creation and annihlation free algebra
  spanned by creation operators. -/
def crPartF : ğ“•.States â†’ ğ“•.FieldOpFreeAlgebra := fun Ï† =>
  match Ï† with
  | States.inAsymp Ï† => ofCrAnState âŸ¨States.inAsymp Ï†, ()âŸ©
  | States.position Ï† => ofCrAnState âŸ¨States.position Ï†, CreateAnnihilate.createâŸ©
  | States.outAsymp _ => 0

@[simp]
lemma crPartF_negAsymp (Ï† : ğ“•.IncomingAsymptotic) :
    crPartF (States.inAsymp Ï†) = ofCrAnState âŸ¨States.inAsymp Ï†, ()âŸ© := by
  simp [crPartF]

@[simp]
lemma crPartF_position (Ï† : ğ“•.PositionStates) :
    crPartF (States.position Ï†) =
    ofCrAnState âŸ¨States.position Ï†, CreateAnnihilate.createâŸ© := by
  simp [crPartF]

@[simp]
lemma crPartF_posAsymp (Ï† : ğ“•.OutgoingAsymptotic) :
    crPartF (States.outAsymp Ï†) = 0 := by
  simp [crPartF]

/-- The algebra map taking an element of the free-state algbra to
  the part of it in the creation and annihilation free algebra
  spanned by annihilation operators. -/
def anPartF : ğ“•.States â†’ ğ“•.FieldOpFreeAlgebra := fun Ï† =>
  match Ï† with
  | States.inAsymp _ => 0
  | States.position Ï† => ofCrAnState âŸ¨States.position Ï†, CreateAnnihilate.annihilateâŸ©
  | States.outAsymp Ï† => ofCrAnState âŸ¨States.outAsymp Ï†, ()âŸ©

@[simp]
lemma anPartF_negAsymp (Ï† : ğ“•.IncomingAsymptotic) :
    anPartF (States.inAsymp Ï†) = 0 := by
  simp [anPartF]

@[simp]
lemma anPartF_position (Ï† : ğ“•.PositionStates) :
    anPartF (States.position Ï†) =
    ofCrAnState âŸ¨States.position Ï†, CreateAnnihilate.annihilateâŸ© := by
  simp [anPartF]

@[simp]
lemma anPartF_posAsymp (Ï† : ğ“•.OutgoingAsymptotic) :
    anPartF (States.outAsymp Ï†) = ofCrAnState âŸ¨States.outAsymp Ï†, ()âŸ© := by
  simp [anPartF]

lemma ofState_eq_crPartF_add_anPartF (Ï† : ğ“•.States) :
    ofState Ï† = crPartF Ï† + anPartF Ï† := by
  rw [ofState]
  cases Ï† with
  | inAsymp Ï† => simp [statesToCrAnType]
  | position Ï† => simp [statesToCrAnType, CreateAnnihilate.sum_eq]
  | outAsymp Ï† => simp [statesToCrAnType]

/-!

## The basis of the creation and annihlation free-algebra.

-/

/-- The basis of the free creation and annihilation algebra formed by lists of CrAnStates. -/
noncomputable def ofCrAnListBasis : Basis (List ğ“•.CrAnStates) â„‚ (FieldOpFreeAlgebra ğ“•) where
  repr := FreeAlgebra.equivMonoidAlgebraFreeMonoid.toLinearEquiv

@[simp]
lemma ofListBasis_eq_ofList (Ï†s : List ğ“•.CrAnStates) :
    ofCrAnListBasis Ï†s = ofCrAnList Ï†s := by
  simp only [ofCrAnListBasis, FreeAlgebra.equivMonoidAlgebraFreeMonoid, MonoidAlgebra.of_apply,
    Basis.coe_ofRepr, AlgEquiv.toLinearEquiv_symm, AlgEquiv.toLinearEquiv_apply,
    AlgEquiv.ofAlgHom_symm_apply, ofCrAnList]
  erw [MonoidAlgebra.lift_apply]
  simp only [zero_smul, Finsupp.sum_single_index, one_smul]
  rw [@FreeMonoid.lift_apply]
  match Ï†s with
  | [] => rfl
  | Ï† :: Ï†s => erw [List.map_cons]

/-!

## Some useful multi-linear maps.

-/

/-- The bi-linear map associated with multiplication in `FieldOpFreeAlgebra`. -/
noncomputable def mulLinearMap : FieldOpFreeAlgebra ğ“• â†’â‚—[â„‚] FieldOpFreeAlgebra ğ“• â†’â‚—[â„‚] FieldOpFreeAlgebra ğ“• where
  toFun a := {
    toFun := fun b => a * b,
    map_add' := fun c d => by simp [mul_add]
    map_smul' := by simp}
  map_add' := fun a b => by
    ext c
    simp [add_mul]
  map_smul' := by
    intros
    ext c
    simp [smul_mul']

lemma mulLinearMap_apply (a b : FieldOpFreeAlgebra ğ“•) :
    mulLinearMap a b = a * b := rfl

/-- The linear map associated with scalar-multiplication in `FieldOpFreeAlgebra`. -/
noncomputable def smulLinearMap (c : â„‚) : FieldOpFreeAlgebra ğ“• â†’â‚—[â„‚] FieldOpFreeAlgebra ğ“• where
  toFun a := c â€¢ a
  map_add' := by simp
  map_smul' m x := by simp [smul_smul, RingHom.id_apply, NonUnitalNormedCommRing.mul_comm]

end FieldOpFreeAlgebra

end FieldSpecification
