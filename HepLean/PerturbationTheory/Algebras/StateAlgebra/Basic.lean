/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.FieldSpecification.CreateAnnihilate
/-!

# State algebra

We define the state algebra of a field structure to be the free algebra
generated by the states.

-/

namespace FieldSpecification
variable {ğ“• : FieldSpecification}

/-- The state free-algebra.
  The free algebra generated by `States`,
  that is a position based states or assymptotic states.
  As a module `StateAlgebra` is spanned by lists of `States`. -/
abbrev StateAlgebra (ğ“• : FieldSpecification) : Type := FreeAlgebra â„‚ ğ“•.States

namespace StateAlgebra

open FieldStatistic

/-- The element of the states free-algebra generated by a single state. -/
def ofState (Ï† : ğ“•.States) : StateAlgebra ğ“• :=
  FreeAlgebra.Î¹ â„‚ Ï†

/-- The element of the states free-algebra generated by a list of states. -/
def ofList (Ï†s : List ğ“•.States) : StateAlgebra ğ“• :=
  (List.map ofState Ï†s).prod

@[simp]
lemma ofList_nil : ofList ([] : List ğ“•.States) = 1 := rfl

lemma ofList_singleton (Ï† : ğ“•.States) : ofList [Ï†] = ofState Ï† := by
  simp [ofList]

lemma ofList_append (Ï†s Ïˆs : List ğ“•.States) :
    ofList (Ï†s ++ Ïˆs) = ofList Ï†s * ofList Ïˆs := by
  rw [ofList, List.map_append, List.prod_append]
  rfl

lemma ofList_cons (Ï† : ğ“•.States) (Ï†s : List ğ“•.States) :
    ofList (Ï† :: Ï†s) = ofState Ï† * ofList Ï†s := rfl

/-- The basis of the free state algebra formed by lists of states. -/
noncomputable def ofListBasis : Basis (List ğ“•.States) â„‚ ğ“•.StateAlgebra where
  repr := FreeAlgebra.equivMonoidAlgebraFreeMonoid.toLinearEquiv

@[simp]
lemma ofListBasis_eq_ofList (Ï†s : List ğ“•.States) :
    ofListBasis Ï†s = ofList Ï†s := by
  simp only [ofListBasis, FreeAlgebra.equivMonoidAlgebraFreeMonoid, MonoidAlgebra.of_apply,
    Basis.coe_ofRepr, AlgEquiv.toLinearEquiv_symm, AlgEquiv.toLinearEquiv_apply,
    AlgEquiv.ofAlgHom_symm_apply, ofList]
  erw [MonoidAlgebra.lift_apply]
  simp only [zero_smul, Finsupp.sum_single_index, one_smul]
  rw [@FreeMonoid.lift_apply]
  simp only [List.prod]
  match Ï†s with
  | [] => rfl
  | Ï† :: Ï†s =>
    erw [List.map_cons]

/-!

## The super commutor on the state algebra.

-/

/-- The super commutor on the free state algebra. For two bosonic operators
  or a bosonic and fermionic operator this corresponds to the usual commutator
  whilst for two fermionic operators this corresponds to the anti-commutator. -/
noncomputable def superCommute : ğ“•.StateAlgebra â†’â‚—[â„‚] ğ“•.StateAlgebra â†’â‚—[â„‚] ğ“•.StateAlgebra :=
  Basis.constr ofListBasis â„‚ fun Ï†s =>
  Basis.constr ofListBasis â„‚ fun Ï†s' =>
  ofList (Ï†s ++ Ï†s') - ğ“¢(ğ“• |>â‚› Ï†s, ğ“• |>â‚› Ï†s') â€¢ ofList (Ï†s' ++ Ï†s)

local notation "âŸ¨" Ï†s "," Ï†s' "âŸ©â‚›" => superCommute Ï†s Ï†s'

lemma superCommute_ofList (Ï†s Ï†s' : List ğ“•.States) : âŸ¨ofList Ï†s, ofList Ï†s'âŸ©â‚› =
    ofList (Ï†s ++ Ï†s') - ğ“¢(ğ“• |>â‚› Ï†s, ğ“• |>â‚› Ï†s') â€¢ ofList (Ï†s' ++ Ï†s) := by
  rw [â† ofListBasis_eq_ofList, â† ofListBasis_eq_ofList]
  simp only [superCommute, Basis.constr_basis]

end StateAlgebra

end FieldSpecification
