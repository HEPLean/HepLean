/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.FieldStruct.TimeOrder
import HepLean.PerturbationTheory.Koszul.KoszulSign
/-!

# State algebra

We define the state algebra of a field structure to be the free algebra
generated by the states.

-/

namespace FieldStruct
variable {ð“• : FieldStruct}
noncomputable section

namespace StateAlgebra

open FieldStatistic

/-- The linear map on the free state algebra defined as the map taking
  a list of states to the time-ordered list of states multiplied by
  the sign corresponding to the number of fermionic-fermionic
  exchanges done in ordering. -/
def timeOrder : StateAlgebra ð“• â†’â‚—[â„‚] StateAlgebra ð“• :=
  Basis.constr ofListBasis â„‚ fun Ï†s =>
  timeOrderSign Ï†s â€¢ ofList (timeOrderList Ï†s)

lemma timeOrder_ofList (Ï†s : List ð“•.States) :
    timeOrder (ofList Ï†s) = timeOrderSign Ï†s â€¢ ofList (timeOrderList Ï†s) := by
  rw [â† ofListBasis_eq_ofList]
  simp only [timeOrder, Basis.constr_basis]

@[simp]
lemma timeOrder_ofList_nil : timeOrder (ð“• := ð“•) (ofList []) = 1 := by
  rw [timeOrder_ofList]
  simp [timeOrderSign, Wick.koszulSign, timeOrderList]

@[simp]
lemma timeOrder_ofList_singleton (Ï† : ð“•.States) : timeOrder (ofList [Ï†]) = ofList [Ï†] := by
  simp [timeOrder_ofList, timeOrderSign, timeOrderList]

lemma timeOrder_ofState_ofState_ordered {Ï† Ïˆ : ð“•.States} (h : timeOrderRel Ï† Ïˆ) :
    timeOrder (ofState Ï† * ofState Ïˆ) = ofState Ï† * ofState Ïˆ := by
  rw [â† ofList_singleton, â† ofList_singleton, â† ofList_append, timeOrder_ofList]
  simp only [List.singleton_append]
  rw [timeOrderSign_pair_ordered h, timeOrderList_pair_ordered h]
  simp

lemma timeOrder_ofState_ofState_not_ordered {Ï† Ïˆ : ð“•.States} (h :Â¬ timeOrderRel Ï† Ïˆ) :
    timeOrder (ofState Ï† * ofState Ïˆ) =
    ð“¢(ð“• |>â‚› Ï†, ð“• |>â‚› Ïˆ) â€¢ ofState Ïˆ * ofState Ï† := by
  rw [â† ofList_singleton, â† ofList_singleton, â† ofList_append, timeOrder_ofList]
  simp only [List.singleton_append, instCommGroup.eq_1, Algebra.smul_mul_assoc]
  rw [timeOrderSign_pair_not_ordered h, timeOrderList_pair_not_ordered h]
  simp [â† ofList_append]

lemma timeOrder_ofState_ofState_not_ordered_eq_timeOrder {Ï† Ïˆ : ð“•.States} (h :Â¬ timeOrderRel Ï† Ïˆ) :
    timeOrder (ofState Ï† * ofState Ïˆ) =
    ð“¢(ð“• |>â‚› Ï†, ð“• |>â‚› Ïˆ) â€¢ timeOrder (ofState Ïˆ * ofState Ï†) := by
  rw [timeOrder_ofState_ofState_not_ordered h]
  rw [timeOrder_ofState_ofState_ordered]
  simp only [instCommGroup.eq_1, Algebra.smul_mul_assoc]
  have hx := IsTotal.total (r := timeOrderRel) Ïˆ Ï†
  simp_all

lemma timeOrder_eq_maxTimeField_mul (Ï† : ð“•.States) (Ï†s : List ð“•.States) :
    timeOrder (ofList (Ï† :: Ï†s)) =
    ð“¢(ð“• |>â‚› maxTimeField Ï† Ï†s, ð“• |>â‚› (Ï† :: Ï†s).take (maxTimeFieldPos Ï† Ï†s)) â€¢
    ofState (maxTimeField Ï† Ï†s) * timeOrder (ofList (eraseMaxTimeField Ï† Ï†s)) := by
  rw [timeOrder_ofList, timeOrderList_eq_maxTimeField_timeOrderList]
  rw [ofList_cons, timeOrder_ofList]
  simp only [instCommGroup.eq_1, Algebra.mul_smul_comm, Algebra.smul_mul_assoc, smul_smul]
  congr
  rw [timerOrderSign_of_eraseMaxTimeField, mul_assoc]
  simp


end StateAlgebra
end
end FieldStruct
