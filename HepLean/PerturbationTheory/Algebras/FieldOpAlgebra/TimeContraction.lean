/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.Algebras.FieldOpAlgebra.NormalOrder
import HepLean.PerturbationTheory.Algebras.FieldOpAlgebra.TimeOrder
/-!

# Time contractions

We define the state algebra of a field structure to be the free algebra
generated by the states.

-/

namespace FieldSpecification
variable {ð“• : FieldSpecification}
open CrAnAlgebra
noncomputable section

namespace FieldOpAlgebra

open FieldStatistic

/-- The time contraction of two States as an element of `ð“ž.A` defined
  as their time ordering in the state algebra minus their normal ordering in the
  creation and annihlation algebra, both mapped to `ð“ž.A`.. -/
def timeContract (Ï† Ïˆ : ð“•.States) : ð“•.FieldOpAlgebra :=
    ð“£(ofFieldOp Ï† * ofFieldOp Ïˆ) - ð“(ofFieldOp Ï† * ofFieldOp Ïˆ)

lemma timeContract_eq_smul (Ï† Ïˆ : ð“•.States) : timeContract Ï† Ïˆ =
    ð“£(ofFieldOp Ï† * ofFieldOp Ïˆ) + (-1 : â„‚) â€¢ ð“(ofFieldOp Ï† * ofFieldOp Ïˆ) := by rfl

lemma timeContract_of_timeOrderRel (Ï† Ïˆ : ð“•.States) (h : timeOrderRel Ï† Ïˆ) :
    timeContract Ï† Ïˆ = [anPart Ï†, ofFieldOp Ïˆ]â‚› := by
  conv_rhs =>
    rw [ofFieldOp_eq_crPart_add_anPart]
    rw [map_add, superCommute_anPart_anPart, superCommute_anPart_crPart]
  simp only [timeContract, instCommGroup.eq_1, Algebra.smul_mul_assoc, add_zero]
  rw [timeOrder_ofFieldOp_ofFieldOp_ordered h]
  rw [normalOrder_ofFieldOp_mul_ofFieldOp]
  simp only [instCommGroup.eq_1]
  rw [ofFieldOp_eq_crPart_add_anPart, ofFieldOp_eq_crPart_add_anPart]
  simp only [mul_add, add_mul]
  abel_nf

lemma timeContract_of_not_timeOrderRel (Ï† Ïˆ : ð“•.States) (h : Â¬ timeOrderRel Ï† Ïˆ) :
    timeContract Ï† Ïˆ = ð“¢(ð“• |>â‚› Ï†, ð“• |>â‚› Ïˆ) â€¢ timeContract Ïˆ Ï† := by
  rw [timeContract_eq_smul]
  simp only [Int.reduceNeg, one_smul, map_add]
  rw [normalOrder_ofFieldOp_ofFieldOp_swap]
  rw [timeOrder_ofFieldOp_ofFieldOp_not_ordered_eq_timeOrder h]
  rw [timeContract_eq_smul]
  simp only [instCommGroup.eq_1, map_smul, map_add, smul_add]
  rw [smul_smul, smul_smul, mul_comm]

lemma timeContract_of_not_timeOrderRel_expand (Ï† Ïˆ : ð“•.States) (h : Â¬ timeOrderRel Ï† Ïˆ) :
    timeContract Ï† Ïˆ = ð“¢(ð“• |>â‚› Ï†, ð“• |>â‚› Ïˆ) â€¢ [anPart Ïˆ, ofFieldOp Ï†]â‚› := by
  rw [timeContract_of_not_timeOrderRel _ _ h]
  rw [timeContract_of_timeOrderRel _ _ _]
  have h1 := IsTotal.total (r := ð“•.timeOrderRel) Ï† Ïˆ
  simp_all

lemma timeContract_mem_center (Ï† Ïˆ : ð“•.States) :
    timeContract Ï† Ïˆ âˆˆ Subalgebra.center â„‚ ð“•.FieldOpAlgebra := by
  by_cases h : timeOrderRel Ï† Ïˆ
  Â· rw [timeContract_of_timeOrderRel _ _ h]
    exact superCommute_anPart_ofFieldOp_mem_center Ï† Ïˆ
  Â· rw [timeContract_of_not_timeOrderRel _ _ h]
    refine Subalgebra.smul_mem (Subalgebra.center â„‚ _) ?_ ð“¢(ð“• |>â‚› Ï†, ð“• |>â‚› Ïˆ)
    rw [timeContract_of_timeOrderRel]
    exact superCommute_anPart_ofFieldOp_mem_center _ _
    have h1 := IsTotal.total (r := ð“•.timeOrderRel) Ï† Ïˆ
    simp_all

lemma timeContract_zero_of_diff_grade (Ï† Ïˆ : ð“•.States) (h : (ð“• |>â‚› Ï†) â‰  (ð“• |>â‚› Ïˆ)) :
    timeContract Ï† Ïˆ = 0 := by
  by_cases h1 : timeOrderRel Ï† Ïˆ
  Â· rw [timeContract_of_timeOrderRel _ _ h1]
    rw [superCommute_anPart_ofState_diff_grade_zero]
    exact h
  Â· rw [timeContract_of_not_timeOrderRel _ _ h1]
    rw [timeContract_of_timeOrderRel _ _ _]
    rw [superCommute_anPart_ofState_diff_grade_zero]
    simp only [instCommGroup.eq_1, smul_zero]
    exact h.symm
    have ht := IsTotal.total (r := ð“•.timeOrderRel) Ï† Ïˆ
    simp_all

lemma normalOrder_timeContract (Ï† Ïˆ : ð“•.States) :
    ð“(timeContract Ï† Ïˆ) = 0 := by
  by_cases h : timeOrderRel Ï† Ïˆ
  Â· rw [timeContract_of_timeOrderRel _ _ h]
    simp
  Â· rw [timeContract_of_not_timeOrderRel _ _ h]
    simp
    have h1 : timeOrderRel Ïˆ Ï† := by
      have ht : timeOrderRel Ï† Ïˆ âˆ¨ timeOrderRel Ïˆ Ï† := IsTotal.total (r := ð“•.timeOrderRel) Ï† Ïˆ
      simp_all
    rw [timeContract_of_timeOrderRel _ _ h1]
    simp

lemma timeOrder_timeContract_eq_time_mid {Ï† Ïˆ : ð“•.States}
    (h1 : timeOrderRel Ï† Ïˆ) (h2 : timeOrderRel Ïˆ Ï†) (a b : ð“•.FieldOpAlgebra) :
    ð“£(a * timeContract Ï† Ïˆ * b) = timeContract Ï† Ïˆ * ð“£(a * b):= by
  rw [timeContract_of_timeOrderRel _ _ h1]
  rw [ofFieldOp_eq_sum]
  simp [Finset.mul_sum, Finset.sum_mul]
  congr
  funext x
  match Ï† with
  | .inAsymp Ï† =>
    simp
  | .position Ï† =>
    simp only [anPart_position, instCommGroup.eq_1]
    apply timeOrder_superCommute_eq_time_mid _ _
    simp [crAnTimeOrderRel, h1]
    simp [crAnTimeOrderRel, h2]
  | .outAsymp Ï† =>
    simp only [anPart_posAsymp, instCommGroup.eq_1]
    apply timeOrder_superCommute_eq_time_mid _ _
    simp [crAnTimeOrderRel, h1]
    simp [crAnTimeOrderRel, h2]

lemma timeOrder_timeContract_eq_time_left {Ï† Ïˆ : ð“•.States}
    (h1 : timeOrderRel Ï† Ïˆ) (h2 : timeOrderRel Ïˆ Ï†) (b : ð“•.FieldOpAlgebra) :
    ð“£(timeContract Ï† Ïˆ * b) = timeContract Ï† Ïˆ * ð“£(b):= by
  trans ð“£(1 * timeContract Ï† Ïˆ * b)
  simp
  rw [timeOrder_timeContract_eq_time_mid h1 h2]
  simp

lemma timeOrder_timeContract_neq_time {Ï† Ïˆ : ð“•.States}
    (h1 : Â¬ (timeOrderRel Ï† Ïˆ âˆ§ timeOrderRel Ïˆ Ï†)) :
    ð“£(timeContract Ï† Ïˆ) = 0 := by
  by_cases h2 : timeOrderRel Ï† Ïˆ
  Â· simp_all
    rw [timeContract_of_timeOrderRel _ _ h2]
    simp
    rw [ofFieldOp_eq_sum]
    simp [Finset.mul_sum, Finset.sum_mul]
    apply Finset.sum_eq_zero
    intro x hx
    match Ï† with
    | .inAsymp Ï† =>
      simp
    | .position Ï† =>
      simp only [anPart_position, instCommGroup.eq_1]
      apply timeOrder_superCommute_neq_time
      simp_all [crAnTimeOrderRel]
    | .outAsymp Ï† =>
      simp only [anPart_posAsymp, instCommGroup.eq_1]
      apply timeOrder_superCommute_neq_time
      simp_all [crAnTimeOrderRel]
  Â· rw [timeContract_of_not_timeOrderRel_expand _ _ h2]
    simp
    right
    rw [ofFieldOp_eq_sum]
    simp [Finset.mul_sum, Finset.sum_mul]
    apply Finset.sum_eq_zero
    intro x hx
    match Ïˆ with
    | .inAsymp Ïˆ =>
      simp
    | .position Ïˆ =>
      simp only [anPart_position, instCommGroup.eq_1]
      apply timeOrder_superCommute_neq_time
      simp_all [crAnTimeOrderRel]
    | .outAsymp Ïˆ =>
      simp only [anPart_posAsymp, instCommGroup.eq_1]
      apply timeOrder_superCommute_neq_time
      simp_all [crAnTimeOrderRel]

end FieldOpAlgebra

end
end FieldSpecification
