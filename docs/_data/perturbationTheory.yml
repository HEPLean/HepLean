
title: "Proof of Wick's theorem"
curators: Joseph Tooby-Smith
parts:

  - type: h1
    sectionNo: 1
    content: "Introduction"

  - type: remark
    name: "wicks_theorem_context"
    status : "incomplete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WicksTheorem.lean#L49"
    content: |

        In perturbative quantum field theory, Wick's theorem allows
        us to expand expectation values of time-ordered products of fields in terms of normal-orders
        and time contractions.
        The theorem is used to simplify the calculation of scattering amplitudes, and is the precurser
        to Feynman diagrams.

        There are actually three different versions of Wick's theorem used.
        The static version, the time-dependent version, and the normal-ordered time-dependent version.
        PhysLean contains a formalization of all three of these theorems in complete generality for
        mixtures of bosonic and fermionic fields.

        The statement of these theorems for bosons is simplier then when fermions are involved, since
        one does not have to worry about the minus-signs picked up on exchanging fields.

  - type: p
    content: "In this note we walk through the important parts of the proof of the three versions of
      Wick's theorem for field operators containing carrying both fermionic and bosonic statitics,
      as it appears in PhysLean. Not every lemma or definition is covered here.
      The aim is to give just enough that the story can be understood."

  - type: p
    content: "
     Before proceeding with the steps in the proof, we review some basic terminology
     related to Lean and type theory. The most important notion is that of a type.
     We don't give any formal definition here, except to say that a type `T`, like a set, has
     elements `x` which we say are of type `T` and write `x : T`. Examples of types include,
     the type of natural numbers `â„•`, the type of real numbers `â„`, the type of numbers
     `0, â€¦, n-1` denoted `Fin n`. Given two types `T` and `S`, we can form the product type `T Ã— S`,
     and the function type `T â†’ S`.

     Types form the foundation of Lean and the theory behind them will be used both explicitly and
      implicitly throughout this note."

  - type: h1
    sectionNo: 2
    content: "Field operators"

  - type: h2
    sectionNo: "2.1"
    content: "Field statistics"

  - type: name
    name: FieldStatistic
    line: 18
    fileName: PhysLean.QFT.PerturbationTheory.FieldStatistics.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldStatistics/Basic.lean#L18"
    isDef: true
    isThm: false
    docString: |
      The type `FieldStatistic` is the type containing two elements `bosonic` and `fermionic`.
      This type is used to specify if a field or operator obeys bosonic or fermionic statistics.
    declString: |
      inductive FieldStatistic : Type where
        | bosonic : FieldStatistic
        | fermionic : FieldStatistic
      deriving DecidableEq
    declNo: "2.1"

  - type: name
    name: FieldStatistic.instCommGroup
    line: 29
    fileName: PhysLean.QFT.PerturbationTheory.FieldStatistics.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldStatistics/Basic.lean#L29"
    isDef: true
    isThm: false
    docString: |
      The type `FieldStatistic` carries an instance of a commutative group in which
      - `bosonic * bosonic = bosonic`
      - `bosonic * fermionic = fermionic`
      - `fermionic * bosonic = fermionic`
      - `fermionic * fermionic = bosonic`

      This group is isomorphic to `â„¤â‚‚`.
    declString: |
      instance : CommGroup FieldStatistic where
        one := bosonic
        mul a b :=
          match a, b with
          | bosonic, bosonic => bosonic
          | bosonic, fermionic => fermionic
          | fermionic, bosonic => fermionic
          | fermionic, fermionic => bosonic
        inv a := a
        mul_assoc a b c := by
          cases a <;> cases b <;> cases c <;>
          dsimp [HMul.hMul]
        one_mul a := by
          cases a <;> dsimp [HMul.hMul]
        mul_one a := by
          cases a <;> dsimp [HMul.hMul]
        inv_mul_cancel a := by
          cases a <;> dsimp only [HMul.hMul, Nat.succ_eq_add_one] <;> rfl
        mul_comm a b := by
          cases a <;> cases b <;> rfl
    declNo: "2.2"

  - type: name
    name: FieldStatistic.exchangeSign
    line: 27
    fileName: PhysLean.QFT.PerturbationTheory.FieldStatistics.ExchangeSign
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldStatistics/ExchangeSign.lean#L27"
    isDef: true
    isThm: false
    docString: |
      The exchange sign, `exchangeSign`, is defined as the group homomorphism

      `FieldStatistic â†’* FieldStatistic â†’* â„‚`,

      for which `exchangeSign a b` is `-1` if both `a` and `b` are `fermionic` and `1` otherwise.
      The exchange sign is the sign one picks up on exchanging an operator or field `Ï†â‚` of statistic
      `a` with an operator or field `Ï†â‚‚` of statistic `b`, i.e. `Ï†â‚Ï†â‚‚ â†’ Ï†â‚‚Ï†â‚`.

      The notation `ğ“¢(a, b)` is used for the exchange sign of `a` and `b`.
    declString: |
      def exchangeSign : FieldStatistic â†’* FieldStatistic â†’* â„‚ where
        toFun a :=
          {
            toFun := fun b =>
              match a, b with
              | bosonic, _ => 1
              | _, bosonic => 1
              | fermionic, fermionic => -1
            map_one' := by
              fin_cases a
              <;> simp
            map_mul' := fun c b => by
              fin_cases a <;>
                fin_cases b <;>
                fin_cases c <;>
                simp
          }
        map_one' := by
          ext b
          fin_cases b
          <;> simp
        map_mul' c b := by
          ext a
          fin_cases a
          <;> fin_cases b <;> fin_cases c
          <;> simp
    declNo: "2.3"

  - type: h2
    sectionNo: "2.2"
    content: "Field specifications"

  - type: name
    name: FieldSpecification
    line: 32
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/Basic.lean#L32"
    isDef: true
    isThm: false
    docString: |
      The structure `FieldSpecification` is defined to have the following content:
      - A type `Field` whose elements are the constituent fields of the theory.
      - For every field `f` in `Field`, a type `PositionLabel f` whose elements label the different
        position operators associated with the field `f`. For example,
        - For `f` a *real-scalar field*, `PositionLabel f` will have a unique element.
        - For `f` a *complex-scalar field*, `PositionLabel f` will have two elements, one for the field
          operator and one for its conjugate.
        - For `f` a *Dirac fermion*, `PositionLabel f` will have eight elements, one for each Lorentz
          index of the field and its conjugate.
        - For `f` a *Weyl fermion*, `PositionLabel f` will have four elements, one for each Lorentz
          index of the field and its conjugate.
      - For every field `f` in `Field`, a type `AsymptoticLabel f` whose elements label the different
        types of incoming asymptotic field operators associated with the
        field `f` (this also matches the types of outgoing asymptotic field operators).
        For example,
        - For `f` a *real-scalar field*, `AsymptoticLabel f` will have a unique element.
        - For `f` a *complex-scalar field*, `AsymptoticLabel f` will have two elements, one for the
          field operator and one for its conjugate.
        - For `f` a *Dirac fermion*, `AsymptoticLabel f` will have four elements, two for each spin.
        - For `f` a *Weyl fermion*, `AsymptoticLabel f` will have two elements, one for each spin.
      - For each field `f` in `Field`, a field statistic `statistic f` which classifies `f` as either
        `bosonic` or `fermionic`.

    declString: |
      structure FieldSpecification where
        /-- A type whose elements are the constituent fields of the theory. -/
        Field : Type
        /-- For every field `f` in `Field`, the type `PositionLabel f` has elements that label the
          different position operators associated with the field `f`. -/
        PositionLabel : Field â†’ Type
        /-- For every field `f` in `Field`, the type `AsymptoticLabel f` has elements that label
          the different asymptotic based field operators associated with the field `f`. -/
        AsymptoticLabel : Field â†’ Type
        /-- For every field `f` in `Field`, the field statistic `statistic f` classifies `f` as either
          `bosonic` or `fermionic`. -/
        statistic : Field â†’ FieldStatistic
    declNo: "2.4"

  - type: h2
    sectionNo: "2.3"
    content: "Field operators"

  - type: name
    name: FieldSpecification.FieldOp
    line: 72
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/Basic.lean#L72"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, the inductive type `ğ“•.FieldOp` is defined
        to contain the following elements:
      - For every `f` in `ğ“•.Field`, element of `e` of `AsymptoticLabel f` and `3`-momentum `p`, an
        element labelled `inAsymp f e p` corresponding to an incoming asymptotic field operator
        of the field `f`, of label `e` (e.g. specifying the spin), and momentum `p`.
      - For every `f` in `ğ“•.Field`, element of `e` of `PositionLabel f` and space-time position `x`, an
        element labelled `position f e x` corresponding to a position field operator of the field `f`,
        of label `e` (e.g. specifying the Lorentz index), and position `x`.
      - For every `f` in `ğ“•.Field`, element of `e` of `AsymptoticLabel f` and `3`-momentum `p`, an
        element labelled `outAsymp f e p` corresponding to an outgoing asymptotic field operator of the
        field `f`, of label `e` (e.g. specifying the spin), and momentum `p`.

      As an example, if `f` corresponds to a Weyl-fermion field, then
      - For `inAsymp f e p`, `e` would correspond to a spin `s`, and `inAsymp f e p` would, once
        represented in the operator algebra,
        be proportional to the creation operator `a(p, s)`.
      - `position f e x`, `e` would correspond to a Lorentz index `a`, and `position f e x` would,
        once represented in the operator algebra, be proportional to the operator

        `âˆ‘ s, âˆ« dÂ³p/(â€¦) (xâ‚(p,s) a(p, s) e ^ (-i p x) + yâ‚(p,s) aâ€ (p, s) e ^ (-i p x))`.

      - `outAsymp f e p`, `e` would correspond to a spin `s`, and `outAsymp f e p` would,
        once represented in the operator algebra, be proportional to the
        annihilation operator `aâ€ (p, s)`.


    declString: |
      inductive FieldOp (ğ“• : FieldSpecification) where
        | inAsymp : (Î£ f, ğ“•.AsymptoticLabel f) Ã— (Fin 3 â†’ â„) â†’ ğ“•.FieldOp
        | position : (Î£ f, ğ“•.PositionLabel f) Ã— SpaceTime â†’ ğ“•.FieldOp
        | outAsymp : (Î£ f, ğ“•.AsymptoticLabel f) Ã— (Fin 3 â†’ â„) â†’ ğ“•.FieldOp
    declNo: "2.5"

  - type: name
    name: FieldSpecification.fieldOpStatistic
    line: 115
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/Basic.lean#L115"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and an element `Ï†` of `ğ“•.FieldOp`.
        The field statistic `fieldOpStatistic Ï†` is defined to be the statistic associated with
        the field underlying `Ï†`.

        The following notation is used in relation to `fieldOpStatistic`:
      - For `Ï†` an element of `ğ“•.FieldOp`, `ğ“• |>â‚› Ï†` is `fieldOpStatistic Ï†`.
      - For `Ï†s` a list of `ğ“•.FieldOp`, `ğ“• |>â‚› Ï†s` is the product of `fieldOpStatistic Ï†` over
        the list `Ï†s`.
      - For a function `f : Fin n â†’ ğ“•.FieldOp` and a finite set `a` of `Fin n`, `ğ“• |>â‚› âŸ¨f, aâŸ©` is the
        product of `fieldOpStatistic (f i)` for all `i âˆˆ a`.
    declString: |
      def fieldOpStatistic : ğ“•.FieldOp â†’ FieldStatistic := ğ“•.statistic âˆ˜ ğ“•.fieldOpToField
    declNo: "2.6"

  - type: name
    name: CreateAnnihilate
    line: 13
    fileName: PhysLean.QFT.PerturbationTheory.CreateAnnihilate
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/CreateAnnihilate.lean#L13"
    isDef: true
    isThm: false
    docString: |
      The type `CreateAnnihilate` is the type containing two elements `create` and `annihilate`.
      This type is used to specify if an operator is a creation, or annihilation, operator
      or the sum thereof or integral thereover etc.
    declString: |
      inductive CreateAnnihilate where
        | create : CreateAnnihilate
        | annihilate : CreateAnnihilate
      deriving Inhabited, BEq, DecidableEq
    declNo: "2.7"

  - type: name
    name: FieldSpecification.CrAnFieldOp
    line: 65
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.CrAnFieldOp
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/CrAnFieldOp.lean#L65"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, the (sigma) type `ğ“•.CrAnFieldOp`
      corresponds to the type of creation and annihilation parts of field operators.
      It formally defined to consist of the following elements:
      - For each incoming asymptotic field operator `Ï†` in `ğ“•.FieldOp` an element
        written as `âŸ¨Ï†, ()âŸ©` in `ğ“•.CrAnFieldOp`, corresponding to the creation part of `Ï†`.
        Here `Ï†` has no annihilation part. (Here `()` is the unique element of `Unit`.)
      - For each position field operator `Ï†` in `ğ“•.FieldOp` an element of `ğ“•.CrAnFieldOp`
        written as `âŸ¨Ï†, .createâŸ©`, corresponding to the creation part of `Ï†`.
      - For each position field operator `Ï†` in `ğ“•.FieldOp` an element of `ğ“•.CrAnFieldOp`
        written as `âŸ¨Ï†, .annihilateâŸ©`, corresponding to the annihilation part of `Ï†`.
      - For each outgoing asymptotic field operator `Ï†` in `ğ“•.FieldOp` an element
        written as `âŸ¨Ï†, ()âŸ©` in `ğ“•.CrAnFieldOp`, corresponding to the annihilation part of `Ï†`.
        Here `Ï†` has no creation part. (Here `()` is the unique element of `Unit`.)

      As an example, if `f` corresponds to a Weyl-fermion field, it would contribute
        the following elements to `ğ“•.CrAnFieldOp`
      - For each spin `s`, an element corresponding to an incoming asymptotic operator: `a(p, s)`.
      - For each each Lorentz
        index `a`, an element corresponding to the creation part of a position operator:

        `âˆ‘ s, âˆ« dÂ³p/(â€¦) (xâ‚ (p,s) a(p, s) e ^ (-i p x))`.
      - For each each Lorentz
        index `a`,an element corresponding to annihilation part of a position operator:

        `âˆ‘ s, âˆ« dÂ³p/(â€¦) (yâ‚(p,s) aâ€ (p, s) e ^ (-i p x))`.
      - For each spin `s`, element corresponding to an outgoing asymptotic operator: `aâ€ (p, s)`.


    declString: |
      def CrAnFieldOp : Type := Î£ (s : ğ“•.FieldOp), ğ“•.fieldOpToCrAnType s
    declNo: "2.8"

  - type: name
    name: FieldSpecification.crAnFieldOpToCreateAnnihilate
    line: 103
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.CrAnFieldOp
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/CrAnFieldOp.lean#L103"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `ğ“•.crAnFieldOpToCreateAnnihilate` is the map from
        `ğ“•.CrAnFieldOp` to `CreateAnnihilate` taking `Ï†` to `create` if
      - `Ï†` corresponds to an incoming asymptotic field operator or the creation part of a position based
        field operator.

      otherwise it takes `Ï†` to `annihilate`.

    declString: |
      def crAnFieldOpToCreateAnnihilate : ğ“•.CrAnFieldOp â†’ CreateAnnihilate
        | âŸ¨FieldOp.inAsymp _, _âŸ© => CreateAnnihilate.create
        | âŸ¨FieldOp.position _, CreateAnnihilate.createâŸ© => CreateAnnihilate.create
        | âŸ¨FieldOp.position _, CreateAnnihilate.annihilateâŸ© => CreateAnnihilate.annihilate
        | âŸ¨FieldOp.outAsymp _, _âŸ© => CreateAnnihilate.annihilate
    declNo: "2.9"

  - type: name
    name: FieldSpecification.crAnStatistics
    line: 116
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.CrAnFieldOp
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/CrAnFieldOp.lean#L116"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and an element `Ï†` in `ğ“•.CrAnFieldOp`, the field
      statistic `crAnStatistics Ï†` is defined to be the statistic associated with the field `ğ“•.Field`
      (or the `ğ“•.FieldOp`) underlying `Ï†`.

      The following notation is used in relation to `crAnStatistics`:
      - For `Ï†` an element of `ğ“•.CrAnFieldOp`, `ğ“• |>â‚› Ï†` is `crAnStatistics Ï†`.
      - For `Ï†s` a list of `ğ“•.CrAnFieldOp`, `ğ“• |>â‚› Ï†s` is the product of `crAnStatistics Ï†` over
        the list `Ï†s`.

    declString: |
      def crAnStatistics : ğ“•.CrAnFieldOp â†’ FieldStatistic :=
        ğ“•.fieldOpStatistic âˆ˜ ğ“•.crAnFieldOpToFieldOp
    declNo: "2.10"

  - type: remark
    name: "notation_remark"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/CrAnFieldOp.lean#L141"
    content: |
      When working with a field specification `ğ“•` the
      following notation will be used within doc-strings:
      - when field statistics occur in exchange signs the `ğ“• |>â‚› _` may be dropped.
      - lists of `FieldOp` or `CrAnFieldOp` `Ï†s` may be written as `Ï†â‚€â€¦Ï†â‚™`,
        which should be interpreted within the context in which it appears.
      - `Ï†á¶œ` may be used to indicate the creation part of an operator and
        `Ï†áµƒ` to indicate the annihilation part of an operator.

      Some examples of these notation-conventions are:
      - `ğ“¢(Ï†, Ï†s)` which corresponds to `ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› Ï†s)`
      - `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚â€¦Ï†â‚™` which corresponds to a (given) list `Ï†s = Ï†â‚€â€¦Ï†â‚™` with the element at the
        `i`th position removed.


  - type: h2
    sectionNo: "2.4"
    content: "Field-operator free algebra"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra
    line: 37
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L37"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, the algebra `ğ“•.FieldOpFreeAlgebra` is
      the free algebra generated by `ğ“•.CrAnFieldOp`.
    declString: |
      abbrev FieldOpFreeAlgebra (ğ“• : FieldSpecification) : Type := FreeAlgebra â„‚ ğ“•.CrAnFieldOp
    declNo: "2.11"

  - type: remark
    name: "naming_convention"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L43"
    content: |

        For mathematicial objects defined in relation to `FieldOpFreeAlgebra` the postfix `F`
        may be given to
        their names to indicate that they are related to the free algebra.
        This is to avoid confusion when working within the context of `FieldOpAlgebra` which is defined
        as a quotient of `FieldOpFreeAlgebra`.

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.ofCrAnOpF
    line: 50
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L50"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and a element `Ï†` of `ğ“•.CrAnFieldOp`,
      `ofCrAnOpF Ï†` is defined as the element of `ğ“•.FieldOpFreeAlgebra` formed by `Ï†`.
    declString: |
      def ofCrAnOpF (Ï† : ğ“•.CrAnFieldOp) : FieldOpFreeAlgebra ğ“• :=
        FreeAlgebra.Î¹ â„‚ Ï†
    declNo: "2.12"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.universality
    line: 55
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L55"
    isDef: false
    isThm: false
    docString: |
      The algebra `ğ“•.FieldOpFreeAlgebra` satisfies the universal property that for any other algebra
      `A` (e.g. the operator algebra of the theory) with a map `f : ğ“•.CrAnFieldOp â†’ A` (e.g.
      the inclusion of the creation and annihilation parts of field operators into the
      operator algebra) there is a unique algebra map `g : ğ“•.FieldOpFreeAlgebra â†’ A`
      such that `g âˆ˜ ofCrAnOpF = f`.

      The unique `g` is given by `FreeAlgebra.lift â„‚ f`.

    declString: |
      lemma universality {A : Type} [Semiring A] [Algebra â„‚ A] (f : ğ“•.CrAnFieldOp â†’ A) :
          âˆƒ! g : FieldOpFreeAlgebra ğ“• â†’â‚[â„‚] A, g âˆ˜ ofCrAnOpF = f := by
        use FreeAlgebra.lift â„‚ f
        apply And.intro
        Â· funext x
          simp [ofCrAnOpF]
        Â· intro g hg
          ext x
          simpa using congrFun hg x
    declNo: "2.13"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.ofCrAnListF
    line: 74
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L74"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and a list `Ï†s` of `ğ“•.CrAnFieldOp`,
      `ofCrAnListF Ï†s` is defined as the element of `ğ“•.FieldOpFreeAlgebra`
      obtained by the product of `ofCrAnListF Ï†` for each `Ï†` in `Ï†s`.
      For example `ofCrAnListF [Ï†â‚, Ï†â‚‚, Ï†â‚ƒ] = ofCrAnOpF Ï†â‚ * ofCrAnOpF Ï†â‚‚ * ofCrAnOpF Ï†â‚ƒ`.
      The set of all `ofCrAnListF Ï†s` forms a basis of `FieldOpFreeAlgebra ğ“•`.
    declString: |
      def ofCrAnListF (Ï†s : List ğ“•.CrAnFieldOp) : FieldOpFreeAlgebra ğ“• := (List.map ofCrAnOpF Ï†s).prod
    declNo: "2.14"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.ofFieldOpF
    line: 94
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L94"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and an element `Ï†` of `ğ“•.FieldOp`,
      `ofFieldOpF Ï†` is the element of `ğ“•.FieldOpFreeAlgebra` formed by summing over
      `ofCrAnOpF` of the
      creation and annihilation parts of `Ï†`.

      For example, for `Ï†` an incoming asymptotic field operator we get
      `ofCrAnOpF âŸ¨Ï†, ()âŸ©`, and for `Ï†` a
      position field operator we get `ofCrAnOpF âŸ¨Ï†, .createâŸ© + ofCrAnOpF âŸ¨Ï†, .annihilateâŸ©`.
    declString: |
      def ofFieldOpF (Ï† : ğ“•.FieldOp) : FieldOpFreeAlgebra ğ“• :=
        âˆ‘ (i : ğ“•.fieldOpToCrAnType Ï†), ofCrAnOpF âŸ¨Ï†, iâŸ©
    declNo: "2.15"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.ofFieldOpListF
    line: 105
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L105"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and a list `Ï†s` of `ğ“•.FieldOp`,
      `ğ“•.ofFieldOpListF Ï†s` is defined as the element of `ğ“•.FieldOpFreeAlgebra`
      obtained by the product of `ofFieldOpF Ï†` for each `Ï†` in `Ï†s`.
      For example `ofFieldOpListF [Ï†â‚, Ï†â‚‚, Ï†â‚ƒ] = ofFieldOpF Ï†â‚ * ofFieldOpF Ï†â‚‚ * ofFieldOpF Ï†â‚ƒ`.
    declString: |
      def ofFieldOpListF (Ï†s : List ğ“•.FieldOp) : FieldOpFreeAlgebra ğ“• := (List.map ofFieldOpF Ï†s).prod
    declNo: "2.16"

  - type: remark
    name: "notation_drop"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L111"
    content: |
      In doc-strings explicit applications of `ofCrAnOpF`,
      `ofCrAnListF`, `ofFieldOpF`, and `ofFieldOpListF` will often be dropped.

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.fieldOpFreeAlgebraGrade
    line: 239
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Grading
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/Grading.lean#L239"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, the algebra `ğ“•.FieldOpFreeAlgebra` is graded by `FieldStatistic`.
      Those `ofCrAnListF Ï†s` for which `Ï†s` has an overall `bosonic` statistic
      (i.e. `ğ“• |>â‚› Ï†s = bosonic`) span `bosonic`
      submodule, whilst those `ofCrAnListF Ï†s` for which `Ï†s` has an overall `fermionic` statistic
      (i.e. `ğ“• |>â‚› Ï†s = fermionic`) span
      the `fermionic` submodule.
    declString: |
      instance fieldOpFreeAlgebraGrade :
          GradedAlgebra (A := ğ“•.FieldOpFreeAlgebra) statisticSubmodule where
        one_mem := by
          simp only [statisticSubmodule]
          refine Submodule.mem_span.mpr fun p a => a ?_
          simp only [Set.mem_setOf_eq]
          use []
          simp only [ofCrAnListF_nil, ofList_empty, true_and]
          rfl
        mul_mem f1 f2 a1 a2 h1 h2 := by
          let p (a2 : ğ“•.FieldOpFreeAlgebra) (hx : a2 âˆˆ statisticSubmodule f2) : Prop :=
            a1 * a2 âˆˆ statisticSubmodule (f1 + f2)
          change p a2 h2
          apply Submodule.span_induction (p := p)
          Â· intro x hx
            simp only [Set.mem_setOf_eq] at hx
            obtain âŸ¨Ï†s, rfl, hâŸ© := hx
            simp only [p]
            let p (a1 : ğ“•.FieldOpFreeAlgebra) (hx : a1 âˆˆ statisticSubmodule f1) : Prop :=
              a1 * ofCrAnListF Ï†s âˆˆ statisticSubmodule (f1 + f2)
            change p a1 h1
            apply Submodule.span_induction (p := p)
            Â· intro y hy
              obtain âŸ¨Ï†s', rfl, h'âŸ© := hy
              simp only [p]
              rw [â† ofCrAnListF_append]
              refine Submodule.mem_span.mpr fun p a => a ?_
              simp only [Set.mem_setOf_eq]
              use Ï†s' ++ Ï†s
              simp only [ofList_append, h', h, true_and]
              cases f1 <;> cases f2 <;> rfl
            Â· simp [p]
            Â· intro x y hx hy hx1 hx2
              simp only [add_mul, p]
              exact Submodule.add_mem _ hx1 hx2
            Â· intro c a hx h1
              simp only [Algebra.smul_mul_assoc, p]
              exact Submodule.smul_mem _ _ h1
            Â· exact h1
          Â· simp [p]
          Â· intro x y hx hy hx1 hx2
            simp only [mul_add, p]
            exact Submodule.add_mem _ hx1 hx2
          Â· intro c a hx h1
            simp only [Algebra.mul_smul_comm, p]
            exact Submodule.smul_mem _ _ h1
          Â· exact h2
        decompose' a := DirectSum.of (fun i => (statisticSubmodule (ğ“• := ğ“•) i)) bosonic (bosonicProjF a)
          + DirectSum.of (fun i => (statisticSubmodule (ğ“• := ğ“•) i)) fermionic (fermionicProjF a)
        left_inv a := by
          trans a.bosonicProjF + fermionicProjF a
          Â· simp
          Â· exact bosonicProjF_add_fermionicProjF a
        right_inv a := by
          rw [coeAddMonoidHom_apply_eq_bosonic_plus_fermionic]
          simp only [DFinsupp.toFun_eq_coe, map_add, bosonicProjF_of_bonosic_part,
            bosonicProjF_of_fermionic_part, add_zero, fermionicProjF_of_bosonic_part,
            fermionicProjF_of_fermionic_part, zero_add]
          conv_rhs => rw [directSum_eq_bosonic_plus_fermionic a]
    declNo: "2.17"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.superCommuteF
    line: 26
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean#L26"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, the super commutator `superCommuteF` is defined as the linear
      map `ğ“•.FieldOpFreeAlgebra â†’â‚—[â„‚] ğ“•.FieldOpFreeAlgebra â†’â‚—[â„‚] ğ“•.FieldOpFreeAlgebra`
      which on the lists `Ï†s` and `Ï†s'` of `ğ“•.CrAnFieldOp` gives

      `superCommuteF Ï†s Ï†s' = Ï†s * Ï†s' - ğ“¢(Ï†s, Ï†s') â€¢ Ï†s' * Ï†s`.

      The notation `[a, b]â‚›F` can be used for `superCommuteF a b`.
    declString: |
      noncomputable def superCommuteF : ğ“•.FieldOpFreeAlgebra â†’â‚—[â„‚] ğ“•.FieldOpFreeAlgebra â†’â‚—[â„‚]
          ğ“•.FieldOpFreeAlgebra :=
        Basis.constr ofCrAnListFBasis â„‚ fun Ï†s =>
        Basis.constr ofCrAnListFBasis â„‚ fun Ï†s' =>
        ofCrAnListF (Ï†s ++ Ï†s') - ğ“¢(ğ“• |>â‚› Ï†s, ğ“• |>â‚› Ï†s') â€¢ ofCrAnListF (Ï†s' ++ Ï†s)
    declNo: "2.18"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum
    line: 408
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean#L408"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, and two lists `Ï†s = Ï†â‚€â€¦Ï†â‚™` and `Ï†s'` of `ğ“•.CrAnFieldOp`
      the following super commutation relation holds:

      `[Ï†s', Ï†â‚€â€¦Ï†â‚™]â‚›F = âˆ‘ i, ğ“¢(Ï†s', Ï†â‚€â€¦Ï†áµ¢â‚‹â‚) â€¢ Ï†â‚€â€¦Ï†áµ¢â‚‹â‚ * [Ï†s', Ï†áµ¢]â‚›F * Ï†áµ¢â‚Šâ‚ â€¦ Ï†â‚™`

      The proof of this relation is via induction on the length of `Ï†s`.

    declString: |
      lemma superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum (Ï†s : List ğ“•.CrAnFieldOp) :
          (Ï†s' : List ğ“•.CrAnFieldOp) â†’ [ofCrAnListF Ï†s, ofCrAnListF Ï†s']â‚›F =
          âˆ‘ (n : Fin Ï†s'.length), ğ“¢(ğ“• |>â‚› Ï†s, ğ“• |>â‚› Ï†s'.take n) â€¢
          ofCrAnListF (Ï†s'.take n) * [ofCrAnListF Ï†s, ofCrAnOpF (Ï†s'.get n)]â‚›F *
          ofCrAnListF (Ï†s'.drop (n + 1))
        | [] => by
          simp [â† ofCrAnListF_nil, superCommuteF_ofCrAnListF_ofCrAnListF]
        | Ï† :: Ï†s' => by
          rw [superCommuteF_ofCrAnListF_ofCrAnListF_cons,
            superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum Ï†s Ï†s']
          conv_rhs => erw [Fin.sum_univ_succ]
          congr 1
          Â· simp
          Â· simp [Finset.mul_sum, smul_smul, ofCrAnListF_cons, mul_assoc,
              FieldStatistic.ofList_cons_eq_mul, mul_comm]
    declNo: "2.19"

  - type: h2
    sectionNo: "2.5"
    content: "Field-operator algebra"

  - type: name
    name: FieldSpecification.FieldOpAlgebra
    line: 35
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L35"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, the algebra `ğ“•.FieldOpAlgebra` is defined as the quotient
        of the free algebra `ğ“•.FieldOpFreeAlgebra` by the ideal generated by
      - `[ofCrAnOpF Ï†c, ofCrAnOpF Ï†c']â‚›F` for `Ï†c` and `Ï†c'` field creation operators.
        This corresponds to the condition that two creation operators always super-commute.
      - `[ofCrAnOpF Ï†a, ofCrAnOpF Ï†a']â‚›F` for `Ï†a` and `Ï†a'` field annihilation operators.
        This corresponds to the condition that two annihilation operators always super-commute.
      - `[ofCrAnOpF Ï†, ofCrAnOpF Ï†']â‚›F` for `Ï†` and `Ï†'` operators with different statistics.
        This corresponds to the condition that two operators with different statistics always
        super-commute. In other words, fermions and bosons always super-commute.
      - `[ofCrAnOpF Ï†1, [ofCrAnOpF Ï†2, ofCrAnOpF Ï†3]â‚›F]â‚›F`. This corresponds to the condition,
        when combined with the conditions above, that the super-commutator is in the center
        of the algebra.

    declString: |
      abbrev FieldOpAlgebra : Type := (TwoSidedIdeal.span ğ“•.fieldOpIdealSet).ringCon.Quotient
    declNo: "2.20"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.Î¹
    line: 73
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L73"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `Î¹` is defined as the projection

      `ğ“•.FieldOpFreeAlgebra â†’â‚[â„‚] ğ“•.FieldOpAlgebra`

      taking each element of `ğ“•.FieldOpFreeAlgebra` to its equivalence class in `FieldOpAlgebra ğ“•`.
    declString: |
      def Î¹ : FieldOpFreeAlgebra ğ“• â†’â‚[â„‚] FieldOpAlgebra ğ“• where
        toFun := (TwoSidedIdeal.span ğ“•.fieldOpIdealSet).ringCon.mk'
        map_one' := by rfl
        map_mul' x y := by rfl
        map_zero' := by rfl
        map_add' x y := by rfl
        commutes' x := by rfl
    declNo: "2.21"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.universality
    line: 77
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Universality
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Universality.lean#L77"
    isDef: false
    isThm: false
    docString: |
      For a field specification, `ğ“•`, the algebra `ğ“•.FieldOpAlgebra` satisfies the following universal
      property. Let `f : ğ“•.CrAnFieldOp â†’ A` be a function and `g : ğ“•.FieldOpFreeAlgebra â†’â‚[â„‚] A`
      the universal lift of that function associated with the free algebra `ğ“•.FieldOpFreeAlgebra`.
      If `g` is zero on the ideal defining `ğ“•.FieldOpAlgebra`, then there exists
      algebra map `g' : FieldOpAlgebra ğ“• â†’â‚[â„‚] A` such that `g' âˆ˜ Î¹ = g`, and furthermore this
      algebra map is unique.

    declString: |
      lemma universality {A : Type} [Semiring A] [Algebra â„‚ A] (f : ğ“•.CrAnFieldOp â†’ A)
          (h1 : âˆ€ a âˆˆ TwoSidedIdeal.span ğ“•.fieldOpIdealSet, FreeAlgebra.lift â„‚ f a = 0) :
          âˆƒ! g : FieldOpAlgebra ğ“• â†’â‚[â„‚] A, g âˆ˜ Î¹ = FreeAlgebra.lift â„‚ f := by
        use universalLift f h1
        simp only
        apply And.intro
        Â· ext a
          simp
        Â· intro g hg
          ext a
          obtain âŸ¨a, rflâŸ© := Î¹_surjective a
          simpa using congrFun hg a
    declNo: "2.22"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofCrAnOp
    line: 495
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L495"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•` and an element `Ï†` of `ğ“•.CrAnFieldOp`,
      `ofCrAnOp Ï†` is defined as the element of
      `ğ“•.FieldOpAlgebra` given by `Î¹ (ofCrAnOpF Ï†)`.
    declString: |
      def ofCrAnOp (Ï† : ğ“•.CrAnFieldOp) : ğ“•.FieldOpAlgebra := Î¹ (ofCrAnOpF Ï†)
    declNo: "2.23"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofCrAnList
    line: 509
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L509"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•` and a list `Ï†s` of `ğ“•.CrAnFieldOp`,
      `ofCrAnList Ï†s` is defined as the element of
      `ğ“•.FieldOpAlgebra` given by `Î¹ (ofCrAnListF Ï†)`.
    declString: |
      def ofCrAnList (Ï†s : List ğ“•.CrAnFieldOp) : ğ“•.FieldOpAlgebra := Î¹ (ofCrAnListF Ï†s)
    declNo: "2.24"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofFieldOp
    line: 463
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L463"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•` and an element `Ï†` of `ğ“•.FieldOp`,
      `ofFieldOp Ï†` is defined as the element of
      `ğ“•.FieldOpAlgebra` given by `Î¹ (ofFieldOpF Ï†)`.
    declString: |
      def ofFieldOp (Ï† : ğ“•.FieldOp) : ğ“•.FieldOpAlgebra := Î¹ (ofFieldOpF Ï†)
    declNo: "2.25"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofCrAnList
    line: 509
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L509"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•` and a list `Ï†s` of `ğ“•.CrAnFieldOp`,
      `ofCrAnList Ï†s` is defined as the element of
      `ğ“•.FieldOpAlgebra` given by `Î¹ (ofCrAnListF Ï†)`.
    declString: |
      def ofCrAnList (Ï†s : List ğ“•.CrAnFieldOp) : ğ“•.FieldOpAlgebra := Î¹ (ofCrAnListF Ï†s)
    declNo: "2.26"

  - type: remark
    name: "notation_drop"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L533"
    content: |
      In doc-strings we will often drop explicit applications of `ofCrAnOp`,
      `ofCrAnList`, `ofFieldOp`, and `ofFieldOpList`

  - type: name
    name: FieldSpecification.FieldOpAlgebra.anPart
    line: 536
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L536"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and an element `Ï†` of `ğ“•.FieldOp`, the
        annihilation part of `ğ“•.FieldOp` as an element of `ğ“•.FieldOpAlgebra`.
        Thus for `Ï†`
      - an incoming asymptotic state this is `0`.
      - a position based state this is `ofCrAnOp âŸ¨Ï†, .createâŸ©`.
      - an outgoing asymptotic state this is `ofCrAnOp âŸ¨Ï†, ()âŸ©`.
    declString: |
      def anPart (Ï† : ğ“•.FieldOp) : ğ“•.FieldOpAlgebra := Î¹ (anPartF Ï†)
    declNo: "2.27"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.crPart
    line: 562
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L562"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and an element `Ï†` of `ğ“•.FieldOp`, the
        creation part of `ğ“•.FieldOp` as an element of `ğ“•.FieldOpAlgebra`.
        Thus for `Ï†`
      - an incoming asymptotic state this is `ofCrAnOp âŸ¨Ï†, ()âŸ©`.
      - a position based state this is `ofCrAnOp âŸ¨Ï†, .createâŸ©`.
      - an outgoing asymptotic state this is `0`.
    declString: |
      def crPart (Ï† : ğ“•.FieldOp) : ğ“•.FieldOpAlgebra := Î¹ (crPartF Ï†)
    declNo: "2.28"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofFieldOp_eq_crPart_add_anPart
    line: 588
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Basic.lean#L588"
    isDef: false
    isThm: false
    docString: |
      For field specification `ğ“•`, and an element `Ï†` of `ğ“•.FieldOp` the following relation holds:

      `ofFieldOp Ï† = crPart Ï† + anPart Ï†`

      That is, every field operator splits into its creation part plus its annihilation part.

    declString: |
      lemma ofFieldOp_eq_crPart_add_anPart (Ï† : ğ“•.FieldOp) :
          ofFieldOp Ï† = crPart Ï† + anPart Ï† := by
        rw [ofFieldOp, crPart, anPart, ofFieldOpF_eq_crPartF_add_anPartF]
        simp only [map_add]
    declNo: "2.29"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.fieldOpAlgebraGrade
    line: 386
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Grading
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/Grading.lean#L386"
    isDef: true
    isThm: false
    docString: |
      For a field statistic `ğ“•`, the algebra `ğ“•.FieldOpAlgebra` is graded by `FieldStatistic`.
      Those `ofCrAnList Ï†s` for which `Ï†s` has an overall `bosonic` statistic
      (i.e. `ğ“• |>â‚› Ï†s = bosonic`) span `bosonic`
      submodule, whilst those `ofCrAnList Ï†s` for which `Ï†s` has an overall `fermionic` statistic
      (i.e. `ğ“• |>â‚› Ï†s = fermionic`) span the `fermionic` submodule.
    declString: |
      instance fieldOpAlgebraGrade : GradedAlgebra (A := ğ“•.FieldOpAlgebra) statSubmodule where
        one_mem := by
          simp only [statSubmodule]
          refine Submodule.mem_span.mpr fun p a => a ?_
          simp only [Set.mem_setOf_eq]
          use []
          simp only [ofCrAnList, ofCrAnListF_nil, map_one, ofList_empty, true_and]
          rfl
        mul_mem f1 f2 a1 a2 h1 h2 := by
          let p (a2 : ğ“•.FieldOpAlgebra) (hx : a2 âˆˆ statSubmodule f2) : Prop :=
            a1 * a2 âˆˆ statSubmodule (f1 + f2)
          change p a2 h2
          apply Submodule.span_induction
          Â· intro x hx
            simp only [Set.mem_setOf_eq] at hx
            obtain âŸ¨Ï†s, rfl, hâŸ© := hx
            simp only [p]
            let p (a1 : ğ“•.FieldOpAlgebra) (hx : a1 âˆˆ statSubmodule f1) : Prop :=
              a1 * ofCrAnList Ï†s âˆˆ statSubmodule (f1 + f2)
            change p a1 h1
            apply Submodule.span_induction (p := p)
            Â· intro y hy
              obtain âŸ¨Ï†s', rfl, h'âŸ© := hy
              simp only [p]
              rw [â† ofCrAnList_append]
              refine Submodule.mem_span.mpr fun p a => a ?_
              simp only [Set.mem_setOf_eq]
              use Ï†s' ++ Ï†s
              simp only [ofList_append, h', h, true_and]
              cases f1 <;> cases f2 <;> rfl
            Â· simp [p]
            Â· intro x y hx hy hx1 hx2
              simp only [add_mul, p]
              exact Submodule.add_mem _ hx1 hx2
            Â· intro c a hx h1
              simp only [Algebra.smul_mul_assoc, p]
              exact Submodule.smul_mem _ _ h1
            Â· exact h1
          Â· simp [p]
          Â· intro x y hx hy hx1 hx2
            simp only [mul_add, p]
            exact Submodule.add_mem _ hx1 hx2
          Â· intro c a hx h1
            simp only [Algebra.mul_smul_comm, p]
            exact Submodule.smul_mem _ _ h1
        decompose' a := DirectSum.of (fun i => (statSubmodule (ğ“• := ğ“•) i)) bosonic (bosonicProj a)
          + DirectSum.of (fun i => (statSubmodule (ğ“• := ğ“•) i)) fermionic (fermionicProj a)
        left_inv a := by
          trans a.bosonicProj + a.fermionicProj
          Â· simp
          Â· exact bosonicProj_add_fermionicProj a
        right_inv a := by
          rw [coeAddMonoidHom_apply_eq_bosonic_plus_fermionic]
          simp only [DFinsupp.toFun_eq_coe, map_add, bosonicProj_of_bosonic_part,
            bosonicProj_of_fermionic_part, add_zero, fermionicProj_of_bosonic_part,
            fermionicProj_of_fermionic_part, zero_add]
          conv_rhs => rw [directSum_eq_bosonic_plus_fermionic a]
    declNo: "2.30"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.superCommute
    line: 91
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.SuperCommute
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean#L91"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `superCommute` is the linear map

      `FieldOpAlgebra ğ“• â†’â‚—[â„‚] FieldOpAlgebra ğ“• â†’â‚—[â„‚] FieldOpAlgebra ğ“•`

      defined as the descent of `Î¹ âˆ˜ superCommuteF` in both arguments.
      In particular for `Ï†s` and `Ï†s'` lists of `ğ“•.CrAnFieldOp` in `FieldOpAlgebra ğ“•` the following
      relation holds:

      `superCommute Ï†s Ï†s' = Ï†s * Ï†s' - ğ“¢(Ï†s, Ï†s') â€¢ Ï†s' * Ï†s`

      The notation `[a, b]â‚›` is used for `superCommute a b`.

    declString: |
      noncomputable def superCommute : FieldOpAlgebra ğ“• â†’â‚—[â„‚]
          FieldOpAlgebra ğ“• â†’â‚—[â„‚] FieldOpAlgebra ğ“• where
        toFun := Quotient.lift superCommuteRight superCommuteRight_eq_of_equiv
        map_add' x y := by
          obtain âŸ¨x, rflâŸ© := Î¹_surjective x
          obtain âŸ¨y, rflâŸ© := Î¹_surjective y
          ext b
          obtain âŸ¨b, rflâŸ© := Î¹_surjective b
          rw [â† map_add, Î¹_apply, Î¹_apply, Î¹_apply, Î¹_apply]
          rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]
          simp only [LinearMap.add_apply]
          rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot, superCommuteRight_apply_quot]
          simp
        map_smul' c y := by
          obtain âŸ¨y, rflâŸ© := Î¹_surjective y
          ext b
          obtain âŸ¨b, rflâŸ© := Î¹_surjective b
          rw [â† map_smul, Î¹_apply, Î¹_apply, Î¹_apply]
          simp only [Quotient.lift_mk, RingHom.id_apply, LinearMap.smul_apply]
          rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot]
          simp
    declNo: "2.31"

  - type: h1
    sectionNo: 3
    content: "Time ordering"

  - type: name
    name: FieldSpecification.crAnTimeOrderRel
    line: 194
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/TimeOrder.lean#L194"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `ğ“•.crAnTimeOrderRel` is a relation on
        `ğ“•.CrAnFieldOp` representing time ordering.
        It is defined such that `ğ“•.crAnTimeOrderRel Ï†â‚€ Ï†â‚` is true if and only if one of the following
        holds
      - `Ï†â‚€` is an *outgoing* asymptotic operator
      - `Ï†â‚` is an *incoming* asymptotic field operator
      - `Ï†â‚€` and `Ï†â‚` are both position field operators where
        the `SpaceTime` point of `Ï†â‚€` has a time *greater* than or equal to that of `Ï†â‚`.

      Thus, colloquially `ğ“•.crAnTimeOrderRel Ï†â‚€ Ï†â‚` if `Ï†â‚€` has time *greater* than or equal to `Ï†â‚`.
      The use of *greater* than rather then *less* than is because on ordering lists of operators
      it is needed that the operator with the greatest time is to the left.

    declString: |
      def crAnTimeOrderRel (a b : ğ“•.CrAnFieldOp) : Prop := ğ“•.timeOrderRel a.1 b.1
    declNo: "3.1"

  - type: name
    name: FieldSpecification.crAnTimeOrderList
    line: 255
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/TimeOrder.lean#L255"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and a list `Ï†s` of `ğ“•.CrAnFieldOp`,
      `ğ“•.crAnTimeOrderList Ï†s` is the list `Ï†s` time-ordered using the insertion sort algorithm.
    declString: |
      def crAnTimeOrderList (Ï†s : List ğ“•.CrAnFieldOp) : List ğ“•.CrAnFieldOp :=
        List.insertionSort ğ“•.crAnTimeOrderRel Ï†s
    declNo: "3.2"

  - type: name
    name: FieldSpecification.crAnTimeOrderSign
    line: 226
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/TimeOrder.lean#L226"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and a list `Ï†s` of `ğ“•.CrAnFieldOp`,
      `ğ“•.crAnTimeOrderSign Ï†s` is the sign corresponding to the number of `ferimionic`-`fermionic`
      exchanges undertaken to time-order (i.e. order with respect to `ğ“•.crAnTimeOrderRel`) `Ï†s` using
      the insertion sort algorithm.
    declString: |
      def crAnTimeOrderSign (Ï†s : List ğ“•.CrAnFieldOp) : â„‚ :=
        Wick.koszulSign ğ“•.crAnStatistics ğ“•.crAnTimeOrderRel Ï†s
    declNo: "3.3"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.timeOrderF
    line: 29
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/TimeOrder.lean#L29"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `timeOrderF` is the linear map

      `FieldOpFreeAlgebra ğ“• â†’â‚—[â„‚] FieldOpFreeAlgebra ğ“•`

      defined by its action on the basis `ofCrAnListF Ï†s`, taking
      `ofCrAnListF Ï†s` to

      `crAnTimeOrderSign Ï†s â€¢ ofCrAnListF (crAnTimeOrderList Ï†s)`.

      That is, `timeOrderF` time-orders the field operators and multiplies by the sign of the
      time order.

      The notation `ğ“£á¶ (a)` is used for `timeOrderF a`
    declString: |
      def timeOrderF : FieldOpFreeAlgebra ğ“• â†’â‚—[â„‚] FieldOpFreeAlgebra ğ“• :=
        Basis.constr ofCrAnListFBasis â„‚ fun Ï†s =>
        crAnTimeOrderSign Ï†s â€¢ ofCrAnListF (crAnTimeOrderList Ï†s)
    declNo: "3.4"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder
    line: 370
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean#L370"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `timeOrder` is the linear map

      `FieldOpAlgebra ğ“• â†’â‚—[â„‚] FieldOpAlgebra ğ“•`

      defined as the descent of `Î¹ âˆ˜â‚— timeOrderF : FieldOpFreeAlgebra ğ“• â†’â‚—[â„‚] FieldOpAlgebra ğ“•` from
      `FieldOpFreeAlgebra ğ“•` to `FieldOpAlgebra ğ“•`.
      This descent exists because `Î¹ âˆ˜â‚— timeOrderF` is well-defined on equivalence classes.

      The notation `ğ“£(a)` is used for `timeOrder a`.
    declString: |
      noncomputable def timeOrder : FieldOpAlgebra ğ“• â†’â‚—[â„‚] FieldOpAlgebra ğ“• where
        toFun := Quotient.lift (Î¹.toLinearMap âˆ˜â‚— timeOrderF) Î¹_timeOrderF_eq_of_equiv
        map_add' x y := by
          obtain âŸ¨x, hxâŸ© := Î¹_surjective x
          obtain âŸ¨y, hyâŸ© := Î¹_surjective y
          subst hx hy
          rw [â† map_add, Î¹_apply, Î¹_apply, Î¹_apply]
          rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]
          simp
        map_smul' c y := by
          obtain âŸ¨y, hyâŸ© := Î¹_surjective y
          subst hy
          rw [â† map_smul, Î¹_apply, Î¹_apply]
          simp
    declNo: "3.5"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder_eq_maxTimeField_mul_finset
    line: 434
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean#L434"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, the time order operator acting on a
      list of `ğ“•.FieldOp`, `ğ“£(Ï†â‚€â€¦Ï†â‚™)`, is equal to
      `ğ“¢(Ï†áµ¢,Ï†â‚€â€¦Ï†áµ¢â‚‹â‚) â€¢ Ï†áµ¢ * ğ“£(Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚Ï†â‚™)` where `Ï†áµ¢` is the maximal time field
      operator in `Ï†â‚€â€¦Ï†â‚™`.

      The proof of this result ultimately relies on basic properties of ordering and signs.
    declString: |
      lemma timeOrder_eq_maxTimeField_mul_finset (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp) :
          ğ“£(ofFieldOpList (Ï† :: Ï†s)) = ğ“¢(ğ“• |>â‚› maxTimeField Ï† Ï†s, ğ“• |>â‚› âŸ¨(eraseMaxTimeField Ï† Ï†s).get,
            (Finset.univ.filter (fun x =>
              (maxTimeFieldPosFin Ï† Ï†s).succAbove x < maxTimeFieldPosFin Ï† Ï†s))âŸ©) â€¢
            ofFieldOp (maxTimeField Ï† Ï†s) * ğ“£(ofFieldOpList (eraseMaxTimeField Ï† Ï†s)) := by
        rw [ofFieldOpList, timeOrder_eq_Î¹_timeOrderF, timeOrderF_eq_maxTimeField_mul_finset]
        rfl
    declNo: "3.6"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder_timeOrder_mid
    line: 501
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean#L501"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, and `a`, `b`, `c` in `ğ“•.FieldOpAlgebra`, then
      `ğ“£(a * b * c) = ğ“£(a * ğ“£(b) * c)`.
    declString: |
      lemma timeOrder_timeOrder_mid (a b c : ğ“•.FieldOpAlgebra) :
          ğ“£(a * b * c) = ğ“£(a * ğ“£(b) * c) := by
        obtain âŸ¨a, rflâŸ© := Î¹_surjective a
        obtain âŸ¨b, rflâŸ© := Î¹_surjective b
        obtain âŸ¨c, rflâŸ© := Î¹_surjective c
        rw [â† map_mul, â† map_mul, timeOrder_eq_Î¹_timeOrderF, timeOrder_eq_Î¹_timeOrderF,
        â† map_mul, â† map_mul, timeOrder_eq_Î¹_timeOrderF, timeOrderF_timeOrderF_mid]
    declNo: "3.7"

  - type: h1
    sectionNo: 4
    content: "Normal ordering"

  - type: name
    name: FieldSpecification.normalOrderRel
    line: 17
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/NormalOrder.lean#L17"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `ğ“•.normalOrderRel` is a relation on `ğ“•.CrAnFieldOp`
      representing normal ordering. It is defined such that `ğ“•.normalOrderRel Ï†â‚€ Ï†â‚`
      is true if one of the following is true
      - `Ï†â‚€` is a field creation operator
      - `Ï†â‚` is a field annihilation operator.

      Thus, colloquially `ğ“•.normalOrderRel Ï†â‚€ Ï†â‚` says the creation operators are less than
      annihilation operators.
    declString: |
      def normalOrderRel : ğ“•.CrAnFieldOp â†’ ğ“•.CrAnFieldOp â†’ Prop :=
        fun a b => CreateAnnihilate.normalOrder (ğ“• |>á¶œ a) (ğ“• |>á¶œ b)
    declNo: "4.1"

  - type: name
    name: FieldSpecification.normalOrderList
    line: 225
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/NormalOrder.lean#L225"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and a list `Ï†s` of `ğ“•.CrAnFieldOp`,
      `ğ“•.normalOrderList Ï†s` is the list `Ï†s` normal-ordered using ther
      insertion sort algorithm. It puts creation operators on the left and annihilation operators on
      the right. For example:

      `ğ“•.normalOrderList [Ï†1c, Ï†1a, Ï†2c, Ï†2a] = [Ï†1c, Ï†2c, Ï†1a, Ï†2a]`

    declString: |
      def normalOrderList (Ï†s : List ğ“•.CrAnFieldOp) : List ğ“•.CrAnFieldOp :=
        List.insertionSort ğ“•.normalOrderRel Ï†s
    declNo: "4.2"

  - type: name
    name: FieldSpecification.normalOrderSign
    line: 46
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/NormalOrder.lean#L46"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and a list `Ï†s` of `ğ“•.CrAnFieldOp`, `ğ“•.normalOrderSign Ï†s` is the
      sign corresponding to the number of `fermionic`-`fermionic` exchanges undertaken to normal-order
      `Ï†s` using the insertion sort algorithm.
    declString: |
      def normalOrderSign (Ï†s : List ğ“•.CrAnFieldOp) : â„‚ :=
        Wick.koszulSign ğ“•.crAnStatistics ğ“•.normalOrderRel Ï†s
    declNo: "4.3"

  - type: name
    name: FieldSpecification.normalOrderSign_eraseIdx
    line: 347
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldSpecification/NormalOrder.lean#L347"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.CrAnFieldOp` and an `i < Ï†s.length`,
      then
      `normalOrderSign (Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚â€¦Ï†â‚™)` is equal to the product of
      - `normalOrderSign Ï†â‚€â€¦Ï†â‚™`,
      - `ğ“¢(Ï†áµ¢, Ï†â‚€â€¦Ï†áµ¢â‚‹â‚)` i.e. the sign needed to remove `Ï†áµ¢` from `Ï†â‚€â€¦Ï†â‚™`,
      - `ğ“¢(Ï†áµ¢, _)` where `_` is the list of elements appearing before `Ï†áµ¢` after normal ordering,
        i.e.
        the sign needed to insert `Ï†áµ¢` back into the normal-ordered list at the correct place.
    declString: |
      lemma normalOrderSign_eraseIdx (Ï†s : List ğ“•.CrAnFieldOp) (i : Fin Ï†s.length) :
          normalOrderSign (Ï†s.eraseIdx i) = normalOrderSign Ï†s *
          ğ“¢(ğ“• |>â‚› (Ï†s.get i), ğ“• |>â‚› (Ï†s.take i)) *
          ğ“¢(ğ“• |>â‚› (Ï†s.get i), ğ“• |>â‚› ((normalOrderList Ï†s).take (normalOrderEquiv i))) := by
        rw [normalOrderSign, Wick.koszulSign_eraseIdx, â† normalOrderSign]
        rfl
    declNo: "4.4"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.normalOrderF
    line: 30
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpFreeAlgebra/NormalOrder.lean#L30"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `normalOrderF` is the linear map

      `FieldOpFreeAlgebra ğ“• â†’â‚—[â„‚] FieldOpFreeAlgebra ğ“•`

      defined by its action on the basis `ofCrAnListF Ï†s`, taking `ofCrAnListF Ï†s` to

      `normalOrderSign Ï†s â€¢ ofCrAnListF (normalOrderList Ï†s)`.

      That is, `normalOrderF` normal-orders the field operators and multiplies by the sign of the
      normal order.

      The notation `ğ“á¶ (a)` is used for `normalOrderF a` for `a` an element of
      `FieldOpFreeAlgebra ğ“•`.
    declString: |
      def normalOrderF : FieldOpFreeAlgebra ğ“• â†’â‚—[â„‚] FieldOpFreeAlgebra ğ“• :=
        Basis.constr ofCrAnListFBasis â„‚ fun Ï†s =>
        normalOrderSign Ï†s â€¢ ofCrAnListF (normalOrderList Ï†s)
    declNo: "4.5"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder
    line: 222
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Basic.lean#L222"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `normalOrder` is the linear map

      `FieldOpAlgebra ğ“• â†’â‚—[â„‚] FieldOpAlgebra ğ“•`

      defined as the descent of `Î¹ âˆ˜â‚— normalOrderF : FieldOpFreeAlgebra ğ“• â†’â‚—[â„‚] FieldOpAlgebra ğ“•`
      from `FieldOpFreeAlgebra ğ“•` to `FieldOpAlgebra ğ“•`.
      This descent exists because `Î¹ âˆ˜â‚— normalOrderF` is well-defined on equivalence classes.

      The notation `ğ“(a)` is used for `normalOrder a` for `a` an element of `FieldOpAlgebra ğ“•`.
    declString: |
      noncomputable def normalOrder : FieldOpAlgebra ğ“• â†’â‚—[â„‚] FieldOpAlgebra ğ“• where
        toFun := Quotient.lift (Î¹.toLinearMap âˆ˜â‚— normalOrderF) Î¹_normalOrderF_eq_of_equiv
        map_add' x y := by
          obtain âŸ¨x, rflâŸ© := Î¹_surjective x
          obtain âŸ¨y, rflâŸ© := Î¹_surjective y
          rw [â† map_add, Î¹_apply, Î¹_apply, Î¹_apply]
          rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]
          simp
        map_smul' c y := by
          obtain âŸ¨y, rflâŸ© := Î¹_surjective y
          rw [â† map_smul, Î¹_apply, Î¹_apply]
          simp
    declNo: "4.6"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder_superCommute_eq_zero
    line: 121
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean#L121"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, and `a` and `b` in `ğ“•.FieldOpAlgebra` the normal ordering
      of the super commutator of `a` and `b` vanishes, i.e. `ğ“([a,b]â‚›) = 0`.
    declString: |
      lemma normalOrder_superCommute_eq_zero (a b : ğ“•.FieldOpAlgebra) :
          ğ“([a, b]â‚›) = 0 := by
        obtain âŸ¨a, rflâŸ© := Î¹_surjective a
        obtain âŸ¨b, rflâŸ© := Î¹_surjective b
        rw [superCommute_eq_Î¹_superCommuteF, normalOrder_eq_Î¹_normalOrderF]
        simp
    declNo: "4.7"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum
    line: 221
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean#L221"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, an element `Ï†` of `ğ“•.CrAnFieldOp`, a list `Ï†s` of `ğ“•.CrAnFieldOp`,
        the following relation holds

      `[Ï†, ğ“(Ï†â‚€â€¦Ï†â‚™)]â‚› = âˆ‘ i, ğ“¢(Ï†, Ï†â‚€â€¦Ï†áµ¢â‚‹â‚) â€¢ [Ï†, Ï†áµ¢]â‚› * ğ“(Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚â€¦Ï†â‚™)`.

      The proof of this result ultimately goes as follows
      - The definition of `normalOrder` is used to rewrite `ğ“(Ï†â‚€â€¦Ï†â‚™)` as a scalar multiple of
        a `ofCrAnList Ï†sn` where `Ï†sn` is the normal ordering of `Ï†â‚€â€¦Ï†â‚™`.
      - `superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum` is used to rewrite the super commutator of `Ï†`
        (considered as a list with one element) with
        `ofCrAnList Ï†sn` as a sum of super commutators, one for each element of `Ï†sn`.
      - The fact that super-commutators are in the center of `ğ“•.FieldOpAlgebra` is used to rearrange
        terms.
      - Properties of ordered lists, and `normalOrderSign_eraseIdx` are then used to complete the proof.

    declString: |
      lemma ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum (Ï† : ğ“•.CrAnFieldOp)
          (Ï†s : List ğ“•.CrAnFieldOp) : [ofCrAnOp Ï†, ğ“(ofCrAnList Ï†s)]â‚› = âˆ‘ n : Fin Ï†s.length,
          ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› (Ï†s.take n)) â€¢ [ofCrAnOp Ï†, ofCrAnOp Ï†s[n]]â‚›
          * ğ“(ofCrAnList (Ï†s.eraseIdx n)) := by
        rw [normalOrder_ofCrAnList, map_smul]
        rw [superCommute_ofCrAnOp_ofCrAnList_eq_sum, Finset.smul_sum,
          sum_normalOrderList_length]
        congr
        funext n
        simp only [instCommGroup.eq_1, List.get_eq_getElem, normalOrderList_get_normalOrderEquiv,
          normalOrderList_eraseIdx_normalOrderEquiv, Algebra.smul_mul_assoc, Fin.getElem_fin]
        rw [ofCrAnList_eq_normalOrder, mul_smul_comm, smul_smul, smul_smul]
        by_cases hs : (ğ“• |>â‚› Ï†) = (ğ“• |>â‚› Ï†s[n])
        Â· congr
          erw [normalOrderSign_eraseIdx, â† hs]
          trans (normalOrderSign Ï†s * normalOrderSign Ï†s) *
            (ğ“¢(ğ“• |>â‚› (Ï†s.get n), ğ“• |>â‚› ((normalOrderList Ï†s).take (normalOrderEquiv n))) *
            ğ“¢(ğ“• |>â‚› (Ï†s.get n), ğ“• |>â‚› ((normalOrderList Ï†s).take (normalOrderEquiv n))))
            * ğ“¢(ğ“• |>â‚› (Ï†s.get n), ğ“• |>â‚› (Ï†s.take n))
          Â· ring_nf
            rw [hs]
            rfl
          Â· simp [hs]
        Â· erw [superCommute_diff_statistic hs]
          simp
    declNo: "4.8"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum
    line: 347
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean#L347"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, a `Ï†` in `ğ“•.FieldOp` and a list `Ï†s` of `ğ“•.FieldOp`
      then `Ï† * ğ“(Ï†â‚€Ï†â‚â€¦Ï†â‚™)` is equal to

      `ğ“(Ï†Ï†â‚€Ï†â‚â€¦Ï†â‚™) + âˆ‘ i, (ğ“¢(Ï†,Ï†â‚€Ï†â‚â€¦Ï†áµ¢â‚‹â‚) â€¢ [anPart Ï†, Ï†áµ¢]â‚›) * ğ“(Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚â€¦Ï†â‚™)`.

      The proof ultimately goes as follows:
      - `ofFieldOp_eq_crPart_add_anPart` is used to split `Ï†` into its creation and annihilation parts.
      - The following relation is then used

        `crPart Ï† * ğ“(Ï†â‚€Ï†â‚â€¦Ï†â‚™) = ğ“(crPart Ï† * Ï†â‚€Ï†â‚â€¦Ï†â‚™)`.

      - It used that `anPart Ï† * ğ“(Ï†â‚€Ï†â‚â€¦Ï†â‚™)` is equal to

        `ğ“¢(Ï†, Ï†â‚€Ï†â‚â€¦Ï†â‚™) ğ“(Ï†â‚€Ï†â‚â€¦Ï†â‚™) * anPart Ï† + [anPart Ï†, ğ“(Ï†â‚€Ï†â‚â€¦Ï†â‚™)]`

      - Then it is used that

        `ğ“¢(Ï†, Ï†â‚€Ï†â‚â€¦Ï†â‚™) ğ“(Ï†â‚€Ï†â‚â€¦Ï†â‚™) * anPart Ï† = ğ“(anPart Ï† * Ï†â‚€Ï†â‚â€¦Ï†â‚™)`

      - The result `ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum` is used
        to expand `[anPart Ï†, ğ“(Ï†â‚€Ï†â‚â€¦Ï†â‚™)]` as a sum.

    declString: |
      lemma ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp) :
          ofFieldOp Ï† * ğ“(ofFieldOpList Ï†s) =
          âˆ‘ n : Option (Fin Ï†s.length), contractStateAtIndex Ï† Ï†s n *
          ğ“(ofFieldOpList (optionEraseZ Ï†s Ï† n)) := by
        rw [ofFieldOp_mul_normalOrder_ofFieldOpList_eq_superCommute]
        rw [anPart_superCommute_normalOrder_ofFieldOpList_sum]
        simp only [instCommGroup.eq_1, Fin.getElem_fin, Algebra.smul_mul_assoc, contractStateAtIndex,
          Fintype.sum_option, one_mul]
        rfl
    declNo: "4.9"

  - type: h1
    sectionNo: 5
    content: "Wick Contractions"

  - type: h2
    sectionNo: "5.1"
    content: "Definition"

  - type: name
    name: WickContraction
    line: 16
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Basic.lean#L16"
    isDef: true
    isThm: false
    docString: |
      Given a natural number `n`, which will correspond to the number of fields needing
      contracting, a Wick contraction
      is a finite set of pairs of `Fin n` (numbers `0`, ..., `n-1`), such that no
      element of `Fin n` occurs in more than one pair. The pairs are the positions of fields we
      'contract' together.

    declString: |
      def WickContraction (n : â„•) : Type :=
        {f : Finset ((Finset (Fin n))) // (âˆ€ a âˆˆ f, a.card = 2) âˆ§
          (âˆ€ a âˆˆ f, âˆ€ b âˆˆ f, a = b âˆ¨ Disjoint a b)}
    declNo: "5.1"

  - type: name
    name: WickContraction.mem_three
    line: 110
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.ExtractEquiv
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/ExtractEquiv.lean#L110"
    isDef: false
    isThm: false
    docString: |
      For `n = 3` there are `4` possible Wick contractions:

      - `âˆ…`, corresponding to the case where no fields are contracted.
      - `{{0, 1}}`, corresponding to the case where the field at position `0` and `1` are contracted.
      - `{{0, 2}}`, corresponding to the case where the field at position `0` and `2` are contracted.
      - `{{1, 2}}`, corresponding to the case where the field at position `1` and `2` are contracted.

      The proof of this result uses the fact that Lean is an executable programming language
      and can calculate all Wick contractions for a given `n`.
    declString: |
      lemma mem_three (c : WickContraction 3) : c.1 âˆˆ ({âˆ…, {{0, 1}}, {{0, 2}}, {{1, 2}}} :
          Finset (Finset (Finset (Fin 3)))) := by
        fin_cases c <;>
          simp only [Fin.isValue, Nat.succ_eq_add_one, Nat.reduceAdd, Function.Embedding.coeFn_mk,
            Finset.mem_insert, Finset.mem_singleton]
        Â· exact Or.inl rfl
        Â· exact Or.inr (Or.inl rfl)
        Â· exact Or.inr (Or.inr (Or.inl rfl))
        Â· exact Or.inr (Or.inr (Or.inr rfl))
    declNo: "5.2"

  - type: name
    name: WickContraction.mem_four
    line: 129
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.ExtractEquiv
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/ExtractEquiv.lean#L129"
    isDef: false
    isThm: false
    docString: |
      For `n = 4` there are `10` possible Wick contractions including e.g.

      - `âˆ…`, corresponding to the case where no fields are contracted.
      - `{{0, 1}, {2, 3}}`, corresponding to the case where the fields at position `0` and `1` are
        contracted, and the fields at position `2` and `3` are contracted.
      - `{{0, 2}, {1, 3}}`, corresponding to the case where the fields at position `0` and `2` are
        contracted, and the fields at position `1` and `3` are contracted.

      The proof of this result uses the fact that Lean is an executable programming language
      and can calculate all Wick contractions for a given `n`.

    declString: |
      lemma mem_four (c : WickContraction 4) : c.1 âˆˆ ({âˆ…,
          {{0, 1}}, {{0, 2}}, {{0, 3}}, {{1, 2}}, {{1, 3}}, {{2,3}},
          {{0, 1}, {2, 3}}, {{0, 2}, {1, 3}}, {{0, 3}, {1, 2}}} :
          Finset (Finset (Finset (Fin 4)))) := by
        fin_cases c <;>
          simp only [Fin.isValue, Nat.succ_eq_add_one, Nat.reduceAdd, Function.Embedding.coeFn_mk,
            Finset.mem_insert, Finset.mem_singleton]
        Â· exact Or.inl rfl -- âˆ…
        Â· exact Or.inr (Or.inl rfl) -- {{0, 1}}
        Â· exact Or.inr (Or.inr (Or.inl rfl)) -- {{0, 2}}
        Â· exact Or.inr (Or.inr (Or.inr (Or.inl rfl))) -- {{0, 3}}
        Â· exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl)))) -- {{1, 2}}
        Â· exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr rfl))))))))
        Â· exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl))))) -- {{1, 3}}
        Â· exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl))))))))
        Â· exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl)))))) -- {{2, 3 }}
        Â· exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl)))))))
    declNo: "5.3"

  - type: remark
    name: "contraction_notation"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Basic.lean#L31"
    content: |
      Given a field specification `ğ“•`, and a list `Ï†s`
        of `ğ“•.FieldOp`, a Wick contraction of `Ï†s` will mean a Wick contraction in
        `WickContraction Ï†s.length`. The notation `Ï†sÎ›` will be used for such contractions.
        The terminology that `Ï†sÎ›` contracts pairs within of `Ï†s` will also be used, even though
        `Ï†sÎ›` is really contains positions of `Ï†s`.

  - type: name
    name: WickContraction.GradingCompliant
    line: 520
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Basic.lean#L520"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, `Ï†s` a list of `ğ“•.FieldOp` and a Wick contraction
      `Ï†sÎ›` of `Ï†s`, the Wick contraction `Ï†sÎ›` is said to be `GradingCompliant` if
      for every pair in `Ï†sÎ›` the contracted fields are either both `fermionic` or both `bosonic`.
      In other words, in a `GradingCompliant` Wick contraction if
      no contracted pairs occur between `fermionic` and `bosonic` fields.
    declString: |
      def GradingCompliant (Ï†s : List ğ“•.FieldOp) (Ï†sÎ› : WickContraction Ï†s.length) :=
        âˆ€ (a : Ï†sÎ›.1), (ğ“• |>â‚› Ï†s[Ï†sÎ›.fstFieldOfContract a]) = (ğ“• |>â‚› Ï†s[Ï†sÎ›.sndFieldOfContract a])
    declNo: "5.4"

  - type: h2
    sectionNo: "5.2"
    content: "Aside: Cardinality"

  - type: name
    name: WickContraction.card_eq_cardFun
    line: 240
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Card
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Card.lean#L240"
    isDef: false
    isThm: true
    docString: |
      The number of Wick contractions in `WickContraction n` is equal to the terms in
      Online Encyclopedia of Integer Sequences (OEIS) A000085. That is:
      1, 1, 2, 4, 10, 26, 76, 232, 764, 2620, 9496, ...
    declString: |
      theorem card_eq_cardFun : (n : â„•) â†’ Fintype.card (WickContraction n) = cardFun n
        | 0 => by decide
        | 1 => by decide
        | Nat.succ (Nat.succ n) => by
          rw [wickContraction_card_eq_sum_zero_none_isSome, wickContraction_zero_none_card,
            wickContraction_zero_some_eq_mul]
          simp only [cardFun, succ_eq_add_one]
          rw [â† card_eq_cardFun n, â† card_eq_cardFun (n + 1)]
    declNo: "5.5"

  - type: h2
    sectionNo: "5.3"
    content: "Uncontracted elements"

  - type: name
    name: WickContraction.uncontracted
    line: 19
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Uncontracted
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Uncontracted.lean#L19"
    isDef: true
    isThm: false
    docString: |
      For a Wick contraction `c`, `c.uncontracted` is defined as the finset of elements of `Fin n`
      which are not in any contracted pair.
    declString: |
      def uncontracted : Finset (Fin n) := Finset.filter (fun i => c.getDual? i = none) (Finset.univ)
    declNo: "5.6"

  - type: name
    name: WickContraction.uncontractedListGet
    line: 317
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.UncontractedList
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/UncontractedList.lean#L317"
    isDef: true
    isThm: false
    docString: |
      Given a Wick Contraction `Ï†sÎ›` of a list `Ï†s` of `ğ“•.FieldOp`. The list
      `Ï†sÎ›.uncontractedListGet` of `ğ“•.FieldOp` is defined as the list `Ï†s` with
      all contracted positions removed, leaving the uncontracted `ğ“•.FieldOp`.

      The notation `[Ï†sÎ›]áµ˜á¶œ` is used for `Ï†sÎ›.uncontractedListGet`.
    declString: |
      def uncontractedListGet {Ï†s : List ğ“•.FieldOp} (Ï†sÎ› : WickContraction Ï†s.length) :
          List ğ“•.FieldOp := Ï†sÎ›.uncontractedList.map Ï†s.get
    declNo: "5.7"

  - type: h2
    sectionNo: "5.4"
    content: "Constructors"

  - type: name
    name: WickContraction.insertAndContract
    line: 27
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.InsertAndContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/InsertAndContract.lean#L27"
    isDef: true
    isThm: false
    docString: |
      Given a Wick contraction `Ï†sÎ›` for a list `Ï†s` of `ğ“•.FieldOp`,
      an element `Ï†` of `ğ“•.FieldOp`, an `i â‰¤ Ï†s.length` and a `k`
      in `Option Ï†sÎ›.uncontracted` i.e. is either `none` or
      some element of `Ï†sÎ›.uncontracted`, the new Wick contraction
      `Ï†sÎ›.insertAndContract Ï† i k` is defined by inserting `Ï†` into `Ï†s` after
      the first `i`-elements and moving the values representing the contracted pairs in `Ï†sÎ›`
      accordingly.
      If `k` is not `none`, but rather `some k`, to this contraction is added the contraction
      of `Ï†` (at position `i`) with the new position of `k` after `Ï†` is added.

      In other words, `Ï†sÎ›.insertAndContract Ï† i k` is formed by adding `Ï†` to `Ï†s` at position `i`,
      and contracting `Ï†` with the field originally at position `k` if `k` is not `none`.
      It is a Wick contraction of the list `Ï†s.insertIdx Ï† i` corresponding to `Ï†s` with `Ï†` inserted at
      position `i`.

      The notation `Ï†sÎ› â†©Î› Ï† i k` is used to denote `Ï†sÎ›.insertAndContract Ï† i k`.
    declString: |
      def insertAndContract {Ï†s : List ğ“•.FieldOp} (Ï† : ğ“•.FieldOp) (Ï†sÎ› : WickContraction Ï†s.length)
          (i : Fin Ï†s.length.succ) (k : Option Ï†sÎ›.uncontracted) :
          WickContraction (Ï†s.insertIdx i Ï†).length :=
        congr (by simp) (Ï†sÎ›.insertAndContractNat i k)
    declNo: "5.8"

  - type: name
    name: WickContraction.insertLift_sum
    line: 290
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.InsertAndContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/InsertAndContract.lean#L290"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
      `ğ“•.FieldOp` and a `i â‰¤ Ï†s.length` then a sum over
      Wick contractions of `Ï†s` with `Ï†` inserted at `i` is equal to the sum over Wick contractions
      `Ï†sÎ›` of just `Ï†s` and the sum over optional uncontracted elements of the `Ï†sÎ›`.

      In other words,

      `âˆ‘ (Ï†sÎ› : WickContraction (Ï†s.insertIdx i Ï†).length), f Ï†sÎ›`

      where `(Ï†s.insertIdx i Ï†)` is `Ï†s` with `Ï†` inserted at position `i`. is equal to

      `âˆ‘ (Ï†sÎ› : WickContraction Ï†s.length), âˆ‘ k, f (Ï†sÎ› â†©Î› Ï† i k) `.

      where the sum over `k` is over all `k` in `Option Ï†sÎ›.uncontracted`.
    declString: |
      lemma insertLift_sum (Ï† : ğ“•.FieldOp) {Ï†s : List ğ“•.FieldOp}
          (i : Fin Ï†s.length.succ) [AddCommMonoid M] (f : WickContraction (Ï†s.insertIdx i Ï†).length â†’ M) :
          âˆ‘ c, f c =
          âˆ‘ (Ï†sÎ› : WickContraction Ï†s.length), âˆ‘ (k : Option Ï†sÎ›.uncontracted), f (Ï†sÎ› â†©Î› Ï† i k) := by
        rw [sum_extractEquiv_congr (finCongr (insertIdx_length_fin Ï† Ï†s i).symm i) f
          (insertIdx_length_fin Ï† Ï†s i)]
        rfl
    declNo: "5.9"

  - type: name
    name: WickContraction.join
    line: 26
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Join
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Join.lean#L26"
    isDef: true
    isThm: false
    docString: |
      Given a list `Ï†s` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s` and a Wick contraction
      `Ï†sucÎ›` of `[Ï†sÎ›]áµ˜á¶œ`, `join Ï†sÎ› Ï†sucÎ›` is defined as the Wick contraction of `Ï†s` consisting of
      the contractions in `Ï†sÎ›` and those in `Ï†sucÎ›`.

      As an example, for `Ï†s = [Ï†1, Ï†2, Ï†3, Ï†4]`,
      `Ï†sÎ› = {{0, 1}}` corresponding to the contraction of `Ï†1` and `Ï†2` in `Ï†s` and
      `Ï†sucÎ› = {{0, 1}}`
      corresponding to the contraction of `Ï†3` and `Ï†4` in `[Ï†sÎ›]áµ˜á¶œ = [Ï†3, Ï†4]`, then
      `join Ï†sÎ› Ï†sucÎ›` is the contraction `{{0, 1}, {2, 3}}` of `Ï†s`.
    declString: |
      def join {Ï†s : List ğ“•.FieldOp} (Ï†sÎ› : WickContraction Ï†s.length)
          (Ï†sucÎ› : WickContraction [Ï†sÎ›]áµ˜á¶œ.length) : WickContraction Ï†s.length :=
        âŸ¨Ï†sÎ›.1 âˆª Ï†sucÎ›.1.map (Finset.mapEmbedding uncontractedListEmd).toEmbedding, by
          intro a ha
          simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,
            RelEmbedding.coe_toEmbedding] at ha
          rcases ha with ha | ha
          Â· exact Ï†sÎ›.2.1 a ha
          Â· obtain âŸ¨a, ha, rflâŸ© := ha
            rw [Finset.mapEmbedding_apply]
            simp only [Finset.card_map]
            exact Ï†sucÎ›.2.1 a ha, by
          intro a ha b hb
          simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,
            RelEmbedding.coe_toEmbedding] at ha hb
          rcases ha with ha | ha <;> rcases hb with hb | hb
          Â· exact Ï†sÎ›.2.2 a ha b hb
          Â· obtain âŸ¨b, hb, rflâŸ© := hb
            right
            symm
            rw [Finset.mapEmbedding_apply]
            apply uncontractedListEmd_finset_disjoint_left
            exact ha
          Â· obtain âŸ¨a, ha, rflâŸ© := ha
            right
            rw [Finset.mapEmbedding_apply]
            apply uncontractedListEmd_finset_disjoint_left
            exact hb
          Â· obtain âŸ¨a, ha, rflâŸ© := ha
            obtain âŸ¨b, hb, rflâŸ© := hb
            simp only [EmbeddingLike.apply_eq_iff_eq]
            rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]
            rw [Finset.disjoint_map]
            exact Ï†sucÎ›.2.2 a ha b hbâŸ©
    declNo: "5.10"

  - type: h2
    sectionNo: "5.5"
    content: "Sign"

  - type: name
    name: WickContraction.sign
    line: 32
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Sign/Basic.lean#L32"
    isDef: true
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, and a Wick contraction `Ï†sÎ›` of `Ï†s`,
        the complex number `Ï†sÎ›.sign` is defined to be the sign (`1` or `-1`) corresponding
        to the number of `fermionic`-`fermionic` exchanges that must be done to put
        contracted pairs within `Ï†sÎ›` next to one another, starting recursively
        from the contracted pair
        whose first element occurs at the left-most position.

        As an example, if `[Ï†1, Ï†2, Ï†3, Ï†4]` correspond to fermionic fields then the sign
        associated with
      - `{{0, 1}}` is `1`
      - `{{0, 1}, {2, 3}}` is `1`
      - `{{0, 2}, {1, 3}}` is `-1`

    declString: |
      def sign (Ï†s : List ğ“•.FieldOp) (Ï†sÎ› : WickContraction Ï†s.length) : â„‚ :=
        âˆ (a : Ï†sÎ›.1), ğ“¢(ğ“• |>â‚› Ï†s[Ï†sÎ›.sndFieldOfContract a],
          ğ“• |>â‚› âŸ¨Ï†s.get, Ï†sÎ›.signFinset (Ï†sÎ›.fstFieldOfContract a) (Ï†sÎ›.sndFieldOfContract a)âŸ©)
    declNo: "5.11"

  - type: name
    name: WickContraction.join_sign
    line: 420
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.Join
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Sign/Join.lean#L420"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, a grading compliant Wick contraction `Ï†sÎ›` of `Ï†s`,
      and a Wick contraction `Ï†sucÎ›` of `[Ï†sÎ›]áµ˜á¶œ`, the following relation holds
      `(join Ï†sÎ› Ï†sucÎ›).sign = Ï†sÎ›.sign * Ï†sucÎ›.sign`.

      In `Ï†sÎ›.sign` the sign is determined by starting with the contracted pair
      whose first element occurs at the left-most position. This lemma manifests that this
      choice does not matter, and that contracted pairs can be brought together in any order.
    declString: |
      lemma join_sign {Ï†s : List ğ“•.FieldOp} (Ï†sÎ› : WickContraction Ï†s.length)
          (Ï†sucÎ› : WickContraction [Ï†sÎ›]áµ˜á¶œ.length) (hc : Ï†sÎ›.GradingCompliant) :
          (join Ï†sÎ› Ï†sucÎ›).sign = Ï†sÎ›.sign * Ï†sucÎ›.sign :=
        join_sign_induction Ï†sÎ› Ï†sucÎ› hc (Ï†sÎ›).1.card rfl
    declNo: "5.12"

  - type: name
    name: WickContraction.sign_insert_none
    line: 241
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertNone
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Sign/InsertNone.lean#L241"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a graded compliant Wick contraction `Ï†sÎ›` of `Ï†s`,
      an `i â‰¤ Ï†s.length`, and a `Ï†` in `ğ“•.FieldOp`, then
      `(Ï†sÎ› â†©Î› Ï† i none).sign = s * Ï†sÎ›.sign`
      where `s` is the sign arrived at by moving `Ï†` through the elements of `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚` which
      are contracted with some element.

      The proof of this result involves a careful consideration of the contributions of different
      `FieldOp`s in `Ï†s` to the sign of `Ï†sÎ› â†©Î› Ï† i none`.
    declString: |
      lemma sign_insert_none (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (i : Fin Ï†s.length.succ) (hG : GradingCompliant Ï†s Ï†sÎ›) :
          (Ï†sÎ› â†©Î› Ï† i none).sign = ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, Finset.univ.filter
          (fun x => (Ï†sÎ›.getDual? x).isSome âˆ§ i.succAbove x < i)âŸ©) * Ï†sÎ›.sign := by
        rw [sign_insert_none_eq_signInsertNone_mul_sign]
        rw [signInsertNone_eq_filterset]
        exact hG
    declNo: "5.13"

  - type: name
    name: WickContraction.sign_insert_none_zero
    line: 257
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertNone
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Sign/InsertNone.lean#L257"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a graded compliant Wick contraction `Ï†sÎ›` of `Ï†s`,
      and a `Ï†` in `ğ“•.FieldOp`, then `(Ï†sÎ› â†©Î› Ï† 0 none).sign = Ï†sÎ›.sign`.

      This is a direct corollary of `sign_insert_none`.
    declString: |
      lemma sign_insert_none_zero (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) : (Ï†sÎ› â†©Î› Ï† 0 none).sign = Ï†sÎ›.sign := by
        rw [sign_insert_none_eq_signInsertNone_mul_sign]
        simp [signInsertNone]
    declNo: "5.14"

  - type: name
    name: WickContraction.sign_insert_some_of_not_lt
    line: 882
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertSome
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Sign/InsertSome.lean#L882"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
        `ğ“•.FieldOp`, a `i â‰¤ Ï†s.length` and a `k` in `Ï†sÎ›.uncontracted` such that `i â‰¤ k`,
      the sign of `Ï†sÎ› â†©Î› Ï† i (some k)` is equal to the product of
      - the sign associated with moving `Ï†` through the `Ï†sÎ›`-uncontracted `FieldOp` in `Ï†â‚€â€¦Ï†â‚–â‚‹â‚`,
      - the sign associated with moving `Ï†` through all the `FieldOp` in `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚`,
      - the sign of `Ï†sÎ›`.

      The proof of this result involves a careful consideration of the contributions of different
      `FieldOp` in `Ï†s` to the sign of `Ï†sÎ› â†©Î› Ï† i (some k)`.

    declString: |
      lemma sign_insert_some_of_not_lt (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (i : Fin Ï†s.length.succ) (k : Ï†sÎ›.uncontracted)
          (hk : Â¬ i.succAbove k < i) (hg : GradingCompliant Ï†s Ï†sÎ› âˆ§ (ğ“• |>â‚› Ï†) = ğ“• |>â‚› Ï†s[k.1]) :
          (Ï†sÎ› â†©Î› Ï† i (some k)).sign =
          ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, Ï†sÎ›.uncontracted.filter (fun x => x < â†‘k)âŸ©)
          * ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, Finset.univ.filter (fun x => i.succAbove x < i)âŸ©) *
          Ï†sÎ›.sign := by
        rw [sign_insert_some,
          â† signInsertSome_mul_filter_contracted_of_not_lt Ï† Ï†s Ï†sÎ› i k hk hg]
        rw [â† mul_assoc]
        congr 1
        rw [mul_comm, â† mul_assoc]
        simp
    declNo: "5.15"

  - type: name
    name: WickContraction.sign_insert_some_of_lt
    line: 857
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertSome
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Sign/InsertSome.lean#L857"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
        `ğ“•.FieldOp`, a `i â‰¤ Ï†s.length` and a `k` in `Ï†sÎ›.uncontracted` such that `k<i`,
      the sign of `Ï†sÎ› â†©Î› Ï† i (some k)` is equal to the product of
      - the sign associated with moving `Ï†` through the `Ï†sÎ›`-uncontracted `FieldOp` in `Ï†â‚€â€¦Ï†â‚–`,
      - the sign associated with moving `Ï†` through all `FieldOp` in `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚`,
      - the sign of `Ï†sÎ›`.

      The proof of this result involves a careful consideration of the contributions of different
      `FieldOp` in `Ï†s` to the sign of `Ï†sÎ› â†©Î› Ï† i (some k)`.

    declString: |
      lemma sign_insert_some_of_lt (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (i : Fin Ï†s.length.succ) (k : Ï†sÎ›.uncontracted)
          (hk : i.succAbove k < i) (hg : GradingCompliant Ï†s Ï†sÎ› âˆ§ (ğ“• |>â‚› Ï†) = ğ“• |>â‚› Ï†s[k.1]) :
          (Ï†sÎ› â†©Î› Ï† i (some k)).sign =
          ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, Ï†sÎ›.uncontracted.filter (fun x => x â‰¤ â†‘k)âŸ©)
          * ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, Finset.univ.filter (fun x => i.succAbove x < i)âŸ©)
          * Ï†sÎ›.sign := by
        rw [sign_insert_some,
          â† signInsertSome_mul_filter_contracted_of_lt Ï† Ï†s Ï†sÎ› i k hk hg]
        rw [â† mul_assoc]
        congr 1
        rw [mul_comm, â† mul_assoc]
        simp
    declNo: "5.16"

  - type: name
    name: WickContraction.sign_insert_some_zero
    line: 907
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertSome
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Sign/InsertSome.lean#L907"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
        `ğ“•.FieldOp`, and a `k` in `Ï†sÎ›.uncontracted`,
      the sign of `Ï†sÎ› â†©Î› Ï† 0 (some k)` is equal to the product of
      - the sign associated with moving `Ï†` through the `Ï†sÎ›`-uncontracted `FieldOp` in `Ï†â‚€â€¦Ï†â‚–â‚‹â‚`,
      - the sign of `Ï†sÎ›`.

      This is a direct corollary of `sign_insert_some_of_not_lt`.

    declString: |
      lemma sign_insert_some_zero (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (k : Ï†sÎ›.uncontracted)
          (hn : GradingCompliant Ï†s Ï†sÎ› âˆ§ (ğ“•|>â‚›Ï†) = ğ“•|>â‚›Ï†s[k.1]) :
          (Ï†sÎ› â†©Î› Ï† 0 k).sign = ğ“¢(ğ“•|>â‚›Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, (Ï†sÎ›.uncontracted.filter (fun x => x < â†‘k))âŸ©) *
          Ï†sÎ›.sign := by
        rw [sign_insert_some_of_not_lt]
        Â· simp
        Â· simp
        Â· exact hn
    declNo: "5.17"

  - type: h2
    sectionNo: "5.6"
    content: "Normal order"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder_uncontracted_none
    line: 28
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.WickContractions
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/WickContractions.lean#L28"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
      `ğ“•.FieldOp`, and a `i â‰¤ Ï†s.length`, then the following relation holds:

      `ğ“([Ï†sÎ› â†©Î› Ï† i none]áµ˜á¶œ) = s â€¢ ğ“(Ï† :: [Ï†sÎ›]áµ˜á¶œ)`

      where `s` is the exchange sign for `Ï†` and the uncontracted fields in `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚`.

      The proof of this result ultimately is a consequence of `normalOrder_superCommute_eq_zero`.

    declString: |
      lemma normalOrder_uncontracted_none (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (i : Fin Ï†s.length.succ) (Ï†sÎ› : WickContraction Ï†s.length) :
          ğ“(ofFieldOpList [Ï†sÎ› â†©Î› Ï† i none]áµ˜á¶œ)
          = ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, Ï†sÎ›.uncontracted.filter (fun x => i.succAbove x < i)âŸ©) â€¢
          ğ“(ofFieldOpList (Ï† :: [Ï†sÎ›]áµ˜á¶œ)) := by
        simp only [Nat.succ_eq_add_one, instCommGroup.eq_1]
        rw [ofFieldOpList_normalOrder_insert Ï† [Ï†sÎ›]áµ˜á¶œ
          âŸ¨(Ï†sÎ›.uncontractedListOrderPos i), by simp [uncontractedListGet]âŸ©, smul_smul]
        trans (1 : â„‚) â€¢ (ğ“(ofFieldOpList [Ï†sÎ› â†©Î› Ï† i none]áµ˜á¶œ))
        Â· simp
        congr 1
        simp only [instCommGroup.eq_1, uncontractedListGet]
        rw [â† List.map_take, take_uncontractedListOrderPos_eq_filter]
        have h1 : (ğ“• |>â‚› List.map Ï†s.get (List.filter (fun x => decide (â†‘x < i.1)) Ï†sÎ›.uncontractedList))
              = ğ“• |>â‚› âŸ¨Ï†s.get, (Ï†sÎ›.uncontracted.filter (fun x => x.val < i.1))âŸ© := by
            simp only [Nat.succ_eq_add_one, ofFinset]
            congr
            rw [uncontractedList_eq_sort]
            have hdup : (List.filter (fun x => decide (x.1 < i.1))
                (Finset.sort (fun x1 x2 => x1 â‰¤ x2) Ï†sÎ›.uncontracted)).Nodup := by
              exact List.Nodup.filter _ (Finset.sort_nodup (fun x1 x2 => x1 â‰¤ x2) Ï†sÎ›.uncontracted)
            have hsort : (List.filter (fun x => decide (x.1 < i.1))
                (Finset.sort (fun x1 x2 => x1 â‰¤ x2) Ï†sÎ›.uncontracted)).Sorted (Â· â‰¤ Â·) := by
              exact List.Sorted.filter _ (Finset.sort_sorted (fun x1 x2 => x1 â‰¤ x2) Ï†sÎ›.uncontracted)
            rw [â† (List.toFinset_sort (Â· â‰¤ Â·) hdup).mpr hsort]
            congr
            ext a
            simp
        rw [h1]
        simp only [Nat.succ_eq_add_one]
        have h2 : (Finset.filter (fun x => x.1 < i.1) Ï†sÎ›.uncontracted) =
          (Finset.filter (fun x => i.succAbove x < i) Ï†sÎ›.uncontracted) := by
          ext a
          simp only [Nat.succ_eq_add_one, Finset.mem_filter, and_congr_right_iff]
          intro ha
          simp only [Fin.succAbove]
          split
          Â· apply Iff.intro
            Â· intro h
              omega
            Â· intro h
              rename_i h
              rw [Fin.lt_def] at h
              simp only [Fin.coe_castSucc] at h
              omega
          Â· apply Iff.intro
            Â· intro h
              rename_i h'
              rw [Fin.lt_def]
              simp only [Fin.val_succ]
              rw [Fin.lt_def] at h'
              simp only [Fin.coe_castSucc, not_lt] at h'
              omega
            Â· intro h
              rename_i h
              rw [Fin.lt_def] at h
              simp only [Fin.val_succ] at h
              omega
        rw [h2]
        simp only [exchangeSign_mul_self]
        congr
        simp only [Nat.succ_eq_add_one]
        rw [insertAndContract_uncontractedList_none_map]
    declNo: "5.18"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder_uncontracted_some
    line: 101
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.WickContractions
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/WickContractions.lean#L101"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
      `ğ“•.FieldOp`, a `i â‰¤ Ï†s.length` and a `k` in `Ï†sÎ›.uncontracted`, then
      `ğ“([Ï†sÎ› â†©Î› Ï† i (some k)]áµ˜á¶œ)` is equal to the normal ordering of `[Ï†sÎ›]áµ˜á¶œ` with the `ğ“•.FieldOp`
      corresponding to `k` removed.

      The proof of this result ultimately is a consequence of definitions.

    declString: |
      lemma normalOrder_uncontracted_some (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (i : Fin Ï†s.length.succ) (Ï†sÎ› : WickContraction Ï†s.length) (k : Ï†sÎ›.uncontracted) :
          ğ“(ofFieldOpList [Ï†sÎ› â†©Î› Ï† i (some k)]áµ˜á¶œ)
          = ğ“(ofFieldOpList (optionEraseZ [Ï†sÎ›]áµ˜á¶œ Ï† ((uncontractedFieldOpEquiv Ï†s Ï†sÎ›) k))) := by
        simp only [Nat.succ_eq_add_one, insertAndContract, optionEraseZ, uncontractedFieldOpEquiv,
          Equiv.optionCongr_apply, Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply,
          Fin.coe_cast, uncontractedListGet]
        congr
        rw [congr_uncontractedList]
        erw [uncontractedList_extractEquiv_symm_some]
        simp only [Fin.coe_succAboveEmb, List.map_eraseIdx, List.map_map]
        congr
        conv_rhs => rw [get_eq_insertIdx_succAbove Ï† Ï†s i]
    declNo: "5.19"

  - type: h1
    sectionNo: 6
    content: "Static Wick's theorem"

  - type: h2
    sectionNo: "6.1"
    content: "Static contractions"

  - type: name
    name: WickContraction.staticContract
    line: 22
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.StaticContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/StaticContract.lean#L22"
    isDef: true
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp` and a Wick contraction `Ï†sÎ›`, the
      element of the center of `ğ“•.FieldOpAlgebra`, `Ï†sÎ›.staticContract` is defined as the product
      of `[anPart Ï†s[j], Ï†s[k]]â‚›` over contracted pairs `{j, k}` in `Ï†sÎ›`
      with `j < k`.
    declString: |
      noncomputable def staticContract {Ï†s : List ğ“•.FieldOp}
          (Ï†sÎ› : WickContraction Ï†s.length) :
          Subalgebra.center â„‚ ğ“•.FieldOpAlgebra :=
        âˆ (a : Ï†sÎ›.1), âŸ¨[anPart (Ï†s.get (Ï†sÎ›.fstFieldOfContract a)),
          ofFieldOp (Ï†s.get (Ï†sÎ›.sndFieldOfContract a))]â‚›,
            superCommute_anPart_ofFieldOp_mem_center _ _âŸ©
    declNo: "6.1"

  - type: name
    name: WickContraction.staticContract_insert_none
    line: 33
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.StaticContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/StaticContract.lean#L33"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
      `ğ“•.FieldOp`, and a `i â‰¤ Ï†s.length`, then the following relation holds:

      `(Ï†sÎ› â†©Î› Ï† i none).staticContract = Ï†sÎ›.staticContract`

      The proof of this result ultimately is a consequence of definitions.

    declString: |
      lemma staticContract_insert_none (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (i : Fin Ï†s.length.succ) :
          (Ï†sÎ› â†©Î› Ï† i none).staticContract = Ï†sÎ›.staticContract := by
        rw [staticContract, insertAndContract_none_prod_contractions]
        congr
        ext a
        simp
    declNo: "6.2"

  - type: name
    name: WickContraction.staticContract_insert_some
    line: 49
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.StaticContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/StaticContract.lean#L49"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
      `ğ“•.FieldOp`, a `i â‰¤ Ï†s.length` and a `k` in `Ï†sÎ›.uncontracted`, then
      `(Ï†sÎ› â†©Î› Ï† i (some k)).staticContract` is equal to the product of
      - `[anPart Ï†, Ï†s[k]]â‚›` if `i â‰¤ k` or `[anPart Ï†s[k], Ï†]â‚›` if `k < i`
      - `Ï†sÎ›.staticContract`.

      The proof of this result ultimately is a consequence of definitions.

    declString: |
      lemma staticContract_insert_some
          (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (i : Fin Ï†s.length.succ) (j : Ï†sÎ›.uncontracted) :
          (Ï†sÎ› â†©Î› Ï† i (some j)).staticContract =
          (if i < i.succAbove j then
            âŸ¨[anPart Ï†, ofFieldOp Ï†s[j.1]]â‚›, superCommute_anPart_ofFieldOp_mem_center _ _âŸ©
          else âŸ¨[anPart Ï†s[j.1], ofFieldOp Ï†]â‚›, superCommute_anPart_ofFieldOp_mem_center _ _âŸ©) *
          Ï†sÎ›.staticContract := by
        rw [staticContract, insertAndContract_some_prod_contractions]
        congr 1
        Â· simp only [Nat.succ_eq_add_one, insertAndContract_fstFieldOfContract_some_incl, finCongr_apply,
          List.get_eq_getElem, insertAndContract_sndFieldOfContract_some_incl, Fin.getElem_fin]
          split
          Â· simp
          Â· simp
        Â· congr
          ext a
          simp
    declNo: "6.3"

  - type: h2
    sectionNo: "6.2"
    content: "Static Wick terms"

  - type: name
    name: WickContraction.staticWickTerm
    line: 25
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L25"
    isDef: true
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, and a Wick contraction `Ï†sÎ›` of `Ï†s`, the element
      of `ğ“•.FieldOpAlgebra`, `Ï†sÎ›.staticWickTerm` is defined as

      `Ï†sÎ›.sign â€¢ Ï†sÎ›.staticContract * ğ“([Ï†sÎ›]áµ˜á¶œ)`.

      This is a term which appears in the static version Wick's theorem.
    declString: |
      def staticWickTerm {Ï†s : List ğ“•.FieldOp} (Ï†sÎ› : WickContraction Ï†s.length) : ğ“•.FieldOpAlgebra :=
        Ï†sÎ›.sign â€¢ Ï†sÎ›.staticContract * ğ“(ofFieldOpList [Ï†sÎ›]áµ˜á¶œ)
    declNo: "6.4"

  - type: name
    name: WickContraction.staticWickTerm_empty_nil
    line: 34
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L34"
    isDef: false
    isThm: false
    docString: |
      For the empty list `[]` of `ğ“•.FieldOp`, the `staticWickTerm` of the Wick contraction
      corresponding to the empty set `âˆ…` (the only Wick contraction of `[]`) is `1`.
    declString: |
      lemma staticWickTerm_empty_nil :
          staticWickTerm (empty (n := ([] : List ğ“•.FieldOp).length)) = 1 := by
        rw [staticWickTerm, uncontractedListGet, nil_zero_uncontractedList]
        simp [sign, empty, staticContract]
    declNo: "6.5"

  - type: name
    name: WickContraction.staticWickTerm_insert_zero_none
    line: 42
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L42"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, and an element `Ï†` of
        `ğ“•.FieldOp`, then `(Ï†sÎ› â†©Î› Ï† 0 none).staticWickTerm` is equal to

      `Ï†sÎ›.sign â€¢ Ï†sÎ›.staticWickTerm * ğ“(Ï† :: [Ï†sÎ›]áµ˜á¶œ)`

      The proof of this result relies on
      - `staticContract_insert_none` to rewrite the static contract.
      - `sign_insert_none_zero` to rewrite the sign.

    declString: |
      lemma staticWickTerm_insert_zero_none (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) :
          (Ï†sÎ› â†©Î› Ï† 0 none).staticWickTerm =
          Ï†sÎ›.sign â€¢ Ï†sÎ›.staticContract * ğ“(ofFieldOpList (Ï† :: [Ï†sÎ›]áµ˜á¶œ)) := by
        symm
        erw [staticWickTerm, sign_insert_none_zero]
        simp only [staticContract_insert_none, insertAndContract_uncontractedList_none_zero,
          Algebra.smul_mul_assoc]
    declNo: "6.6"

  - type: name
    name: WickContraction.staticWickTerm_insert_zero_some
    line: 61
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L61"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
        `ğ“•.FieldOp`, and a `k` in `Ï†sÎ›.uncontracted`, `(Ï†sÎ› â†©Î› Ï† 0 (some k)).wickTerm` is equal
        to the product of
      - the sign `ğ“¢(Ï†, Ï†â‚€â€¦Ï†áµ¢â‚‹â‚) `
      - the sign `Ï†sÎ›.sign`
      - `Ï†sÎ›.staticContract`
      - `s â€¢ [anPart Ï†, ofFieldOp Ï†s[k]]â‚›` where `s` is the sign associated with moving `Ï†` through
        uncontracted fields in `Ï†â‚€â€¦Ï†â‚–â‚‹â‚`
      - the normal ordering of `[Ï†sÎ›]áµ˜á¶œ` with the field operator `Ï†s[k]` removed.

      The proof of this result ultimately relies on
      - `staticContract_insert_some` to rewrite static contractions.
      - `normalOrder_uncontracted_some` to rewrite normal orderings.
      - `sign_insert_some_zero` to rewrite signs.

    declString: |
      lemma staticWickTerm_insert_zero_some (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (k : { x // x âˆˆ Ï†sÎ›.uncontracted }) :
          (Ï†sÎ› â†©Î› Ï† 0 k).staticWickTerm =
          sign Ï†s Ï†sÎ› â€¢ (â†‘Ï†sÎ›.staticContract *
          (contractStateAtIndex Ï† [Ï†sÎ›]áµ˜á¶œ ((uncontractedFieldOpEquiv Ï†s Ï†sÎ›) (some k)) *
          ğ“(ofFieldOpList (optionEraseZ [Ï†sÎ›]áµ˜á¶œ Ï† (uncontractedFieldOpEquiv Ï†s Ï†sÎ› k))))) := by
        symm
        rw [staticWickTerm, normalOrder_uncontracted_some]
        simp only [â† mul_assoc]
        rw [â† smul_mul_assoc]
        congr 1
        rw [staticContract_insert_some_of_lt]
        swap
        Â· simp
        rw [smul_smul]
        by_cases hn : GradingCompliant Ï†s Ï†sÎ› âˆ§ (ğ“•|>â‚›Ï†) = (ğ“•|>â‚› Ï†s[k.1])
        Â· congr 1
          swap
          Â· rw [Subalgebra.mem_center_iff.mp Ï†sÎ›.staticContract.2]
          Â· rw [sign_insert_some_zero _ _ _ _ hn, mul_comm, â† mul_assoc]
            simp
        Â· simp only [Fin.getElem_fin, not_and] at hn
          by_cases h0 : Â¬ GradingCompliant Ï†s Ï†sÎ›
          Â· rw [staticContract_of_not_gradingCompliant]
            simp only [ZeroMemClass.coe_zero, zero_mul, smul_zero, instCommGroup.eq_1, mul_zero]
            exact h0
          Â· simp_all only [Finset.mem_univ, not_not, instCommGroup.eq_1, forall_const]
            have h1 : contractStateAtIndex Ï† [Ï†sÎ›]áµ˜á¶œ (uncontractedFieldOpEquiv Ï†s Ï†sÎ› k) = 0 := by
              simp only [contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
                Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply,
                instCommGroup.eq_1, Fin.coe_cast, Fin.getElem_fin, smul_eq_zero]
              right
              simp only [uncontractedListGet, List.getElem_map,
                uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem]
              rw [superCommute_anPart_ofFieldOpF_diff_grade_zero]
              exact hn
            rw [h1]
            simp
    declNo: "6.7"

  - type: name
    name: WickContraction.mul_staticWickTerm_eq_sum
    line: 115
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L115"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, the following relation
      holds

      `Ï† * Ï†sÎ›.staticWickTerm = âˆ‘ k, (Ï†sÎ› â†©Î› Ï† 0 k).staticWickTerm`

      where the sum is over all `k` in `Option Ï†sÎ›.uncontracted`, so `k` is either `none` or `some k`.

      The proof proceeds as follows:
      - `ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum` is used to expand `Ï† ğ“([Ï†sÎ›]áµ˜á¶œ)` as
        a sum over `k` in `Option Ï†sÎ›.uncontracted` of terms involving `[anPart Ï†, Ï†s[k]]â‚›`.
      - Then `staticWickTerm_insert_zero_none` and `staticWickTerm_insert_zero_some` are
        used to equate terms.

    declString: |
      lemma mul_staticWickTerm_eq_sum (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) :
          ofFieldOp Ï† * Ï†sÎ›.staticWickTerm =
          âˆ‘ (k : Option Ï†sÎ›.uncontracted), (Ï†sÎ› â†©Î› Ï† 0 k).staticWickTerm := by
        trans (Ï†sÎ›.sign â€¢ Ï†sÎ›.staticContract * (ofFieldOp Ï† * normalOrder (ofFieldOpList [Ï†sÎ›]áµ˜á¶œ)))
        Â· have ht := Subalgebra.mem_center_iff.mp (Subalgebra.smul_mem (Subalgebra.center â„‚ _)
            (Ï†sÎ›.staticContract).2 Ï†sÎ›.sign)
          conv_rhs => rw [â† mul_assoc, â† ht]
          simp [mul_assoc, staticWickTerm]
        rw [ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum]
        rw [Finset.mul_sum]
        rw [uncontractedFieldOpEquiv_list_sum]
        refine Finset.sum_congr rfl (fun n _ => ?_)
        match n with
        | none =>
          simp only [contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
            Equiv.coe_trans, Option.map_none', one_mul, Algebra.smul_mul_assoc, Nat.succ_eq_add_one,
            Fin.zero_eta, Fin.val_zero, List.insertIdx_zero, staticContract_insert_none,
            insertAndContract_uncontractedList_none_zero]
          rw [staticWickTerm_insert_zero_none]
          simp only [Algebra.smul_mul_assoc]
          rfl
        | some n =>
          simp only [Algebra.smul_mul_assoc, Nat.succ_eq_add_one, Fin.zero_eta, Fin.val_zero,
            List.insertIdx_zero]
          rw [staticWickTerm_insert_zero_some]
    declNo: "6.8"

  - type: h2
    sectionNo: "6.3"
    content: "The Static Wick's theorem"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.static_wick_theorem
    line: 22
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTheorem
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/StaticWickTheorem.lean#L22"
    isDef: false
    isThm: true
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, the static version of Wick's theorem states that

      `Ï†s = âˆ‘ Ï†sÎ›, Ï†sÎ›.staticWickTerm`

      where the sum is over all Wick contraction `Ï†sÎ›`.

      The proof is via induction on `Ï†s`.
      - The base case `Ï†s = []` is handled by `staticWickTerm_empty_nil`.

      The inductive step works as follows:

      For the LHS:
      1. The proof considers `Ï†â‚€â€¦Ï†â‚™` as `Ï†â‚€(Ï†â‚â€¦Ï†â‚™)` and uses the induction hypothesis on `Ï†â‚â€¦Ï†â‚™`.
      2. This gives terms of the form `Ï† * Ï†sÎ›.staticWickTerm` on which
        `mul_staticWickTerm_eq_sum` is used where `Ï†sÎ›` is a Wick contraction of `Ï†â‚â€¦Ï†â‚™`,
        to rewrite terms as a sum over optional uncontracted elements of `Ï†sÎ›`

      On the LHS we now have a sum over Wick contractions `Ï†sÎ›` of `Ï†â‚â€¦Ï†â‚™` (from 1) and optional
      uncontracted elements of `Ï†sÎ›` (from 2)

      For the RHS:
      1. The sum over Wick contractions of `Ï†â‚€â€¦Ï†â‚™` on the RHS
        is split via `insertLift_sum` into a sum over Wick contractions `Ï†sÎ›` of `Ï†â‚â€¦Ï†â‚™` and
        sum over optional uncontracted elements of `Ï†sÎ›`.

      Both sides are now sums over the same thing and their terms equate by the nature of the
      lemmas used.


    declString: |
      theorem static_wick_theorem : (Ï†s : List ğ“•.FieldOp) â†’
          ofFieldOpList Ï†s = âˆ‘ (Ï†sÎ› : WickContraction Ï†s.length), Ï†sÎ›.staticWickTerm
        | [] => by
          simp only [ofFieldOpList, ofFieldOpListF_nil, map_one, List.length_nil]
          rw [sum_WickContraction_nil]
          rw [staticWickTerm_empty_nil]
        | Ï† :: Ï†s => by
          rw [ofFieldOpList_cons, static_wick_theorem Ï†s]
          rw [show (Ï† :: Ï†s) = Ï†s.insertIdx (âŸ¨0, Nat.zero_lt_succ Ï†s.lengthâŸ© : Fin Ï†s.length.succ) Ï†
            from rfl]
          conv_rhs => rw [insertLift_sum]
          rw [Finset.mul_sum]
          apply Finset.sum_congr rfl
          intro c _
          rw [mul_staticWickTerm_eq_sum]
          rfl
    declNo: "6.9"

  - type: h1
    sectionNo: 7
    content: "Wick's theorem"

  - type: h2
    sectionNo: "7.1"
    content: "Time contractions"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeContract
    line: 26
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeContraction
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/TimeContraction.lean#L26"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ğ“•`, and `Ï†` and `Ïˆ` elements of `ğ“•.FieldOp`, the element of
      `ğ“•.FieldOpAlgebra`, `timeContract Ï† Ïˆ` is defined to be `ğ“£(Ï†Ïˆ) - ğ“(Ï†Ïˆ)`.
    declString: |
      def timeContract (Ï† Ïˆ : ğ“•.FieldOp) : ğ“•.FieldOpAlgebra :=
          ğ“£(ofFieldOp Ï† * ofFieldOp Ïˆ) - ğ“(ofFieldOp Ï† * ofFieldOp Ïˆ)
    declNo: "7.1"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeContract_of_timeOrderRel
    line: 34
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeContraction
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/TimeContraction.lean#L34"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, and `Ï†` and `Ïˆ` elements of `ğ“•.FieldOp`, if
      `Ï†` and `Ïˆ` are time-ordered then

      `timeContract Ï† Ïˆ = [anPart Ï†, ofFieldOp Ïˆ]â‚›`.
    declString: |
      lemma timeContract_of_timeOrderRel (Ï† Ïˆ : ğ“•.FieldOp) (h : timeOrderRel Ï† Ïˆ) :
          timeContract Ï† Ïˆ = [anPart Ï†, ofFieldOp Ïˆ]â‚› := by
        conv_rhs =>
          rw [ofFieldOp_eq_crPart_add_anPart]
          rw [map_add, superCommute_anPart_anPart, superCommute_anPart_crPart]
        simp only [timeContract, instCommGroup.eq_1, Algebra.smul_mul_assoc, add_zero]
        rw [timeOrder_ofFieldOp_ofFieldOp_ordered h]
        rw [normalOrder_ofFieldOp_mul_ofFieldOp]
        simp only [instCommGroup.eq_1]
        rw [ofFieldOp_eq_crPart_add_anPart, ofFieldOp_eq_crPart_add_anPart]
        simp only [mul_add, add_mul]
        abel_nf
    declNo: "7.2"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeContract_of_not_timeOrderRel_expand
    line: 61
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeContraction
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/TimeContraction.lean#L61"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, and `Ï†` and `Ïˆ` elements of `ğ“•.FieldOp`, if
      `Ï†` and `Ïˆ` are not time-ordered then

      `timeContract Ï† Ïˆ = ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› Ïˆ) â€¢ [anPart Ïˆ, ofFieldOp Ï†]â‚›`.
    declString: |
      lemma timeContract_of_not_timeOrderRel_expand (Ï† Ïˆ : ğ“•.FieldOp) (h : Â¬ timeOrderRel Ï† Ïˆ) :
          timeContract Ï† Ïˆ = ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› Ïˆ) â€¢ [anPart Ïˆ, ofFieldOp Ï†]â‚› := by
        rw [timeContract_of_not_timeOrderRel _ _ h]
        rw [timeContract_of_timeOrderRel _ _ _]
        have h1 := IsTotal.total (r := ğ“•.timeOrderRel) Ï† Ïˆ
        simp_all
    declNo: "7.3"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeContract_mem_center
    line: 72
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeContraction
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/TimeContraction.lean#L72"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ğ“•`, and `Ï†` and `Ïˆ` elements of `ğ“•.FieldOp`, then
      `timeContract Ï† Ïˆ` is in the center of `ğ“•.FieldOpAlgebra`.
    declString: |
      lemma timeContract_mem_center (Ï† Ïˆ : ğ“•.FieldOp) :
          timeContract Ï† Ïˆ âˆˆ Subalgebra.center â„‚ ğ“•.FieldOpAlgebra := by
        by_cases h : timeOrderRel Ï† Ïˆ
        Â· rw [timeContract_of_timeOrderRel _ _ h]
          exact superCommute_anPart_ofFieldOp_mem_center Ï† Ïˆ
        Â· rw [timeContract_of_not_timeOrderRel _ _ h]
          refine Subalgebra.smul_mem (Subalgebra.center â„‚ _) ?_ ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› Ïˆ)
          rw [timeContract_of_timeOrderRel]
          exact superCommute_anPart_ofFieldOp_mem_center _ _
          have h1 := IsTotal.total (r := ğ“•.timeOrderRel) Ï† Ïˆ
          simp_all
    declNo: "7.4"

  - type: name
    name: WickContraction.timeContract
    line: 22
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/TimeContract.lean#L22"
    isDef: true
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp` and a Wick contraction `Ï†sÎ›` the
      element of the center of `ğ“•.FieldOpAlgebra`, `Ï†sÎ›.timeContract` is defined as the product
      of `timeContract Ï†s[j] Ï†s[k]` over contracted pairs `{j, k}` in `Ï†sÎ›`
      with `j < k`.
    declString: |
      noncomputable def timeContract {Ï†s : List ğ“•.FieldOp}
          (Ï†sÎ› : WickContraction Ï†s.length) :
          Subalgebra.center â„‚ ğ“•.FieldOpAlgebra :=
        âˆ (a : Ï†sÎ›.1), âŸ¨FieldOpAlgebra.timeContract
          (Ï†s.get (Ï†sÎ›.fstFieldOfContract a)) (Ï†s.get (Ï†sÎ›.sndFieldOfContract a)),
          timeContract_mem_center _ _âŸ©
    declNo: "7.5"

  - type: name
    name: WickContraction.timeContract_insert_none
    line: 33
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/TimeContract.lean#L33"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
      `ğ“•.FieldOp`, and a `i â‰¤ Ï†s.length` the following relation holds

      `(Ï†sÎ› â†©Î› Ï† i none).timeContract = Ï†sÎ›.timeContract`

      The proof of this result ultimately is a consequence of definitions.
    declString: |
      lemma timeContract_insert_none (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (i : Fin Ï†s.length.succ) :
          (Ï†sÎ› â†©Î› Ï† i none).timeContract = Ï†sÎ›.timeContract := by
        rw [timeContract, insertAndContract_none_prod_contractions]
        congr
        ext a
        simp
    declNo: "7.6"

  - type: name
    name: WickContraction.timeContract_insert_some_of_not_lt
    line: 126
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/TimeContract.lean#L126"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
      `ğ“•.FieldOp`, a `i â‰¤ Ï†s.length` and a `k` in `Ï†sÎ›.uncontracted` such that `k < i`, with the
      condition that `Ï†s[k]` does not have time greater or equal to `Ï†`, then
      `(Ï†sÎ› â†©Î› Ï† i (some k)).timeContract` is equal to the product of
      - `[anPart Ï†, Ï†s[k]]â‚›`
      - `Ï†sÎ›.timeContract`
      - the exchange sign of `Ï†` with the uncontracted fields in `Ï†â‚€â€¦Ï†â‚–â‚‹â‚`.
      - the exchange sign of `Ï†` with the uncontracted fields in `Ï†â‚€â€¦Ï†â‚–`.

      The proof of this result ultimately is a consequence of definitions and
      `timeContract_of_not_timeOrderRel_expand`.
    declString: |
      lemma timeContract_insert_some_of_not_lt
          (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (i : Fin Ï†s.length.succ) (k : Ï†sÎ›.uncontracted)
          (ht : Â¬ ğ“•.timeOrderRel Ï†s[k.1] Ï†) (hik : Â¬ i < i.succAbove k) :
          (Ï†sÎ› â†©Î› Ï† i (some k)).timeContract =
          ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, (Ï†sÎ›.uncontracted.filter (fun x => x â‰¤ k))âŸ©)
          â€¢ (contractStateAtIndex Ï† [Ï†sÎ›]áµ˜á¶œ
            ((uncontractedFieldOpEquiv Ï†s Ï†sÎ›) (some k)) * Ï†sÎ›.timeContract) := by
        rw [timeContract_insertAndContract_some]
        simp only [Nat.succ_eq_add_one, Fin.getElem_fin, ite_mul, instCommGroup.eq_1,
          contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
          Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply, Fin.coe_cast,
          List.getElem_map, uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem,
          Algebra.smul_mul_assoc, uncontractedListGet]
        simp only [hik, â†“reduceIte, MulMemClass.coe_mul]
        rw [timeContract_of_not_timeOrderRel, timeContract_of_timeOrderRel]
        simp only [instCommGroup.eq_1, Algebra.smul_mul_assoc, smul_smul]
        congr
        have h1 : ofList ğ“•.fieldOpStatistic (List.take (â†‘(Ï†sÎ›.uncontractedIndexEquiv.symm k))
            (List.map Ï†s.get Ï†sÎ›.uncontractedList))
            = (ğ“• |>â‚› âŸ¨Ï†s.get, (Finset.filter (fun x => x < k) Ï†sÎ›.uncontracted)âŸ©) := by
          simp only [ofFinset]
          congr
          rw [â† List.map_take]
          congr
          rw [take_uncontractedIndexEquiv_symm, filter_uncontractedList]
        rw [h1]
        trans ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, {k.1}âŸ©)
        Â· rw [exchangeSign_symm, ofFinset_singleton]
          simp
        rw [â† map_mul]
        congr
        rw [ofFinset_union]
        congr
        ext a
        simp only [Finset.mem_singleton, Finset.mem_sdiff, Finset.mem_union, Finset.mem_filter,
          Finset.mem_inter, not_and, not_lt, and_imp]
        apply Iff.intro
        Â· intro h
          subst h
          simp
        Â· intro h
          have h1 := h.1
          rcases h1 with h1 | h1
          Â· have h2' := h.2 h1.1 h1.2 h1.1
            omega
          Â· have h2' := h.2 h1.1 (by omega) h1.1
            omega
        have ht := IsTotal.total (r := timeOrderRel) Ï†s[k.1] Ï†
        simp_all only [Fin.getElem_fin, Nat.succ_eq_add_one, not_lt, false_or]
        exact ht
    declNo: "7.7"

  - type: name
    name: WickContraction.timeContract_insert_some_of_lt
    line: 82
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/TimeContract.lean#L82"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
      `ğ“•.FieldOp`, a `i â‰¤ Ï†s.length` and a `k` in `Ï†sÎ›.uncontracted` such that `i â‰¤ k`, with the
      condition that `Ï†` has greater or equal time to `Ï†s[k]`, then
      `(Ï†sÎ› â†©Î› Ï† i (some k)).timeContract` is equal to the product of
      - `[anPart Ï†, Ï†s[k]]â‚›`
      - `Ï†sÎ›.timeContract`
      - two copies of the exchange sign of `Ï†` with the uncontracted fields in `Ï†â‚€â€¦Ï†â‚–â‚‹â‚`.
        These two exchange signs cancel each other out but are included for convenience.

      The proof of this result ultimately is a consequence of definitions and
      `timeContract_of_timeOrderRel`.
    declString: |
      lemma timeContract_insert_some_of_lt
          (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (Ï†sÎ› : WickContraction Ï†s.length) (i : Fin Ï†s.length.succ) (k : Ï†sÎ›.uncontracted)
          (ht : ğ“•.timeOrderRel Ï† Ï†s[k.1]) (hik : i < i.succAbove k) :
          (Ï†sÎ› â†©Î› Ï† i (some k)).timeContract =
          ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, (Ï†sÎ›.uncontracted.filter (fun x => x < k))âŸ©)
          â€¢ (contractStateAtIndex Ï† [Ï†sÎ›]áµ˜á¶œ ((uncontractedFieldOpEquiv Ï†s Ï†sÎ›) (some k)) *
            Ï†sÎ›.timeContract) := by
        rw [timeContract_insertAndContract_some]
        simp only [Nat.succ_eq_add_one, Fin.getElem_fin, ite_mul, instCommGroup.eq_1,
          contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
          Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply, Fin.coe_cast,
          List.getElem_map, uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem,
          Algebra.smul_mul_assoc, uncontractedListGet]
        Â· simp only [hik, â†“reduceIte, MulMemClass.coe_mul]
          rw [timeContract_of_timeOrderRel]
          trans (1 : â„‚) â€¢ ((superCommute (anPart Ï†)) (ofFieldOp Ï†s[k.1]) * â†‘Ï†sÎ›.timeContract)
          Â· simp
          simp only [smul_smul]
          congr 1
          have h1 : ofList ğ“•.fieldOpStatistic (List.take (â†‘(Ï†sÎ›.uncontractedIndexEquiv.symm k))
              (List.map Ï†s.get Ï†sÎ›.uncontractedList))
              = (ğ“• |>â‚› âŸ¨Ï†s.get, (Finset.filter (fun x => x < k) Ï†sÎ›.uncontracted)âŸ©) := by
            simp only [ofFinset]
            congr
            rw [â† List.map_take]
            congr
            rw [take_uncontractedIndexEquiv_symm]
            rw [filter_uncontractedList]
          rw [h1]
          simp only [exchangeSign_mul_self]
          Â· exact ht
    declNo: "7.8"

  - type: name
    name: WickContraction.join_sign_timeContract
    line: 432
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.Join
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/Sign/Join.lean#L432"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`,
      and a Wick contraction `Ï†sucÎ›` of `[Ï†sÎ›]áµ˜á¶œ`,
      `(join Ï†sÎ› Ï†sucÎ›).sign â€¢ (join Ï†sÎ› Ï†sucÎ›).timeContract` is equal to the product of
      - `Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract` and
      - `Ï†sucÎ›.sign â€¢ Ï†sucÎ›.timeContract`.
    declString: |
      lemma join_sign_timeContract {Ï†s : List ğ“•.FieldOp} (Ï†sÎ› : WickContraction Ï†s.length)
          (Ï†sucÎ› : WickContraction [Ï†sÎ›]áµ˜á¶œ.length) :
          (join Ï†sÎ› Ï†sucÎ›).sign â€¢ (join Ï†sÎ› Ï†sucÎ›).timeContract.1 =
          (Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract.1) * (Ï†sucÎ›.sign â€¢ Ï†sucÎ›.timeContract.1) := by
        rw [join_timeContract]
        by_cases h : Ï†sÎ›.GradingCompliant
        Â· rw [join_sign _ _ h]
          simp [smul_smul, mul_comm]
        Â· rw [timeContract_of_not_gradingCompliant _ _ h]
          simp
    declNo: "7.9"

  - type: h2
    sectionNo: "7.2"
    content: "Wick terms"

  - type: name
    name: WickContraction.wickTerm
    line: 27
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L27"
    isDef: true
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, and a Wick contraction `Ï†sÎ›` of `Ï†s`, the element
      of `ğ“•.FieldOpAlgebra`, `Ï†sÎ›.wickTerm` is defined as

      `Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract * ğ“([Ï†sÎ›]áµ˜á¶œ)`.

      This is a term which appears in the Wick's theorem.
    declString: |
      def wickTerm {Ï†s : List ğ“•.FieldOp} (Ï†sÎ› : WickContraction Ï†s.length) : ğ“•.FieldOpAlgebra :=
        Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract * ğ“(ofFieldOpList [Ï†sÎ›]áµ˜á¶œ)
    declNo: "7.10"

  - type: name
    name: WickContraction.wickTerm_empty_nil
    line: 36
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L36"
    isDef: false
    isThm: false
    docString: |
      For the empty list `[]` of `ğ“•.FieldOp`, the `wickTerm` of the Wick contraction
      corresponding to the empty set `âˆ…` (the only Wick contraction of `[]`) is `1`.
    declString: |
      lemma wickTerm_empty_nil :
          wickTerm (empty (n := ([] : List ğ“•.FieldOp).length)) = 1 := by
        rw [wickTerm]
        simp [sign_empty]
    declNo: "7.11"

  - type: name
    name: WickContraction.wickTerm_insert_none
    line: 44
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L44"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
        `ğ“•.FieldOp`, and `i â‰¤ Ï†s.length`, then `(Ï†sÎ› â†©Î› Ï† i none).wickTerm` is equal to

      `ğ“¢(Ï†, Ï†â‚€â€¦Ï†áµ¢â‚‹â‚) Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract * ğ“(Ï† :: [Ï†sÎ›]áµ˜á¶œ)`

      The proof of this result relies on
      - `normalOrder_uncontracted_none` to rewrite normal orderings.
      - `timeContract_insert_none` to rewrite the time contract.
      - `sign_insert_none` to rewrite the sign.

    declString: |
      lemma wickTerm_insert_none (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (i : Fin Ï†s.length.succ) (Ï†sÎ› : WickContraction Ï†s.length) :
          (Ï†sÎ› â†©Î› Ï† i none).wickTerm =
          ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, (Finset.univ.filter (fun k => i.succAbove k < i))âŸ©)
          â€¢ (Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract * ğ“(ofFieldOpList (Ï† :: [Ï†sÎ›]áµ˜á¶œ))) := by
        rw [wickTerm]
        by_cases hg : GradingCompliant Ï†s Ï†sÎ›
        Â· rw [normalOrder_uncontracted_none, sign_insert_none _ _ _ _ hg]
          simp only [Nat.succ_eq_add_one, timeContract_insert_none, instCommGroup.eq_1,
            Algebra.mul_smul_comm, Algebra.smul_mul_assoc, smul_smul]
          congr 1
          rw [â† mul_assoc]
          congr 1
          rw [â† map_mul]
          congr
          rw [ofFinset_union]
          congr
          ext a
          simp only [Finset.mem_sdiff, Finset.mem_union, Finset.mem_filter, Finset.mem_univ, true_and,
            Finset.mem_inter, not_and, not_lt, and_imp]
          apply Iff.intro
          Â· intro ha
            have ha1 := ha.1
            rcases ha1 with ha1 | ha1
            Â· exact ha1.2
            Â· exact ha1.2
          Â· intro ha
            simp only [uncontracted, Finset.mem_filter, Finset.mem_univ, true_and, ha, and_true,
              forall_const]
            have hx : Ï†sÎ›.getDual? a = none â†” Â¬ (Ï†sÎ›.getDual? a).isSome := by
              simp
            rw [hx]
            simp only [Bool.not_eq_true, Bool.eq_false_or_eq_true_self, true_and]
            intro h1 h2
            simp_all
        Â· simp only [Nat.succ_eq_add_one, timeContract_insert_none, Algebra.smul_mul_assoc,
          instCommGroup.eq_1]
          rw [timeContract_of_not_gradingCompliant]
          simp only [ZeroMemClass.coe_zero, zero_mul, smul_zero]
          exact hg
    declNo: "7.12"

  - type: name
    name: WickContraction.wickTerm_insert_some
    line: 96
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L96"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
        `ğ“•.FieldOp`, `i â‰¤ Ï†s.length` and a `k` in `Ï†sÎ›.uncontracted`,
        such that all `ğ“•.FieldOp` in `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚` have time strictly less than `Ï†` and
        `Ï†` has a time greater than or equal to all `FieldOp` in `Ï†â‚€â€¦Ï†â‚™`, then
        `(Ï†sÎ› â†©Î› Ï† i (some k)).staticWickTerm`
      is equal to the product of
      - the sign `ğ“¢(Ï†, Ï†â‚€â€¦Ï†áµ¢â‚‹â‚) `
      - the sign `Ï†sÎ›.sign`
      - `Ï†sÎ›.timeContract`
      - `s â€¢ [anPart Ï†, ofFieldOp Ï†s[k]]â‚›` where `s` is the sign associated with moving `Ï†` through
        uncontracted fields in `Ï†â‚€â€¦Ï†â‚–â‚‹â‚`
      - the normal ordering `[Ï†sÎ›]áµ˜á¶œ` with the field corresponding to `k` removed.

      The proof of this result relies on
      - `timeContract_insert_some_of_not_lt`
        and `timeContract_insert_some_of_lt` to rewrite time
        contractions.
      - `normalOrder_uncontracted_some` to rewrite normal orderings.
      - `sign_insert_some_of_not_lt` and `sign_insert_some_of_lt` to rewrite signs.

    declString: |
      lemma wickTerm_insert_some (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp)
          (i : Fin Ï†s.length.succ) (Ï†sÎ› : WickContraction Ï†s.length) (k : Ï†sÎ›.uncontracted)
          (hlt : âˆ€ (k : Fin Ï†s.length), timeOrderRel Ï† Ï†s[k])
          (hn : âˆ€ (k : Fin Ï†s.length), i.succAbove k < i â†’ Â¬ timeOrderRel Ï†s[k] Ï†) :
          (Ï†sÎ› â†©Î› Ï† i (some k)).wickTerm =
          ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, (Finset.univ.filter (fun x => i.succAbove x < i))âŸ©)
          â€¢ (Ï†sÎ›.sign â€¢ (contractStateAtIndex Ï† [Ï†sÎ›]áµ˜á¶œ
            ((uncontractedFieldOpEquiv Ï†s Ï†sÎ›) (some k)) * Ï†sÎ›.timeContract)
          * ğ“(ofFieldOpList (optionEraseZ [Ï†sÎ›]áµ˜á¶œ Ï† (uncontractedFieldOpEquiv Ï†s Ï†sÎ› k)))) := by
        rw [wickTerm]
        by_cases hg : GradingCompliant Ï†s Ï†sÎ› âˆ§ (ğ“• |>â‚› Ï†) = (ğ“• |>â‚› Ï†s[k.1])
        Â· by_cases hk : i.succAbove k < i
          Â· rw [WickContraction.timeContract_insert_some_of_not_lt]
            swap
            Â· exact hn _ hk
            Â· rw [normalOrder_uncontracted_some, sign_insert_some_of_lt Ï† Ï†s Ï†sÎ› i k hk hg]
              simp only [instCommGroup.eq_1, smul_smul, Algebra.smul_mul_assoc]
              congr 1
              rw [mul_assoc, mul_assoc, mul_comm, mul_assoc, mul_assoc]
              simp
            Â· omega
          Â· have hik : i.succAbove â†‘k â‰  i := Fin.succAbove_ne i â†‘k
            rw [timeContract_insert_some_of_lt]
            swap
            Â· exact hlt _
            Â· rw [normalOrder_uncontracted_some]
              rw [sign_insert_some_of_not_lt Ï† Ï†s Ï†sÎ› i k hk hg]
              simp only [instCommGroup.eq_1, smul_smul, Algebra.smul_mul_assoc]
              congr 1
              rw [mul_assoc, mul_assoc, mul_comm, mul_assoc, mul_assoc]
              simp
            Â· omega
        Â· rw [timeContract_insertAndContract_some]
          simp only [Fin.getElem_fin, not_and] at hg
          by_cases hg' : GradingCompliant Ï†s Ï†sÎ›
          Â· have hg := hg hg'
            simp only [Nat.succ_eq_add_one, Fin.getElem_fin, ite_mul, Algebra.smul_mul_assoc,
              instCommGroup.eq_1, contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
              Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply, Fin.coe_cast,
              List.getElem_map, uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem,
              uncontractedListGet]
            by_cases h1 : i < i.succAbove â†‘k
            Â· simp only [h1, â†“reduceIte, MulMemClass.coe_mul]
              rw [timeContract_zero_of_diff_grade]
              simp only [zero_mul, smul_zero]
              rw [superCommute_anPart_ofFieldOpF_diff_grade_zero]
              simp only [zero_mul, smul_zero]
              exact hg
              exact hg
            Â· simp only [h1, â†“reduceIte, MulMemClass.coe_mul]
              rw [timeContract_zero_of_diff_grade]
              simp only [zero_mul, smul_zero]
              rw [superCommute_anPart_ofFieldOpF_diff_grade_zero]
              simp only [zero_mul, smul_zero]
              exact hg
              exact fun a => hg (id (Eq.symm a))
          Â· rw [timeContract_of_not_gradingCompliant]
            simp only [Nat.succ_eq_add_one, Fin.getElem_fin, mul_zero, ZeroMemClass.coe_zero, smul_zero,
              zero_mul, instCommGroup.eq_1]
            exact hg'
    declNo: "7.13"

  - type: name
    name: WickContraction.mul_wickTerm_eq_sum
    line: 177
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L177"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s = Ï†â‚€â€¦Ï†â‚™` of `ğ“•.FieldOp`, a Wick contraction `Ï†sÎ›` of `Ï†s`, an element `Ï†` of
        `ğ“•.FieldOp`, and `i â‰¤ Ï†s.length`
        such that all `ğ“•.FieldOp` in `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚` have time strictly less than `Ï†` and
        `Ï†` has a time greater than or equal to all `FieldOp` in `Ï†â‚€â€¦Ï†â‚™`, then

      `Ï† * Ï†sÎ›.wickTerm = ğ“¢(Ï†, Ï†â‚€â€¦Ï†áµ¢â‚‹â‚) â€¢ âˆ‘ k, (Ï†sÎ› â†©Î› Ï† i k).wickTerm`

      where the sum is over all `k` in `Option Ï†sÎ›.uncontracted`, so `k` is either `none` or `some k`.

      The proof proceeds as follows:
      - `ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum` is used to expand `Ï† ğ“([Ï†sÎ›]áµ˜á¶œ)` as
        a sum over `k` in `Option Ï†sÎ›.uncontracted` of terms involving `[anPart Ï†, Ï†s[k]]â‚›`.
      - Then `wickTerm_insert_none` and `wickTerm_insert_some` are used to equate terms.

    declString: |
      lemma mul_wickTerm_eq_sum (Ï† : ğ“•.FieldOp) (Ï†s : List ğ“•.FieldOp) (i : Fin Ï†s.length.succ)
          (Ï†sÎ› : WickContraction Ï†s.length) (hlt : âˆ€ (k : Fin Ï†s.length), timeOrderRel Ï† Ï†s[k])
          (hn : âˆ€ (k : Fin Ï†s.length), i.succAbove k < i â†’ Â¬timeOrderRel Ï†s[k] Ï†) :
          ofFieldOp Ï† * Ï†sÎ›.wickTerm =
          ğ“¢(ğ“• |>â‚› Ï†, ğ“• |>â‚› âŸ¨Ï†s.get, (Finset.univ.filter (fun x => i.succAbove x < i))âŸ©) â€¢
          âˆ‘ (k : Option Ï†sÎ›.uncontracted), (Ï†sÎ› â†©Î› Ï† i k).wickTerm := by
        trans (Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract) * ((ofFieldOp Ï†) * ğ“(ofFieldOpList [Ï†sÎ›]áµ˜á¶œ))
        Â· have ht := Subalgebra.mem_center_iff.mp (Subalgebra.smul_mem (Subalgebra.center â„‚ _)
            (WickContraction.timeContract Ï†sÎ›).2 (Ï†sÎ›.sign))
          rw [wickTerm]
          rw [â† mul_assoc, ht, mul_assoc]
        rw [ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum, Finset.mul_sum,
          uncontractedFieldOpEquiv_list_sum, Finset.smul_sum]
        simp only [instCommGroup.eq_1, Nat.succ_eq_add_one]
        congr 1
        funext n
        match n with
        | none =>
          rw [wickTerm_insert_none]
          simp only [contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
            Equiv.coe_trans, Option.map_none', one_mul, Algebra.smul_mul_assoc, instCommGroup.eq_1,
            smul_smul]
          congr 1
          rw [â† mul_assoc, exchangeSign_mul_self]
          simp
        | some n =>
          rw [wickTerm_insert_some _ _ _ _ _
            (fun k => hlt k) (fun k a => hn k a)]
          simp only [uncontractedFieldOpEquiv, Equiv.optionCongr_apply, Equiv.coe_trans, Option.map_some',
            Function.comp_apply, finCongr_apply, Algebra.smul_mul_assoc, instCommGroup.eq_1, smul_smul]
          congr 1
          Â· rw [â† mul_assoc, exchangeSign_mul_self]
            rw [one_mul]
          Â· rw [â† mul_assoc]
            congr 1
            have ht := (WickContraction.timeContract Ï†sÎ›).prop
            rw [@Subalgebra.mem_center_iff] at ht
            rw [ht]
    declNo: "7.14"

  - type: h2
    sectionNo: "7.3"
    content: "Wick's theorem"

  - type: name
    name: FieldSpecification.wicks_theorem
    line: 64
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheorem
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WicksTheorem.lean#L64"
    isDef: false
    isThm: true
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, Wick's theorem states that

      `ğ“£(Ï†s) = âˆ‘ Ï†sÎ›, Ï†sÎ›.wickTerm`

      where the sum is over all Wick contraction `Ï†sÎ›`.

      The proof is via induction on `Ï†s`.
      - The base case `Ï†s = []` is handled by `wickTerm_empty_nil`.

      The inductive step works as follows:

      For the LHS:
      1. `timeOrder_eq_maxTimeField_mul_finset` is used to write
        `ğ“£(Ï†â‚€â€¦Ï†â‚™)` as `ğ“¢(Ï†áµ¢,Ï†â‚€â€¦Ï†áµ¢â‚‹â‚) â€¢ Ï†áµ¢ * ğ“£(Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚Ï†â‚™)` where `Ï†áµ¢` is
        the maximal time field in `Ï†â‚€â€¦Ï†â‚™`
      2. The induction hypothesis is then used on `ğ“£(Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚Ï†â‚™)` to expand it as a sum over
        Wick contractions of `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚Ï†â‚™`.
      3. This gives terms of the form `Ï†áµ¢ * Ï†sÎ›.wickTerm` on which
        `mul_wickTerm_eq_sum` is used where `Ï†sÎ›` is a Wick contraction of `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚Ï†`,
        to rewrite terms as a sum over optional uncontracted elements of `Ï†sÎ›`

      On the LHS we now have a sum over Wick contractions `Ï†sÎ›` of `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚Ï†` (from 2) and optional
      uncontracted elements of `Ï†sÎ›` (from 3)

      For the RHS:
      1. The sum over Wick contractions of `Ï†â‚€â€¦Ï†â‚™` on the RHS
        is split via `insertLift_sum` into a sum over Wick contractions `Ï†sÎ›` of `Ï†â‚€â€¦Ï†áµ¢â‚‹â‚Ï†áµ¢â‚Šâ‚Ï†` and
        sum over optional uncontracted elements of `Ï†sÎ›`.

      Both sides are now sums over the same thing and their terms equate by the nature of the
      lemmas used.

    declString: |
      theorem wicks_theorem : (Ï†s : List ğ“•.FieldOp) â†’ ğ“£(ofFieldOpList Ï†s) =
          âˆ‘ (Ï†sÎ› : WickContraction Ï†s.length), Ï†sÎ›.wickTerm
        | [] => by
          rw [timeOrder_ofFieldOpList_nil]
          simp only [map_one, List.length_nil, Algebra.smul_mul_assoc]
          rw [sum_WickContraction_nil]
          simp only [wickTerm_empty_nil]
        | Ï† :: Ï†s => by
          have ih := wicks_theorem (eraseMaxTimeField Ï† Ï†s)
          conv_lhs => rw [timeOrder_eq_maxTimeField_mul_finset, ih, Finset.mul_sum]
          have h1 : Ï† :: Ï†s =
              (eraseMaxTimeField Ï† Ï†s).insertIdx (maxTimeFieldPosFin Ï† Ï†s) (maxTimeField Ï† Ï†s) := by
            simp only [eraseMaxTimeField, insertionSortDropMinPos, List.length_cons, Nat.succ_eq_add_one,
              maxTimeField, insertionSortMin, List.get_eq_getElem]
            erw [insertIdx_eraseIdx_fin]
          conv_rhs => rw [wicks_theorem_congr h1]
          conv_rhs => rw [insertLift_sum]
          apply Finset.sum_congr rfl
          intro c _
          rw [Algebra.smul_mul_assoc, mul_wickTerm_eq_sum
            (maxTimeField Ï† Ï†s) (eraseMaxTimeField Ï† Ï†s) (maxTimeFieldPosFin Ï† Ï†s) c]
          trans (1 : â„‚) â€¢ âˆ‘ k : Option { x // x âˆˆ c.uncontracted },
            (c â†©Î› (maxTimeField Ï† Ï†s) (maxTimeFieldPosFin Ï† Ï†s) k).wickTerm
          swap
          Â· simp [uncontractedListGet]
          rw [smul_smul]
          simp only [instCommGroup.eq_1, exchangeSign_mul_self, Nat.succ_eq_add_one,
            Algebra.smul_mul_assoc, Fintype.sum_option, timeContract_insert_none,
            Finset.univ_eq_attach, smul_add, one_smul, uncontractedListGet]
          Â· exact fun k => timeOrder_maxTimeField _ _ k
          Â· exact fun k => lt_maxTimeFieldPosFin_not_timeOrder _ _ k
      termination_by Ï†s => Ï†s.length
    declNo: "7.15"

  - type: h1
    sectionNo: 8
    content: "Normal-ordered Wick's theorem"

  - type: name
    name: WickContraction.EqTimeOnly.timeOrder_staticContract_of_not_mem
    line: 250
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeCond
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/TimeCond.lean#L250"
    isDef: false
    isThm: false
    docString: |
      Let `Ï†s` be a list of `ğ“•.FieldOp` and `Ï†sÎ›` a `WickContraction` with
      at least one contraction between `ğ“•.FieldOp` that do not have the same time. Then
      `ğ“£(Ï†sÎ›.staticContract.1) = 0`.
    declString: |
      lemma timeOrder_staticContract_of_not_mem {Ï†s : List ğ“•.FieldOp} (Ï†sÎ› : WickContraction Ï†s.length)
          (hl : Â¬ Ï†sÎ›.EqTimeOnly) : ğ“£(Ï†sÎ›.staticContract.1) = 0 := by
        obtain âŸ¨i, j, hij, Ï†sucÎ›, rfl, hrâŸ© := exists_join_singleton_of_not_eqTimeOnly Ï†sÎ› hl
        rw [join_staticContract]
        simp only [MulMemClass.coe_mul]
        rw [singleton_staticContract]
        rw [timeOrder_timeOrder_left]
        rw [timeOrder_superCommute_anPart_ofFieldOp_neq_time]
        simp only [zero_mul, map_zero]
        intro h
        simp_all
    declNo: "8.1"

  - type: name
    name: WickContraction.EqTimeOnly.staticContract_eq_timeContract_of_eqTimeOnly
    line: 99
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeCond
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/TimeCond.lean#L99"
    isDef: false
    isThm: false
    docString: |
      Let `Ï†s` be a list of `ğ“•.FieldOp` and `Ï†sÎ›` a `WickContraction` of `Ï†s` within
      which every contraction involves two `ğ“•.FieldOp`s that have the same time, then
      `Ï†sÎ›.staticContract = Ï†sÎ›.timeContract`.
    declString: |
      lemma staticContract_eq_timeContract_of_eqTimeOnly (h : Ï†sÎ›.EqTimeOnly) :
          Ï†sÎ›.staticContract = Ï†sÎ›.timeContract := by
        simp only [staticContract, timeContract]
        apply congrArg
        funext a
        ext
        simp only [List.get_eq_getElem]
        rw [timeContract_of_timeOrderRel]
        apply timeOrderRel_of_eqTimeOnly_pair Ï†sÎ›
        rw [â† finset_eq_fstFieldOfContract_sndFieldOfContract]
        exact a.2
        exact h
    declNo: "8.2"

  - type: name
    name: WickContraction.EqTimeOnly.timeOrder_timeContract_mul_of_eqTimeOnly_left
    line: 196
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeCond
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/WickContraction/TimeCond.lean#L196"
    isDef: false
    isThm: false
    docString: |
      Let `Ï†s` be a list of `ğ“•.FieldOp`, `Ï†sÎ›` a `WickContraction` of `Ï†s` within
      which every contraction involves two `ğ“•.FieldOp`s that have the same time and
      `b` a general element in `ğ“•.FieldOpAlgebra`. Then
      `ğ“£(Ï†sÎ›.timeContract.1 * b) = Ï†sÎ›.timeContract.1 * ğ“£(b)`.

      This follows from properties of orderings and the ideal defining `ğ“•.FieldOpAlgebra`.
    declString: |
      lemma timeOrder_timeContract_mul_of_eqTimeOnly_left {Ï†s : List ğ“•.FieldOp}
          (Ï†sÎ› : WickContraction Ï†s.length)
          (hl : Ï†sÎ›.EqTimeOnly) (b : ğ“•.FieldOpAlgebra) :
          ğ“£(Ï†sÎ›.timeContract.1 * b) = Ï†sÎ›.timeContract.1 * ğ“£(b) := by
        trans ğ“£(1 * Ï†sÎ›.timeContract.1 * b)
        simp only [one_mul]
        rw [timeOrder_timeContract_mul_of_eqTimeOnly_mid Ï†sÎ› hl]
        simp
    declNo: "8.3"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder_ofFieldOpList_eqTimeOnly
    line: 23
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WicksTheoremNormal.lean#L23"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, then

      `ğ“£(Ï†s) = âˆ‘ Ï†sÎ›, Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract * ğ“£(ğ“([Ï†sÎ›]áµ˜á¶œ))`

      where the sum is over all Wick contraction `Ï†sÎ›` which only have equal time contractions.

      This result follows from
      - `static_wick_theorem` to rewrite `ğ“£(Ï†s)` on the left hand side as a sum of
        `ğ“£(Ï†sÎ›.staticWickTerm)`.
      - `EqTimeOnly.timeOrder_staticContract_of_not_mem` and `timeOrder_timeOrder_mid` to set to
        those `ğ“£(Ï†sÎ›.staticWickTerm)` for which `Ï†sÎ›` has a contracted pair which are not
        equal time to zero.
      - `staticContract_eq_timeContract_of_eqTimeOnly` to rewrite the static contract
        in the remaining `ğ“£(Ï†sÎ›.staticWickTerm)` as a time contract.
      - `timeOrder_timeContract_mul_of_eqTimeOnly_left` to move the time contracts out of the time
        ordering.

    declString: |
      lemma timeOrder_ofFieldOpList_eqTimeOnly (Ï†s : List ğ“•.FieldOp) :
          ğ“£(ofFieldOpList Ï†s) = âˆ‘ (Ï†sÎ› : {Ï†sÎ› // Ï†sÎ›.EqTimeOnly (Ï†s := Ï†s)}),
          Ï†sÎ›.1.sign â€¢ Ï†sÎ›.1.timeContract.1 * ğ“£(ğ“(ofFieldOpList [Ï†sÎ›.1]áµ˜á¶œ)) := by
        rw [static_wick_theorem Ï†s]
        let e2 : WickContraction Ï†s.length â‰ƒ
          {Ï†sÎ› : WickContraction Ï†s.length // Ï†sÎ›.EqTimeOnly} âŠ•
          {Ï†sÎ› : WickContraction Ï†s.length // Â¬ Ï†sÎ›.EqTimeOnly} :=
          (Equiv.sumCompl _).symm
        rw [â† e2.symm.sum_comp]
        simp only [Equiv.symm_symm, Algebra.smul_mul_assoc, Fintype.sum_sum_type,
          Equiv.sumCompl_apply_inl, Equiv.sumCompl_apply_inr, map_add, map_sum, map_smul, e2]
        simp only [staticWickTerm, Algebra.smul_mul_assoc, map_smul]
        conv_lhs =>
          enter [2, 2, x]
          rw [timeOrder_timeOrder_left]
          rw [timeOrder_staticContract_of_not_mem _ x.2]
        simp only [Finset.univ_eq_attach, zero_mul, map_zero, smul_zero, Finset.sum_const_zero, add_zero]
        congr
        funext x
        rw [staticContract_eq_timeContract_of_eqTimeOnly]
        rw [timeOrder_timeContract_mul_of_eqTimeOnly_left]
        exact x.2
        exact x.2
    declNo: "8.4"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder_timeOrder_ofFieldOpList_eq_eqTimeOnly_empty
    line: 92
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WicksTheoremNormal.lean#L92"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, then

      `ğ“£(ğ“(Ï†s)) = ğ“£(Ï†s) - âˆ‘ Ï†sÎ›, Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract.1 * ğ“£(ğ“([Ï†sÎ›]áµ˜á¶œ))`

      where the sum is over all *non-empty* Wick contraction `Ï†sÎ›` which only
        have equal time contractions.

      This result follows directly from
      - `timeOrder_ofFieldOpList_eqTimeOnly`

    declString: |
      lemma normalOrder_timeOrder_ofFieldOpList_eq_eqTimeOnly_empty (Ï†s : List ğ“•.FieldOp) :
          ğ“£(ğ“(ofFieldOpList Ï†s)) = ğ“£(ofFieldOpList Ï†s) -
          âˆ‘ (Ï†sÎ› : {Ï†sÎ› // Ï†sÎ›.EqTimeOnly (Ï†s := Ï†s) âˆ§ Ï†sÎ› â‰  empty}),
          Ï†sÎ›.1.sign â€¢ Ï†sÎ›.1.timeContract.1 * ğ“£(ğ“(ofFieldOpList [Ï†sÎ›.1]áµ˜á¶œ)) := by
        rw [timeOrder_ofFieldOpList_eq_eqTimeOnly_empty]
        simp
    declNo: "8.5"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder_haveEqTime_split
    line: 110
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WicksTheoremNormal.lean#L110"
    isDef: false
    isThm: false
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, then `ğ“£(Ï†s)` is equal to the sum of

      - `âˆ‘ Ï†sÎ›, Ï†sÎ›.wickTerm` where the sum is over all Wick contraction `Ï†sÎ›` which have
        no contractions of equal time.
      - `âˆ‘ Ï†sÎ›, Ï†sÎ›.sign â€¢ Ï†sÎ›.timeContract * (âˆ‘ Ï†ssucÎ›, Ï†ssucÎ›.wickTerm)`, where
        the first sum is over all Wick contraction `Ï†sÎ›` which only have equal time contractions
        and the second sum is over all Wick contraction `Ï†ssucÎ›` of the uncontracted elements of `Ï†sÎ›`
        which do not have any equal time contractions.

      The proof proceeds as follows
      - `wicks_theorem` is used to rewrite `ğ“£(Ï†s)` as a sum over all Wick contractions.
      - The sum over all Wick contractions is then split additively into two parts based on having
        or not having an equal time contractions.
      - Using `join`, the sum `âˆ‘ Ï†sÎ›, _` over Wick contractions which do have equal time contractions
        is split into two sums `âˆ‘ Ï†sÎ›, âˆ‘ Ï†sucÎ›, _`, the first over non-zero elements
        which only have equal time contractions and the second over Wick contractions `Ï†sucÎ›` of
        `[Ï†sÎ›]áµ˜á¶œ` which do not have equal time contractions.
      - `join_sign_timeContract` is then used to equate terms.

    declString: |
      lemma timeOrder_haveEqTime_split (Ï†s : List ğ“•.FieldOp) :
          ğ“£(ofFieldOpList Ï†s) = (âˆ‘ (Ï†sÎ› : {Ï†sÎ› : WickContraction Ï†s.length // Â¬ HaveEqTime Ï†sÎ›}),
          Ï†sÎ›.1.sign â€¢ Ï†sÎ›.1.timeContract.1 * ğ“(ofFieldOpList [Ï†sÎ›.1]áµ˜á¶œ))
          + âˆ‘ (Ï†sÎ› : {Ï†sÎ› // Ï†sÎ›.EqTimeOnly (Ï†s := Ï†s) âˆ§ Ï†sÎ› â‰  empty}), Ï†sÎ›.1.sign â€¢ Ï†sÎ›.1.timeContract *
          (âˆ‘ Ï†ssucÎ› : { Ï†ssucÎ› : WickContraction [Ï†sÎ›.1]áµ˜á¶œ.length // Â¬ Ï†ssucÎ›.HaveEqTime },
            Ï†ssucÎ›.1.wickTerm) := by
        rw [wicks_theorem]
        simp only [wickTerm]
        let e1 : WickContraction Ï†s.length â‰ƒ {Ï†sÎ› // HaveEqTime Ï†sÎ›} âŠ• {Ï†sÎ› // Â¬ HaveEqTime Ï†sÎ›} := by
          exact (Equiv.sumCompl HaveEqTime).symm
        rw [â† e1.symm.sum_comp]
        simp only [Equiv.symm_symm, Algebra.smul_mul_assoc, Fintype.sum_sum_type,
          Equiv.sumCompl_apply_inl, Equiv.sumCompl_apply_inr, ne_eq, sub_left_inj, e1]
        rw [add_comm]
        congr 1
        let f : WickContraction Ï†s.length â†’ ğ“•.FieldOpAlgebra := fun Ï†sÎ› =>
          Ï†sÎ›.sign â€¢ (Ï†sÎ›.timeContract.1 * ğ“(ofFieldOpList [Ï†sÎ›]áµ˜á¶œ))
        change âˆ‘ (Ï†sÎ› : {Ï†sÎ› : WickContraction Ï†s.length // HaveEqTime Ï†sÎ›}), f Ï†sÎ›.1 = _
        rw [sum_haveEqTime]
        congr
        funext Ï†sÎ›
        simp only [f]
        conv_lhs =>
          enter [2, Ï†sucÎ›]
          rw [â† Algebra.smul_mul_assoc]
          rw [join_sign_timeContract Ï†sÎ›.1 Ï†sucÎ›.1]
        conv_lhs =>
          enter [2, Ï†sucÎ›]
          rw [mul_assoc]
        rw [â† Finset.mul_sum, â† Algebra.smul_mul_assoc]
        congr
        funext Ï†sÎ›'
        simp only [ne_eq, Algebra.smul_mul_assoc]
        congr 1
        rw [@join_uncontractedListGet]
    declNo: "8.6"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.wicks_theorem_normal_order
    line: 218
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/PerturbationTheory/FieldOpAlgebra/WicksTheoremNormal.lean#L218"
    isDef: false
    isThm: true
    docString: |
      For a list `Ï†s` of `ğ“•.FieldOp`, the normal-ordered version of Wick's theorem states that

      `ğ“£(ğ“(Ï†s)) = âˆ‘ Ï†sÎ›, Ï†sÎ›.wickTerm`

      where the sum is over all Wick contraction `Ï†sÎ›` in which no two contracted elements
      have the same time.

      The proof proceeds by induction on `Ï†s`, with the base case `[]` holding by following
      through definitions. and the inductive case holding as a result of
      - `timeOrder_haveEqTime_split`
      - `normalOrder_timeOrder_ofFieldOpList_eq_eqTimeOnly_empty`
      - and the induction hypothesis on `ğ“£(ğ“([Ï†sÎ›.1]áµ˜á¶œ))` for contractions `Ï†sÎ›` of `Ï†s` which only
        have equal time contractions and are non-empty.

    declString: |
      theorem wicks_theorem_normal_order : (Ï†s : List ğ“•.FieldOp) â†’
          ğ“£(ğ“(ofFieldOpList Ï†s)) =
          âˆ‘ (Ï†sÎ› : {Ï†sÎ› : WickContraction Ï†s.length // Â¬ HaveEqTime Ï†sÎ›}), Ï†sÎ›.1.wickTerm
        | [] => wicks_theorem_normal_order_empty
        | Ï† :: Ï†s => by
          rw [normalOrder_timeOrder_ofFieldOpList_eq_not_haveEqTime_sub_inductive]
          simp only [Algebra.smul_mul_assoc, ne_eq, add_right_eq_self]
          apply Finset.sum_eq_zero
          intro Ï†sÎ› hÏ†sÎ›
          simp only [smul_eq_zero]
          right
          have ih := wicks_theorem_normal_order [Ï†sÎ›.1]áµ˜á¶œ
          rw [ih]
          simp [wickTerm]
      termination_by Ï†s => Ï†s.length
      decreasing_by
        simp only [uncontractedListGet, List.length_cons, List.length_map, gt_iff_lt]
        rw [uncontractedList_length_eq_card]
        have hc := uncontracted_card_eq_iff Ï†sÎ›.1
        simp only [List.length_cons, Ï†sÎ›.2.2, iff_false] at hc
        have hc' := uncontracted_card_le Ï†sÎ›.1
        simp_all only [Algebra.smul_mul_assoc, List.length_cons, Finset.mem_univ, gt_iff_lt]
        omega
    declNo: "8.7"
